{"implements":[],"javadoc":"<code>LongKeyRecordNode<\/code> is an implementation of a BTree leaf node\n which utilizes variable-length key values and stores variable-length records.\n This type of node has the following layout within a single DataBuffer \n (field size in bytes):\n <pre>\n   |   NodeType(1) | KeyType(1) | KeyCount(4) | PrevLeafId(4) | NextLeafId(4) | KeyOffset0(4) | IndFlag0(1) |...      \n \n   | KeyOffsetN(4) | IndFlagN(1) |...<FreeSpace>... | KeyN | RecN |... | Key0 | Rec0 |\n <\/pre>\n IndFlag - if not zero the record has been stored within a chained DBBuffer \n whose 4-byte integer buffer ID has been stored within this leaf at the record offset.","static":false,"extends":"db.VarKeyNode","methods":[{"javadoc":"Construct an existing variable-length-key record leaf node.\n@param nodeMgr table node manager instance\n@param buf node buffer","static":false,"name":"<init>","comment":"Construct an existing variable-length-key record leaf node.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager instance","type_short":"NodeMgr"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"node buffer","type_short":"DataBuffer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new variable-length-key record leaf node.\n@param nodeMgr table node manager.\n@param prevLeafId node buffer id for previous leaf ( &lt; 0: no leaf)\n@param nextLeafId node buffer id for next leaf ( &lt; 0 : no leaf)\n@param keyType key Field type\n@throws IOException thrown if IO error occurs","static":false,"name":"<init>","comment":"Construct a new variable-length-key record leaf node.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager.","type_short":"NodeMgr"},{"type_long":"int","name":"prevLeafId","comment":"node buffer id for previous leaf (  0: no leaf)","type_short":"int"},{"type_long":"int","name":"nextLeafId","comment":"node buffer id for next leaf (  0 : no leaf)","type_short":"int"},{"type_long":"db.Field","name":"keyType","comment":"key Field type","type_short":"Field"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new variable-length-key record leaf node with no siblings.\n@param nodeMgr table node manager.\n@param keyType key Field type\n@throws IOException thrown if IO error occurs","static":false,"name":"<init>","comment":"Construct a new variable-length-key record leaf node with no siblings.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager.","type_short":"NodeMgr"},{"type_long":"db.Field","name":"keyType","comment":"key Field type","type_short":"Field"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"logConsistencyError","comment":"","params":[{"type_long":"java.lang.String","name":"tableName","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"msg","comment":"","type_short":"String"},{"type_long":"java.lang.Throwable","name":"t","comment":"","type_short":"Throwable"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isConsistent","comment":"","params":[{"type_long":"java.lang.String","name":"tableName","comment":"","type_short":"String"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getLeafNode","comment":"","params":[{"type_long":"db.Field","name":"key","comment":"","type_short":"Field"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.VarKeyRecordNode","comment":"","type_short":"VarKeyRecordNode"}},{"javadoc":"","static":false,"name":"getLeftmostLeafNode","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.VarKeyRecordNode","comment":"","type_short":"VarKeyRecordNode"}},{"javadoc":"","static":false,"name":"getRightmostLeafNode","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.VarKeyRecordNode","comment":"","type_short":"VarKeyRecordNode"}},{"javadoc":"Get this leaf node's right sibling\n@return this leaf node's right sibling or null if right sibling does not exist.\n@throws IOException thrown if an IO error occurs","static":false,"name":"getNextLeaf","comment":"Get this leaf node's right sibling","params":[],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyRecordNode","comment":"this leaf node's right sibling or null if right sibling does not exist.","type_short":"VarKeyRecordNode"}},{"javadoc":"Get this leaf node's left sibling\n@return this leaf node's left sibling or null if left sibling does not exist.\n@throws IOException thrown if an IO error occurs","static":false,"name":"getPreviousLeaf","comment":"Get this leaf node's left sibling","params":[],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyRecordNode","comment":"this leaf node's left sibling or null if left sibling does not exist.","type_short":"VarKeyRecordNode"}},{"javadoc":"Perform a binary search to locate the specified key and derive an index\n into the Buffer ID storage.\n@param key\n@return int buffer ID index.\n@throws IOException thrown if an IO error occurs","static":false,"name":"getKeyIndex","comment":"Perform a binary search to locate the specified key and derive an index\n into the Buffer ID storage.","params":[{"type_long":"db.Field","name":"key","comment":"","type_short":"Field"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"int","comment":"int buffer ID index.","type_short":"int"}},{"javadoc":"Split this leaf node in half and update tree.\n When a split is performed, the next operation must be performed\n from the root node since the tree may have been restructured.\n@return root node which may have changed.\n@throws IOException thrown if an IO error occurs","static":false,"name":"split","comment":"Split this leaf node in half and update tree.\n When a split is performed, the next operation must be performed\n from the root node since the tree may have been restructured.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Append a leaf which contains one or more keys and update tree.  Leaf is inserted\n as the new right sibling of this leaf.\n@param newLeaf new right sibling leaf (must be same node type as this leaf)\n@return root node which may have changed.\n@throws IOException thrown if an IO error occurs","static":false,"name":"appendLeaf","comment":"Append a leaf which contains one or more keys and update tree.  Leaf is inserted\n as the new right sibling of this leaf.","params":[{"type_long":"db.VarKeyRecordNode","name":"leaf","comment":"","type_short":"VarKeyRecordNode"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Insert or Update a record.\n@param record data record with long key\n@param table table which will be notified when record is inserted or updated.\n@return root node which may have changed.\n@throws IOException thrown if IO error occurs","static":false,"name":"putRecord","comment":"Insert or Update a record.","params":[{"type_long":"db.Record","name":"record","comment":"data record with long key","type_short":"Record"},{"type_long":"db.Table","name":"table","comment":"table which will be notified when record is inserted or updated.","type_short":"Table"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Append a new leaf and insert the specified record.\n@param record data record with long key\n@return root node which may have changed.\n@throws IOException thrown if IO error occurs","static":false,"name":"appendNewLeaf","comment":"Append a new leaf and insert the specified record.","params":[{"type_long":"db.Record","name":"record","comment":"data record with long key","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Delete the record identified by the specified key.\n@param key record key\n@param table table which will be notified when record is deleted.\n@return root node which may have changed.\n@throws IOException thrown if IO error occurs","static":false,"name":"deleteRecord","comment":"Delete the record identified by the specified key.","params":[{"type_long":"db.Field","name":"key","comment":"record key","type_short":"Field"},{"type_long":"db.Table","name":"table","comment":"table which will be notified when record is deleted.","type_short":"Table"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Get the first record whoose key is less than the specified key.\n@param key record key\n@param schema record data schema\n@return Record requested or null if record not found.\n@throws IOException thrown if IO error occurs","static":false,"name":"getRecordBefore","comment":"Get the first record whoose key is less than the specified key.","params":[{"type_long":"db.Field","name":"key","comment":"record key","type_short":"Field"},{"type_long":"db.Schema","name":"schema","comment":"record data schema","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"Record requested or null if record not found.","type_short":"Record"}},{"javadoc":"Get the first record whoose key is greater than the specified key.\n@param key record key\n@param schema record data schema\n@return Record requested or null if record not found.\n@throws IOException thrown if IO error occurs","static":false,"name":"getRecordAfter","comment":"Get the first record whoose key is greater than the specified key.","params":[{"type_long":"db.Field","name":"key","comment":"record key","type_short":"Field"},{"type_long":"db.Schema","name":"schema","comment":"record data schema","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"Record requested or null if record not found.","type_short":"Record"}},{"javadoc":"Get the first record whoose key is less than or equal to the specified\n key.\n@param key record key\n@param schema record data schema\n@return Record requested or null if record not found.\n@throws IOException thrown if IO error occurs","static":false,"name":"getRecordAtOrBefore","comment":"Get the first record whoose key is less than or equal to the specified\n key.","params":[{"type_long":"db.Field","name":"key","comment":"record key","type_short":"Field"},{"type_long":"db.Schema","name":"schema","comment":"record data schema","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"Record requested or null if record not found.","type_short":"Record"}},{"javadoc":"Get the first record whoose key is greater than or equal to the specified\n key.\n@param key record key\n@param schema record data schema\n@return Record requested or null if record not found.\n@throws IOException thrown if IO error occurs","static":false,"name":"getRecordAtOrAfter","comment":"Get the first record whoose key is greater than or equal to the specified\n key.","params":[{"type_long":"db.Field","name":"key","comment":"record key","type_short":"Field"},{"type_long":"db.Schema","name":"schema","comment":"record data schema","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"Record requested or null if record not found.","type_short":"Record"}},{"javadoc":"Create a new leaf and add to the node manager.\n The new leaf's parent is unknown.\n@param prevLeafId node buffer id for previous leaf - left sibling ( &lt; 0: no leaf)\n@param nextLeafId node buffer id for next leaf - right sibling ( &lt; 0 : no leaf)\n@return new leaf node.\n@throws IOException thrown if IO error occurs","static":false,"name":"createNewLeaf","comment":"Create a new leaf and add to the node manager.\n The new leaf's parent is unknown.","params":[{"type_long":"int","name":"prevLeafId","comment":"node buffer id for previous leaf - left sibling (  0: no leaf)","type_short":"int"},{"type_long":"int","name":"nextLeafId","comment":"node buffer id for next leaf - right sibling (  0 : no leaf)","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyRecordNode","comment":"new leaf node.","type_short":"VarKeyRecordNode"}},{"javadoc":"","static":false,"name":"getKey","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.Field","comment":"","type_short":"Field"}},{"javadoc":"Get the record data offset within the buffer\n@param index key index\n@return record data offset","static":false,"name":"getRecordDataOffset","comment":"Get the record data offset within the buffer","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"record data offset","type_short":"int"}},{"javadoc":"Get the record key offset within the buffer\n@param index key index\n@return record key offset","static":false,"name":"getRecordKeyOffset","comment":"Get the record key offset within the buffer","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"record key offset","type_short":"int"}},{"javadoc":"Store the record key offset within the buffer for the specified key index.\n The record data immediately follows the stored key for the record.\n@param index key index\n@param offset key offset","static":false,"name":"putRecordKeyOffset","comment":"Store the record key offset within the buffer for the specified key index.\n The record data immediately follows the stored key for the record.","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"},{"type_long":"int","name":"offset","comment":"key offset","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determine if a record is utilizing a chained DBBuffer for data storage\n@param index key index\n@return true if indirect storage is used for record, else false","static":false,"name":"hasIndirectStorage","comment":"Determine if a record is utilizing a chained DBBuffer for data storage","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"true if indirect storage is used for record, else false","type_short":"boolean"}},{"javadoc":"Set the indirect storage flag associated with a record\n@param index key index\n@param state indirect storage used (true) or not used (false)","static":false,"name":"enableIndirectStorage","comment":"Set the indirect storage flag associated with a record","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"},{"type_long":"boolean","name":"state","comment":"indirect storage used (true) or not used (false)","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return unused free space within node","static":false,"name":"getFreeSpace","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"unused free space within node","type_short":"int"}},{"javadoc":"Get the length of a stored record with key.\n@param keyIndex key index associated with record.","static":false,"name":"getFullRecordLength","comment":"Get the length of a stored record with key.","params":[{"type_long":"int","name":"keyIndex","comment":"key index associated with record.","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Move all records from index to the end by the specified offset.\n@param index the smaller key index (0 &lt;= index1)\n@param offset movement offset in bytes\n@return insertion offset immediately following moved block.","static":false,"name":"moveRecords","comment":"Move all records from index to the end by the specified offset.","params":[{"type_long":"int","name":"index","comment":"the smaller key index (0 = index1)","type_short":"int"},{"type_long":"int","name":"offset","comment":"movement offset in bytes","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"insertion offset immediately following moved block.","type_short":"int"}},{"javadoc":"Get the record located at the specified index.\n@param schema record data schema\n@param index key index\n@return Record","static":false,"name":"getRecord","comment":"Get the record located at the specified index.","params":[{"type_long":"db.Schema","name":"schema","comment":"record data schema","type_short":"Schema"},{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"Record","type_short":"Record"}},{"javadoc":"Get the record identified by the specified key.\n@param key record key\n@param schema record data schema\n@return Record requested or null if record not found.\n@throws IOException thrown if IO error occurs","static":false,"name":"getRecord","comment":"Get the record identified by the specified key.","params":[{"type_long":"db.Field","name":"key","comment":"record key","type_short":"Field"},{"type_long":"db.Schema","name":"schema","comment":"record data schema","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"Record requested or null if record not found.","type_short":"Record"}},{"javadoc":"Find the index which represents the halfway point within the record data.\n@returns key index.","static":false,"name":"getSplitIndex","comment":"Find the index which represents the halfway point within the record data.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Split the contents of this leaf node; placing the right half of the records into the\n empty leaf node provided.\n@param newRightLeaf empty right sibling leaf","static":false,"name":"splitData","comment":"Split the contents of this leaf node; placing the right half of the records into the\n empty leaf node provided.","params":[{"type_long":"db.VarKeyRecordNode","name":"rightNode","comment":"","type_short":"VarKeyRecordNode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Updates the record at the given index.\n@param index record index\n@param record new record\n@return root node which may have changed.\n@throws IOException thrown if IO error occurs","static":false,"name":"updateRecord","comment":"Updates the record at the given index.","params":[{"type_long":"int","name":"index","comment":"record index","type_short":"int"},{"type_long":"db.Record","name":"record","comment":"new record","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Inserts the record at the given index if there is sufficient space in\n the buffer.\n@param keyIndex insertion index\n@param record record to be inserted\n@return true if the record was successfully inserted.\n@throws IOException thrown if IO error occurs","static":false,"name":"insertRecord","comment":"Inserts the record at the given index if there is sufficient space in\n the buffer.","params":[{"type_long":"int","name":"keyIndex","comment":"insertion index","type_short":"int"},{"type_long":"db.Record","name":"record","comment":"record to be inserted","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if the record was successfully inserted.","type_short":"boolean"}},{"javadoc":"Remove the record identified by index.\n This will never be the last record within the node.\n@param index record index\n@throws IOException thrown if IO error occurs","static":false,"name":"remove","comment":"Remove the record identified by index.\n This will never be the last record within the node.","params":[{"type_long":"int","name":"index","comment":"record index","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Remove this leaf and all associated chained buffers from the tree.\n@return root node which may have changed.\n@throws IOException thrown if IO error occurs","static":false,"name":"removeLeaf","comment":"Remove this leaf and all associated chained buffers from the tree.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.VarKeyNode","comment":"root node which may have changed.","type_short":"VarKeyNode"}},{"javadoc":"Remove a chained buffer.\n@param bufferId chained buffer ID","static":false,"name":"removeChainedBuffer","comment":"Remove a chained buffer.","params":[{"type_long":"int","name":"bufferId","comment":"chained buffer ID","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"delete","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getBufferReferences","comment":"","params":[],"throws":[],"return":{"type_long":"int[]","comment":"","type_short":"int[]"}}],"name":"VarKeyRecordNode","comment":"LongKeyRecordNode is an implementation of a BTree leaf node\n which utilizes variable-length key values and stores variable-length records.\n This type of node has the following layout within a single DataBuffer \n (field size in bytes):\n \n   |   NodeType(1) | KeyType(1) | KeyCount(4) | PrevLeafId(4) | NextLeafId(4) | KeyOffset0(4) | IndFlag0(1) |...      \n \n   | KeyOffsetN(4) | IndFlagN(1) |...... | KeyN | RecN |... | Key0 | Rec0 |\n \n IndFlag - if not zero the record has been stored within a chained DBBuffer \n whose 4-byte integer buffer ID has been stored within this leaf at the record offset.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"ID_SIZE","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"PREV_LEAF_ID_OFFSET","comment":"","type_short":"int","constant_value":"6"},{"type_long":"int","javadoc":"","static":true,"name":"NEXT_LEAF_ID_OFFSET","comment":"","type_short":"int","constant_value":"10"},{"type_long":"int","javadoc":"","static":true,"name":"HEADER_SIZE","comment":"","type_short":"int","constant_value":"14"},{"type_long":"int","javadoc":"","static":true,"name":"OFFSET_SIZE","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"INDIRECT_OPTION_SIZE","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"ENTRY_SIZE","comment":"","type_short":"int","constant_value":"5"}]}
