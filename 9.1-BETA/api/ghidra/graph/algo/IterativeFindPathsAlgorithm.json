{"implements":["ghidra.graph.algo.FindPathsAlgorithm"],"javadoc":"Finds all paths between two vertices for a given graph.\n \n <P>Note: this algorithm is based on the {@link JohnsonCircuitsAlgorithm}, modified to be\n iterative instead of recursive.\n@param <V> the vertex type\n@param <E> the edge type","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setStatusListener","comment":"","params":[{"type_long":"ghidra.graph.algo.GraphAlgorithmStatusListener<V>","name":"listener","comment":"","type_short":"GraphAlgorithmStatusListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"findPaths","comment":"","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"","type_short":"GDirectedGraph"},{"type_long":"V","name":"start","comment":"","type_short":"V"},{"type_long":"V","name":"end","comment":"","type_short":"V"},{"type_long":"ghidra.util.datastruct.Accumulator<java.util.List<V>>","name":"accumulator","comment":"","type_short":"Accumulator"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"find","comment":"","params":[],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"unblock","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"doUnblock","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"blockBackEdge","comment":"","params":[{"type_long":"V","name":"u","comment":"","type_short":"V"},{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"outputCircuit","comment":"","params":[{"type_long":"java.util.Stack<ghidra.graph.algo.IterativeFindPathsAlgorithm<V,E>.Node>","name":"stack","comment":"","type_short":"Stack"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setStatus","comment":"","params":[{"type_long":"java.util.List<V>","name":"path","comment":"","type_short":"List"},{"type_long":"ghidra.graph.algo.GraphAlgorithmStatusListener.STATUS","name":"s","comment":"","type_short":"STATUS"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setStatus","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"},{"type_long":"ghidra.graph.algo.GraphAlgorithmStatusListener.STATUS","name":"s","comment":"","type_short":"STATUS"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getOutEdges","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Collection<E>","comment":"","type_short":"Collection"}}],"name":"IterativeFindPathsAlgorithm","comment":"Finds all paths between two vertices for a given graph.\n \n Note: this algorithm is based on the JohnsonCircuitsAlgorithm, modified to be\n iterative instead of recursive.","fields":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","javadoc":"","static":false,"name":"g","comment":"","type_short":"GDirectedGraph","constant_value":null},{"type_long":"V","javadoc":"","static":false,"name":"start","comment":"","type_short":"V","constant_value":null},{"type_long":"V","javadoc":"","static":false,"name":"end","comment":"","type_short":"V","constant_value":null},{"type_long":"java.util.Set<V>","javadoc":"","static":false,"name":"blockedSet","comment":"","type_short":"Set","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<V>>","javadoc":"","static":false,"name":"blockedBackEdgesMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.graph.algo.GraphAlgorithmStatusListener<V>","javadoc":"","static":false,"name":"listener","comment":"","type_short":"GraphAlgorithmStatusListener","constant_value":null},{"type_long":"ghidra.util.task.TaskMonitor","javadoc":"","static":false,"name":"monitor","comment":"","type_short":"TaskMonitor","constant_value":null},{"type_long":"ghidra.util.datastruct.Accumulator<java.util.List<V>>","javadoc":"","static":false,"name":"accumulator","comment":"","type_short":"Accumulator","constant_value":null}]}
