{"implements":[],"javadoc":"Finds all circuits (loops) in the given graph.\n \n <P><B><U>Warning:<\/U><\/B> This is a recursive algorithm.  As such, it is limited in how deep \n it can recurse.   Any path that exceeds the {@link #JAVA_STACK_DEPTH_LIMIT} will not be found.\n@param <V> the vertex type\n@param <E> the edge type","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"","type_short":"GDirectedGraph"},{"type_long":"ghidra.util.datastruct.Accumulator<java.util.List<V>>","name":"accumulator","comment":"","type_short":"Accumulator"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Finds the circuits in the graph passed at construction time.\n@param uniqueCircuits true signals to return only unique circuits, where no two \n        circuits will contain the same vertex\n@param monitor the task monitor\n@throws CancelledException if the monitor is cancelled","static":false,"name":"compute","comment":"Finds the circuits in the graph passed at construction time.","params":[{"type_long":"boolean","name":"uniqueCircuits","comment":"true signals to return only unique circuits, where no two \n        circuits will contain the same vertex","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"circuit","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"},{"type_long":"int","name":"depth","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"unblock","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"addBackEdge","comment":"","params":[{"type_long":"V","name":"u","comment":"","type_short":"V"},{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"outputCircuit","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"JohnsonCircuitsAlgorithm","comment":"Finds all circuits (loops) in the given graph.\n \n Warning: This is a recursive algorithm.  As such, it is limited in how deep \n it can recurse.   Any path that exceeds the #JAVA_STACK_DEPTH_LIMIT will not be found.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"JAVA_STACK_DEPTH_LIMIT","comment":"","type_short":"int","constant_value":"2700"},{"type_long":"ghidra.graph.GDirectedGraph<V,E>","javadoc":"","static":false,"name":"g","comment":"","type_short":"GDirectedGraph","constant_value":null},{"type_long":"ghidra.graph.GDirectedGraph<V,E>","javadoc":"","static":false,"name":"subGraph","comment":"","type_short":"GDirectedGraph","constant_value":null},{"type_long":"java.util.Stack<V>","javadoc":"","static":false,"name":"stack","comment":"","type_short":"Stack","constant_value":null},{"type_long":"V","javadoc":"","static":false,"name":"startVertex","comment":"","type_short":"V","constant_value":null},{"type_long":"java.util.Set<V>","javadoc":"","static":false,"name":"blockedSet","comment":"","type_short":"Set","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<V>>","javadoc":"","static":false,"name":"blockedBackEdgesMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.util.datastruct.Accumulator<java.util.List<V>>","javadoc":"","static":false,"name":"accumulator","comment":"","type_short":"Accumulator","constant_value":null}]}
