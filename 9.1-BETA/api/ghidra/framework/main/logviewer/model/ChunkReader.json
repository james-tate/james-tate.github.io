{"implements":[],"javadoc":"This class handles reading data from the input file, in the form of {@link Chunk} objects.  Each\n chunk is stored in the {@link ChunkModel} and represents a single block of text that is \n displayed in the {@link FVTable}.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"@param file\n@param model\n@throws IOException","static":false,"name":"<init>","comment":"","params":[{"type_long":"java.io.File","name":"file","comment":"","type_short":"File"},{"type_long":"ghidra.framework.main.logviewer.model.ChunkModel","name":"model","comment":"","type_short":"ChunkModel"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the number of bytes in the input file.\n@return number of bytes\n@throws IOException","static":false,"name":"getFileSize","comment":"Returns the number of bytes in the input file.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"number of bytes","type_short":"long"}},{"javadoc":"Returns the file being read.\n@return ","static":false,"name":"getFile","comment":"Returns the file being read.","params":[],"throws":[],"return":{"type_long":"java.io.File","comment":"","type_short":"File"}},{"javadoc":"","static":false,"name":"reload","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Reads one chunk from the end of the file. This is useful when scrolling to the bottom of\n the viewport.\n@return the last chunk, or an empty list\n@throws IOException","static":false,"name":"readLastChunk","comment":"Reads one chunk from the end of the file. This is useful when scrolling to the bottom of\n the viewport.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the last chunk, or an empty list","type_short":"List"}},{"javadoc":"Reads the chunk immediately before the first visible one.\n@return the previous chunk, or an empty list\n@throws IOException","static":false,"name":"readPreviousChunk","comment":"Reads the chunk immediately before the first visible one.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the previous chunk, or an empty list","type_short":"List"}},{"javadoc":"Reads a chunk of data from the given location in the file.  To ensure we're always reading\n full lines, take the given start position and move forward to the next full line before\n reading.\n@param startByte the position to start reading from\n@return the lines of text read\n@throws IOException","static":false,"name":"readNextChunkFrom","comment":"Reads a chunk of data from the given location in the file.  To ensure we're always reading\n full lines, take the given start position and move forward to the next full line before\n reading.","params":[{"type_long":"long","name":"startByte","comment":"the position to start reading from","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the lines of text read","type_short":"List"}},{"javadoc":"Reads all bytes from the given byte to the end byte. If the amount of bytes to be read is\n greater than the size of an INT, we will have to read this in several chunks, hence the\n need to return a list of arrays, and not just a single byte array.\n@param startByte\n@param endByte\n@return a map of all the bytes read in (index 0 is first chunk, 1 is next, etc...).\n@throws IOException","static":false,"name":"readBytes","comment":"Reads all bytes from the given byte to the end byte. If the amount of bytes to be read is\n greater than the size of an INT, we will have to read this in several chunks, hence the\n need to return a list of arrays, and not just a single byte array.","params":[{"type_long":"long","name":"startByte","comment":"","type_short":"long"},{"type_long":"long","name":"endByte","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<byte[]>","comment":"a map of all the bytes read in (index 0 is first chunk, 1 is next, etc...).","type_short":"List"}},{"javadoc":"Reads the next chunk in the file past the last one specified in the {@link ChunkModel}.\n@return the lines of text read\n@throws FileNotFoundException\n@throws IOException","static":false,"name":"readNextChunk","comment":"Reads the next chunk in the file past the last one specified in the ChunkModel.","params":[],"throws":[{"type_long":"java.io.FileNotFoundException","comment":"","type_short":"FileNotFoundException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the lines of text read","type_short":"List"}},{"javadoc":"Reads a single chunk of data from the input file. The start point of the read is wherever\n the {@link #raf} is currently pointing.\n@param startByte the byte in the file at which to start reading.\n@return the lines of text read\n@throws IOException","static":false,"name":"readChunk","comment":"Reads a single chunk of data from the input file. The start point of the read is wherever\n the #raf is currently pointing.","params":[{"type_long":"long","name":"startByte","comment":"the byte in the file at which to start reading.","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the lines of text read","type_short":"List"}},{"javadoc":"Reads in a chunk from the current file pointer location, backwards.\n@param startByte the start byte from which to read\n@return the lines of text read\n@throws IOException","static":false,"name":"readChunkInReverse","comment":"Reads in a chunk from the current file pointer location, backwards.","params":[{"type_long":"long","name":"startByte","comment":"the start byte from which to read","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the lines of text read","type_short":"List"}},{"javadoc":"Adds the given chunk to the model.\n@param chunk the chunk to add\n@param lines the lines included in the chunk\n@param startByte the start byte within the file this chunk represents\n@param endByte the end byte within the file this chunk represents\n@param addToFront if true, adds the chunk to the front of the chunk list","static":false,"name":"addChunkToModel","comment":"Adds the given chunk to the model.","params":[{"type_long":"ghidra.framework.main.logviewer.model.Chunk","name":"chunk","comment":"the chunk to add","type_short":"Chunk"},{"type_long":"java.util.List<java.lang.String>","name":"lines","comment":"the lines included in the chunk","type_short":"List"},{"type_long":"long","name":"startByte","comment":"the start byte within the file this chunk represents","type_short":"long"},{"type_long":"long","name":"endByte","comment":"the end byte within the file this chunk represents","type_short":"long"},{"type_long":"boolean","name":"addToFront","comment":"if true, adds the chunk to the front of the chunk list","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the start of the next line after the given byte. To do this, simply read \n backwards from the given point until a newline or carriage return is found.\n@param startByte\n@return \n@throws IOException","static":false,"name":"getStartOfNextLine","comment":"Returns the start of the next line after the given byte. To do this, simply read \n backwards from the given point until a newline or carriage return is found.","params":[{"type_long":"long","name":"startByte","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}}],"name":"ChunkReader","comment":"This class handles reading data from the input file, in the form of Chunk objects.  Each\n chunk is stored in the ChunkModel and represents a single block of text that is \n displayed in the FVTable.","fields":[{"type_long":"java.io.RandomAccessFile","javadoc":"","static":false,"name":"raf","comment":"","type_short":"RandomAccessFile","constant_value":null},{"type_long":"ghidra.framework.main.logviewer.model.ReverseLineReader","javadoc":"","static":false,"name":"reverser","comment":"","type_short":"ReverseLineReader","constant_value":null},{"type_long":"ghidra.framework.main.logviewer.model.ChunkModel","javadoc":"","static":false,"name":"model","comment":"","type_short":"ChunkModel","constant_value":null},{"type_long":"java.io.File","javadoc":"","static":false,"name":"file","comment":"","type_short":"File","constant_value":null}]}
