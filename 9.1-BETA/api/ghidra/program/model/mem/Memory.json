{"implements":["ghidra.program.model.address.AddressSetView"],"javadoc":"Interface for Memory.","static":false,"methods":[{"javadoc":"Returns the program that this memory belongs to.","static":false,"name":"getProgram","comment":"Returns the program that this memory belongs to.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"Returns the set of addresses which correspond to all the \"loaded\" memory blocks that have\n initialized data.  This does not include initialized memory blocks that contain data from\n the program's file header such as debug sections.","static":false,"name":"getLoadedAndInitializedAddressSet","comment":"Returns the set of addresses which correspond to all the \"loaded\" memory blocks that have\n initialized data.  This does not include initialized memory blocks that contain data from\n the program's file header such as debug sections.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Returns the set of addresses which correspond to all memory blocks that have\n initialized data.  This includes initialized memory blocks that contain data from\n the program's file header that are not actually in the running in memory image,\n such as debug sections.  Use {@link #getLoadedAndInitializedAddressSet} if you only want\n the addressed of the loaded in memory blocks.","static":false,"name":"getAllInitializedAddressSet","comment":"Returns the set of addresses which correspond to all memory blocks that have\n initialized data.  This includes initialized memory blocks that contain data from\n the program's file header that are not actually in the running in memory image,\n such as debug sections.  Use #getLoadedAndInitializedAddressSet if you only want\n the addressed of the loaded in memory blocks.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Use {@link #getLoadedAndInitializedAddressSet} instead.\n@deprecated","static":false,"name":"getInitializedAddressSet","comment":"Use #getLoadedAndInitializedAddressSet instead.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Returns the set of addresses which correspond to the executable memory.","static":false,"name":"getExecuteSet","comment":"Returns the set of addresses which correspond to the executable memory.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"Returns true if the memory is bigEndian, false otherwise.","static":false,"name":"isBigEndian","comment":"Returns true if the memory is bigEndian, false otherwise.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Sets the live memory handler\n@param handler the live memory handler","static":false,"name":"setLiveMemoryHandler","comment":"Sets the live memory handler","params":[{"type_long":"ghidra.program.model.mem.LiveMemoryHandler","name":"handler","comment":"the live memory handler","type_short":"LiveMemoryHandler"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the live memory handler instance used by this memory.\n@return the live memory handler","static":false,"name":"getLiveMemoryHandler","comment":"Returns the live memory handler instance used by this memory.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.mem.LiveMemoryHandler","comment":"the live memory handler","type_short":"LiveMemoryHandler"}},{"javadoc":"Create an initialized memory block and add it to this Memory.\n@param name block name\n@param start start address of the block\n@param is source of the data used to fill the block or null for zero initialization.\n@param length the size of the block\n@param monitor task monitor\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Initialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws CancelledException user cancelled operation\n@throws DuplicateNameException if overlay is true and there is already an overlay address\n space with the same name as this memory block","static":false,"name":"createInitializedBlock","comment":"Create an initialized memory block and add it to this Memory.","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start address of the block","type_short":"Address"},{"type_long":"java.io.InputStream","name":"is","comment":"source of the data used to fill the block or null for zero initialization.","type_short":"InputStream"},{"type_long":"long","name":"length","comment":"the size of the block","type_short":"long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"},{"type_long":"boolean","name":"overlay","comment":"if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the start is beyond the\n address space","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"user cancelled operation","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if overlay is true and there is already an overlay address\n space with the same name as this memory block","type_short":"DuplicateNameException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new Initialized Memory Block","type_short":"MemoryBlock"}},{"javadoc":"Create an initialized memory block and add it to this Memory.\n@param name block name\n@param start start of the block\n@param size block length (positive non-zero value required)\n@param initialValue initialization value for every byte in the block.\n@param monitor progress monitor, may be null.\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address paramaeter, but in the new address space.\n@return new Initialized Memory Block\n@throws DuplicateNameException if overlay is true and there is already an overlay address\n space with the same name as this memory block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws CancelledException user cancelled operation","static":false,"name":"createInitializedBlock","comment":"Create an initialized memory block and add it to this Memory.","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start of the block","type_short":"Address"},{"type_long":"long","name":"size","comment":"block length (positive non-zero value required)","type_short":"long"},{"type_long":"byte","name":"initialValue","comment":"initialization value for every byte in the block.","type_short":"byte"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"progress monitor, may be null.","type_short":"TaskMonitor"},{"type_long":"boolean","name":"overlay","comment":"if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address paramaeter, but in the new address space.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if overlay is true and there is already an overlay address\n space with the same name as this memory block","type_short":"DuplicateNameException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the start is beyond the\n address space","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"user cancelled operation","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new Initialized Memory Block","type_short":"MemoryBlock"}},{"javadoc":"Create an initialized memory block using bytes from a {@link FileBytes} object.\n@param name block name\n@param start starting address of the block\n@param fileBytes the {@link FileBytes} object to use as the underlying source of bytes.\n@param offset the offset into the FileBytes for the first byte of this memory block.\n@param size block length (positive non-zero value required)\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@return new Initialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws DuplicateNameException if overlay is true and there is already an overlay address\n space with the same name as this memory block\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the address space\n@throws IndexOutOfBoundsException if file bytes range specified by offset and size \n is out of bounds for the specified fileBytes.","static":false,"name":"createInitializedBlock","comment":"Create an initialized memory block using bytes from a FileBytes object.","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"starting address of the block","type_short":"Address"},{"type_long":"ghidra.program.database.mem.FileBytes","name":"fileBytes","comment":"the FileBytes object to use as the underlying source of bytes.","type_short":"FileBytes"},{"type_long":"long","name":"offset","comment":"the offset into the FileBytes for the first byte of this memory block.","type_short":"long"},{"type_long":"long","name":"size","comment":"block length (positive non-zero value required)","type_short":"long"},{"type_long":"boolean","name":"overlay","comment":"if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if overlay is true and there is already an overlay address\n space with the same name as this memory block","type_short":"DuplicateNameException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the start is beyond the address space","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new Initialized Memory Block","type_short":"MemoryBlock"}},{"javadoc":"Create an uninitialized memory block and add it to this Memory.\n@param name block name\n@param start start of the block\n@param size block length\n@param overlay if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address paramaeter, but in the new address space.\n@return new Uninitialized Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws DuplicateNameException if overlay is true and there is already an overlay address\n space with the same name as this memory block","static":false,"name":"createUninitializedBlock","comment":"Create an uninitialized memory block and add it to this Memory.","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start of the block","type_short":"Address"},{"type_long":"long","name":"size","comment":"block length","type_short":"long"},{"type_long":"boolean","name":"overlay","comment":"if true, the block will be created as an OVERLAY which means that a new\n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address paramaeter, but in the new address space.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if overlay is true and there is already an overlay address\n space with the same name as this memory block","type_short":"DuplicateNameException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the start is beyond the\n address space","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new Uninitialized Memory Block","type_short":"MemoryBlock"}},{"javadoc":"Create a bit overlay memory block and add it to this Memory.\n@param name block name\n@param start start of the block\n@param mappedAddress start address in the source block for the\n beginning of this block\n@param length block length\n@return new Bit Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space","static":false,"name":"createBitMappedBlock","comment":"Create a bit overlay memory block and add it to this Memory.","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start of the block","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"mappedAddress","comment":"start address in the source block for the\n beginning of this block","type_short":"Address"},{"type_long":"long","name":"length","comment":"block length","type_short":"long"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the start is beyond the\n address space","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new Bit Memory Block","type_short":"MemoryBlock"}},{"javadoc":"Create a memory block that uses the bytes located at a different location.\n@param name block name\n@param start start of the block\n@param mappedAddress start address in the source block for the\n beginning of this block\n@param length block length\n@return new Bit Memory Block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block","static":false,"name":"createByteMappedBlock","comment":"Create a memory block that uses the bytes located at a different location.","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start of the block","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"mappedAddress","comment":"start address in the source block for the\n beginning of this block","type_short":"Address"},{"type_long":"long","name":"length","comment":"block length","type_short":"long"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new Bit Memory Block","type_short":"MemoryBlock"}},{"javadoc":"Creates a MemoryBlock at the given address with the same properties\n as block, and adds it to this Memory.\n@param block source block\n@param name block name\n@param start start of the block\n@param length the size of the new block.\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws AddressOverflowException if the new memory block would extend\n beyond the end of the address space.","static":false,"name":"createBlock","comment":"Creates a MemoryBlock at the given address with the same properties\n as block, and adds it to this Memory.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"source block","type_short":"MemoryBlock"},{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start of the block","type_short":"Address"},{"type_long":"long","name":"length","comment":"the size of the new block.","type_short":"long"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the new memory block would extend\n beyond the end of the address space.","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"","type_short":"MemoryBlock"}},{"javadoc":"Remove the memory block.\n@param block the block to be removed.\n@param monitor monitor that is used to cancel the remove operation\n@throws LockException if exclusive lock not in place (see haveLock())","static":false,"name":"removeBlock","comment":"Remove the memory block.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"the block to be removed.","type_short":"MemoryBlock"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"monitor that is used to cancel the remove operation","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the memory size in bytes.","static":false,"name":"getSize","comment":"Get the memory size in bytes.","params":[],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Returns the Block which contains addr.\n@param addr a valid data Address.\n@return the block containing addr; null if addr is not a valid location.\n@throws AddressTypeException if the addr is not the proper type\n of Address for this Memory.","static":false,"name":"getBlock","comment":"Returns the Block which contains addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"a valid data Address.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"the block containing addr; null if addr is not a valid location.","type_short":"MemoryBlock"}},{"javadoc":"Returns the Block with the specified blockName\n@param blockName the name of the requested block\n@return the Block with the specified blockName","static":false,"name":"getBlock","comment":"Returns the Block with the specified blockName","params":[{"type_long":"java.lang.String","name":"blockName","comment":"the name of the requested block","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"the Block with the specified blockName","type_short":"MemoryBlock"}},{"javadoc":"Returns an array containing all the memory blocks.","static":false,"name":"getBlocks","comment":"Returns an array containing all the memory blocks.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock[]","comment":"","type_short":"ghidra.program.model.mem.MemoryBlock[]"}},{"javadoc":"Move the memory block containing source address to the destination\n address.\n@param block block to be moved\n@param newStartAddr new start address for block\n@param monitor task monitor so the move block can be canceled\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if move would cause\n blocks to overlap.\n@throws MemoryBlockException if block movement is not permitted\n@throws AddressOverflowException if new start address +\n block.getSize() would cause the Address to wrap around.\n@throws NotFoundException if memoryBlock does not exist in\n   this memory.","static":false,"name":"moveBlock","comment":"Move the memory block containing source address to the destination\n address.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"block to be moved","type_short":"MemoryBlock"},{"type_long":"ghidra.program.model.address.Address","name":"newStartAddr","comment":"new start address for block","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor so the move block can be canceled","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryBlockException","comment":"if block movement is not permitted","type_short":"MemoryBlockException"},{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if move would cause\n blocks to overlap.","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if new start address +\n block.getSize() would cause the Address to wrap around.","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"if memoryBlock does not exist in\n   this memory.","type_short":"NotFoundException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Split a block at the given addr and create a new block\n starting at addr.\n@param block block to be split into two\n@param addr address (within block) that will be the\n start of new block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws NotFoundException thrown if block does not exist\n in memory\n@throws MemoryBlockException memory split not permitted\n@throws AddressOutOfBoundsException thrown if address is\n not in the block","static":false,"name":"split","comment":"Split a block at the given addr and create a new block\n starting at addr.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"block to be split into two","type_short":"MemoryBlock"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address (within block) that will be the\n start of new block","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryBlockException","comment":"memory split not permitted","type_short":"MemoryBlockException"},{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"thrown if block does not exist\n in memory","type_short":"NotFoundException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Join the two blocks to create a single memory block.\n IMPORTANT! When done, both blockOne and blockTwo should no longer be used.\n@param blockOne block to be combined with blockTwo\n@param blockTwo block to be combined with blockOne\n@return new block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryBlockException thrown if the blocks are\n not contiguous in the address space,","static":false,"name":"join","comment":"Join the two blocks to create a single memory block.\n IMPORTANT! When done, both blockOne and blockTwo should no longer be used.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"blockOne","comment":"block to be combined with blockTwo","type_short":"MemoryBlock"},{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"blockTwo","comment":"block to be combined with blockOne","type_short":"MemoryBlock"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryBlockException","comment":"thrown if the blocks are\n not contiguous in the address space,","type_short":"MemoryBlockException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new block","type_short":"MemoryBlock"}},{"javadoc":"Convert an existing uninitialized block with an\n initialized block.\n@param unitializedBlock unitialized block to convert\n@param initialValue initial value for the bytes\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryBlockException if there is no block in memory\n at the same address as block or if the block lengths are not\n the same.","static":false,"name":"convertToInitialized","comment":"Convert an existing uninitialized block with an\n initialized block.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"unitializedBlock","comment":"unitialized block to convert","type_short":"MemoryBlock"},{"type_long":"byte","name":"initialValue","comment":"initial value for the bytes","type_short":"byte"}],"throws":[{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.program.model.mem.MemoryBlockException","comment":"if there is no block in memory\n at the same address as block or if the block lengths are not\n the same.","type_short":"MemoryBlockException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"","type_short":"MemoryBlock"}},{"javadoc":"","static":false,"name":"convertToUninitialized","comment":"","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"itializedBlock","comment":"","type_short":"MemoryBlock"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryBlockException","comment":"","type_short":"MemoryBlockException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"","type_short":"NotFoundException"},{"type_long":"ghidra.framework.store.LockException","comment":"","type_short":"LockException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"","type_short":"MemoryBlock"}},{"javadoc":"Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.\n@param addr The beginning address in memory to search.\n@param bytes the array of bytes to search for.\n@param masks the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks.\n@param forward if true, search in the forward direction.\n@return The address of where the first match is found. Null is returned\n if there is no match.","static":false,"name":"findBytes","comment":"Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"The beginning address in memory to search.","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"the array of bytes to search for.","type_short":"byte[]"},{"type_long":"byte[]","name":"masks","comment":"the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks.","type_short":"byte[]"},{"type_long":"boolean","name":"forward","comment":"if true, search in the forward direction.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The address of where the first match is found. Null is returned\n if there is no match.","type_short":"Address"}},{"javadoc":"Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.\n Starts at startAddr and ends at endAddr.\n If forward is true, search starts at startAddr and will end if startAddr \">\" endAddr.\n If forward is false, search starts at start addr and will end if startAddr \"<\" endAddr.\n@param startAddr The beginning address in memory to search.\n@param endAddr The ending address in memory to search (inclusive).\n@param bytes the array of bytes to search for.\n@param masks the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks.\n@param forward if true, search in the forward direction.\n@return The address of where the first match is found. Null is returned\n if there is no match.","static":false,"name":"findBytes","comment":"Finds a sequence of contiguous bytes that match the\n given byte array at all bit positions where the mask contains an \"on\" bit.\n Starts at startAddr and ends at endAddr.\n If forward is true, search starts at startAddr and will end if startAddr \"\" endAddr.\n If forward is false, search starts at start addr and will end if startAddr \"\" endAddr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"The beginning address in memory to search.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"endAddr","comment":"The ending address in memory to search (inclusive).","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"the array of bytes to search for.","type_short":"byte[]"},{"type_long":"byte[]","name":"masks","comment":"the array of masks. (One for each byte in the byte array)\n              if all bits of each byte is to be checked (ie: all mask bytes are 0xff),\n              then pass a null for masks.","type_short":"byte[]"},{"type_long":"boolean","name":"forward","comment":"if true, search in the forward direction.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The address of where the first match is found. Null is returned\n if there is no match.","type_short":"Address"}},{"javadoc":"Get byte at addr.\n@param addr the Address of the byte.\n@return the byte.\n@throws MemoryAccessException if the address is\n not contained in any memory block.","static":false,"name":"getByte","comment":"Get byte at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the byte.","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the address is\n not contained in any memory block.","type_short":"MemoryAccessException"}],"return":{"type_long":"byte","comment":"the byte.","type_short":"byte"}},{"javadoc":"Get dest.length number of bytes starting at the given address.\n@param addr the starting Address.\n@param dest the byte array to populate.\n@return the number of bytes put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n@throws MemoryAccessException if the starting address is\n not contained in any memory block.","static":false,"name":"getBytes","comment":"Get dest.length number of bytes starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"byte[]","name":"dest","comment":"the byte array to populate.","type_short":"byte[]"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the starting address is\n not contained in any memory block.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of bytes put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.","type_short":"int"}},{"javadoc":"Get size number of bytes starting at the given address and populates\n dest starting at dIndex.\n@param addr the starting Address.\n@param dest the byte array to populate.\n@param destIndex the offset into dest to place the bytes.\n@param size the number of bytes to get.\n@return the number of bytes put into dest.  May be less than\n size if the requested number extends beyond available memory.\n@throws MemoryAccessException if the starting address is\n not contained in any memory block.","static":false,"name":"getBytes","comment":"Get size number of bytes starting at the given address and populates\n dest starting at dIndex.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"byte[]","name":"dest","comment":"the byte array to populate.","type_short":"byte[]"},{"type_long":"int","name":"destIndex","comment":"the offset into dest to place the bytes.","type_short":"int"},{"type_long":"int","name":"size","comment":"the number of bytes to get.","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the starting address is\n not contained in any memory block.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of bytes put into dest.  May be less than\n size if the requested number extends beyond available memory.","type_short":"int"}},{"javadoc":"Get the short at addr.\n@param addr the Address where the short starts.\n@return the short.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getShort","comment":"Get the short at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address where the short starts.","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"short","comment":"the short.","type_short":"short"}},{"javadoc":"Get the short at addr using the specified endian order.\n@param addr the Address where the short starts.\n@param bigEndian true means to get the short in\n bigEndian order\n@return the short.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getShort","comment":"Get the short at addr using the specified endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address where the short starts.","type_short":"Address"},{"type_long":"boolean","name":"bigEndian","comment":"true means to get the short in\n bigEndian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"short","comment":"the short.","type_short":"short"}},{"javadoc":"Get dest.length number of shorts starting at the given address.\n@param addr the starting Address.\n@param dest the short array to populate.\n@return the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getShorts","comment":"Get dest.length number of shorts starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"short[]","name":"dest","comment":"the short array to populate.","type_short":"short[]"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.","type_short":"int"}},{"javadoc":"Get dest.length number of shorts starting at the given address.\n@param addr the starting Address.\n@param dest the short array to populate.\n@param dIndex the offset into dest to place the shorts.\n@param size the number of shorts to get.\n@return the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getShorts","comment":"Get dest.length number of shorts starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"short[]","name":"dest","comment":"the short array to populate.","type_short":"short[]"},{"type_long":"int","name":"dIndex","comment":"the offset into dest to place the shorts.","type_short":"int"},{"type_long":"int","name":"nElem","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.","type_short":"int"}},{"javadoc":"Get dest.length number of shorts starting at the given address.\n@param addr the starting Address.\n@param dest the short array to populate.\n@param dIndex the offset into dest to place the shorts.\n@param size the number of shorts to get.\n@param isBigEndian true means to get the shorts in\n bigEndian order\n@return the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getShorts","comment":"Get dest.length number of shorts starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"short[]","name":"dest","comment":"the short array to populate.","type_short":"short[]"},{"type_long":"int","name":"dIndex","comment":"the offset into dest to place the shorts.","type_short":"int"},{"type_long":"int","name":"nElem","comment":"","type_short":"int"},{"type_long":"boolean","name":"isBigEndian","comment":"true means to get the shorts in\n bigEndian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of shorts put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is odd, the final byte will be discarded.","type_short":"int"}},{"javadoc":"Get the int at addr.\n@param addr the Address where the int starts.\n@return the int.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getInt","comment":"Get the int at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address where the int starts.","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the int.","type_short":"int"}},{"javadoc":"Get the int at addr using the specified endian order.\n@param addr the Address where the int starts.\n@param bigEndian true means to get the int in\n big endian order\n@return the int.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getInt","comment":"Get the int at addr using the specified endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address where the int starts.","type_short":"Address"},{"type_long":"boolean","name":"bigEndian","comment":"true means to get the int in\n big endian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the int.","type_short":"int"}},{"javadoc":"Get dest.length number of ints starting at the given address.\n@param addr the starting Address.\n@param dest the int array to populate.\n@return the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.\n@throws MemoryAccessException if the starting address is\n not contained in any memory block.","static":false,"name":"getInts","comment":"Get dest.length number of ints starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"int[]","name":"dest","comment":"the int array to populate.","type_short":"int[]"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the starting address is\n not contained in any memory block.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.","type_short":"int"}},{"javadoc":"Get dest.length number of ints starting at the given address.\n@param addr the starting Address.\n@param dest the int array to populate.\n@param dIndex the offset into dest to place the ints.\n@param size the number of ints to get.\n@return the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getInts","comment":"Get dest.length number of ints starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"int[]","name":"dest","comment":"the int array to populate.","type_short":"int[]"},{"type_long":"int","name":"dIndex","comment":"the offset into dest to place the ints.","type_short":"int"},{"type_long":"int","name":"nElem","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.","type_short":"int"}},{"javadoc":"Get dest.length number of ints starting at the given address.\n@param addr the starting Address.\n@param dest the int array to populate.\n@param dIndex the offset into dest to place the ints.\n@param size the number of ints to get.\n@param isBigEndian true means to get the ints in\n bigEndian order\n@return the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getInts","comment":"Get dest.length number of ints starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"int[]","name":"dest","comment":"the int array to populate.","type_short":"int[]"},{"type_long":"int","name":"dIndex","comment":"the offset into dest to place the ints.","type_short":"int"},{"type_long":"int","name":"nElem","comment":"","type_short":"int"},{"type_long":"boolean","name":"isBigEndian","comment":"true means to get the ints in\n bigEndian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of ints put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 4, the final byte(s) will be discarded.","type_short":"int"}},{"javadoc":"Get the long at addr.\n@param addr the Address where the long starts.\n@return the long.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getLong","comment":"Get the long at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address where the long starts.","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"long","comment":"the long.","type_short":"long"}},{"javadoc":"Get the long at addr in the specified endian order.\n@param addr the Address where the long starts.\n@param bigEndian true means to get the long in\n big endian order\n@return the long.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getLong","comment":"Get the long at addr in the specified endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address where the long starts.","type_short":"Address"},{"type_long":"boolean","name":"bigEndian","comment":"true means to get the long in\n big endian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"long","comment":"the long.","type_short":"long"}},{"javadoc":"Get dest.length number of longs starting at the given address.\n@param addr the starting Address.\n@param dest the long array to populate.\n@return the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getLongs","comment":"Get dest.length number of longs starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"long[]","name":"dest","comment":"the long array to populate.","type_short":"long[]"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.","type_short":"int"}},{"javadoc":"Get dest.length number of longs starting at the given address.\n@param addr the starting Address.\n@param dest the long array to populate.\n@param dIndex the offset into dest to place the longs.\n@param size the number of longs to get.\n@return the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getLongs","comment":"Get dest.length number of longs starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"long[]","name":"dest","comment":"the long array to populate.","type_short":"long[]"},{"type_long":"int","name":"dIndex","comment":"the offset into dest to place the longs.","type_short":"int"},{"type_long":"int","name":"nElem","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.","type_short":"int"}},{"javadoc":"Get dest.length number of longs starting at the given address.\n@param addr the starting Address.\n@param dest the long array to populate.\n@param dIndex the offset into dest to place the longs.\n@param size the number of longs to get.\n@param isBigEndian true means to get the longs in\n bigEndian order\n@return the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.\n@throws MemoryAccessException if not all needed bytes are contained in initialized memory.","static":false,"name":"getLongs","comment":"Get dest.length number of longs starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"long[]","name":"dest","comment":"the long array to populate.","type_short":"long[]"},{"type_long":"int","name":"dIndex","comment":"the offset into dest to place the longs.","type_short":"int"},{"type_long":"int","name":"nElem","comment":"","type_short":"int"},{"type_long":"boolean","name":"isBigEndian","comment":"true means to get the longs in\n bigEndian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if not all needed bytes are contained in initialized memory.","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the number of longs put into dest.  May be less than\n dest.length if the requested number extends beyond available memory.\n If the number of retrievable bytes is not 0 mod 8, the final byte(s) will be discarded.","type_short":"int"}},{"javadoc":"Write byte at addr.\n@param addr the Address of the byte.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setByte","comment":"Write byte at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the byte.","type_short":"Address"},{"type_long":"byte","name":"value","comment":"the data to write.","type_short":"byte"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write size bytes from values at addr.\n@param addr the starting Address.\n@param source the bytes to write.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setBytes","comment":"Write size bytes from values at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address.","type_short":"Address"},{"type_long":"byte[]","name":"source","comment":"the bytes to write.","type_short":"byte[]"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write an array of bytes.  This should copy size bytes or fail!\n@param addr the starting Address of the bytes.\n@param source an array to get bytes from.\n@param sIndex the starting source index.\n@param size the number of bytes to fill.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setBytes","comment":"Write an array of bytes.  This should copy size bytes or fail!","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the starting Address of the bytes.","type_short":"Address"},{"type_long":"byte[]","name":"source","comment":"an array to get bytes from.","type_short":"byte[]"},{"type_long":"int","name":"sIndex","comment":"the starting source index.","type_short":"int"},{"type_long":"int","name":"size","comment":"the number of bytes to fill.","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write short at addr in big endian order.\n@param addr the Address of the short.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setShort","comment":"Write short at addr in big endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the short.","type_short":"Address"},{"type_long":"short","name":"value","comment":"the data to write.","type_short":"short"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write short at addr in the specified endian order.\n@param addr the Address of the short.\n@param value the data to write.\n@param bigEndian true means to write short in\n big endian order\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setShort","comment":"Write short at addr in the specified endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the short.","type_short":"Address"},{"type_long":"short","name":"value","comment":"the data to write.","type_short":"short"},{"type_long":"boolean","name":"bigEndian","comment":"true means to write short in\n big endian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write int at addr.\n@param addr the Address of the int.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setInt","comment":"Write int at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the int.","type_short":"Address"},{"type_long":"int","name":"value","comment":"the data to write.","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write int at addr in the specified endian order.\n@param addr the Address of the int.\n@param bigEndian true means to write the short in\n bigEndian order\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setInt","comment":"Write int at addr in the specified endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the int.","type_short":"Address"},{"type_long":"int","name":"value","comment":"the data to write.","type_short":"int"},{"type_long":"boolean","name":"bigEndian","comment":"true means to write the short in\n bigEndian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write long at addr.\n@param addr the Address of the long.\n@param value the data to write.\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setLong","comment":"Write long at addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the long.","type_short":"Address"},{"type_long":"long","name":"value","comment":"the data to write.","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write long at addr in the specified endian order.\n@param addr the Address of the long.\n@param value the data to write.\n@param bigEndian true means to write the long in\n bigEndian order\n@throws MemoryAccessException if writing is not allowed.","static":false,"name":"setLong","comment":"Write long at addr in the specified endian order.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address of the long.","type_short":"Address"},{"type_long":"long","name":"value","comment":"the data to write.","type_short":"long"},{"type_long":"boolean","name":"bigEndian","comment":"true means to write the long in\n bigEndian order","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if writing is not allowed.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Stores a sequence of bytes into the program.  Typically, this method is used by importers\n to store the original raw program bytes.\n@param filename the name of the file from where the bytes originated\n@param offset the offset into the file for the first byte in the input stream.\n@param size the number of bytes to store from the input stream.\n@param is the input stream that will supply the bytes to store in the program.\n@param monitor\n@return a FileBytes that was created to access the bytes.\n@throws IOException if there was an IOException saving the bytes to the program database.\n@throws CancelledException if the user cancelled this operation. Note: the database will\n be stable, but the buffers may contain 0s instead of the actual bytes.","static":false,"name":"createFileBytes","comment":"Stores a sequence of bytes into the program.  Typically, this method is used by importers\n to store the original raw program bytes.","params":[{"type_long":"java.lang.String","name":"filename","comment":"the name of the file from where the bytes originated","type_short":"String"},{"type_long":"long","name":"offset","comment":"the offset into the file for the first byte in the input stream.","type_short":"long"},{"type_long":"long","name":"size","comment":"the number of bytes to store from the input stream.","type_short":"long"},{"type_long":"java.io.InputStream","name":"is","comment":"the input stream that will supply the bytes to store in the program.","type_short":"InputStream"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was an IOException saving the bytes to the program database.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancelled this operation. Note: the database will\n be stable, but the buffers may contain 0s instead of the actual bytes.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.database.mem.FileBytes","comment":"a FileBytes that was created to access the bytes.","type_short":"FileBytes"}},{"javadoc":"Returns a list of all the stored original file bytes objects\n@return a list of all the stored original file bytes objects","static":false,"name":"getAllFileBytes","comment":"Returns a list of all the stored original file bytes objects","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.database.mem.FileBytes>","comment":"a list of all the stored original file bytes objects","type_short":"List"}},{"javadoc":"Deletes a stored sequence of file bytes.  The file bytes can only be deleted if there\n are no memory block references to the file bytes.\n@param fileBytes the FileBytes for the file bytes to be deleted.\n@return true if the FileBytes was deleted.  If any memory blocks are referenced by this \n FileBytes or it is invalid then it will not be deleted and false will be returned.\n@throws IOException if there was an error updating the database.","static":false,"name":"deleteFileBytes","comment":"Deletes a stored sequence of file bytes.  The file bytes can only be deleted if there\n are no memory block references to the file bytes.","params":[{"type_long":"ghidra.program.database.mem.FileBytes","name":"fileBytes","comment":"the FileBytes for the file bytes to be deleted.","type_short":"FileBytes"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was an error updating the database.","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if the FileBytes was deleted.  If any memory blocks are referenced by this \n FileBytes or it is invalid then it will not be deleted and false will be returned.","type_short":"boolean"}},{"javadoc":"Returns information ({@link AddressSourceInfo}) about the byte source at the given address.\n@param address the address to query. Returns null if the address is not in memory.\n@return information ({@link AddressSourceInfo}) about the byte source at the given address or\n null if the address is not in memory.","static":false,"name":"getAddressSourceInfo","comment":"Returns information (AddressSourceInfo) about the byte source at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to query. Returns null if the address is not in memory.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.database.mem.AddressSourceInfo","comment":"information (AddressSourceInfo) about the byte source at the given address or\n null if the address is not in memory.","type_short":"AddressSourceInfo"}}],"name":"Memory","comment":"Interface for Memory.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"GBYTE_SHIFT_FACTOR","comment":"","type_short":"int","constant_value":"30"},{"type_long":"long","javadoc":"","static":true,"name":"GBYTE","comment":"","type_short":"long","constant_value":"1073741824"},{"type_long":"int","javadoc":"Maximum size of all memory blocks, 16-GByte (see {@link #getAllInitializedAddressSet()}).\n This restriction is somewhat arbitrary but is established to prevent an excessive\n number of memory map segments which can have a negative impact on performance.","static":true,"name":"MAX_BINARY_SIZE_GB","comment":"Maximum size of all memory blocks, 16-GByte (see #getAllInitializedAddressSet()).\n This restriction is somewhat arbitrary but is established to prevent an excessive\n number of memory map segments which can have a negative impact on performance.","type_short":"int","constant_value":"16"},{"type_long":"long","javadoc":"","static":true,"name":"MAX_BINARY_SIZE","comment":"","type_short":"long","constant_value":"17179869184"},{"type_long":"int","javadoc":"The current max size of a memory block.","static":true,"name":"MAX_BLOCK_SIZE_GB","comment":"The current max size of a memory block.","type_short":"int","constant_value":"16"},{"type_long":"long","javadoc":"","static":true,"name":"MAX_BLOCK_SIZE","comment":"","type_short":"long","constant_value":"17179869184"}]}
