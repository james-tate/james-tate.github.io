{"implements":["ghidra.program.model.mem.MemBuffer"],"javadoc":"Interface common to both instructions and data.","static":false,"methods":[{"javadoc":"Get the string representation of the starting address for\n this code unit.\n@param showBlockName true if the string should include the memory block name\n@param pad if true, the address will be padded with leading zeros.  Even if pad is\n false, the string will be padded to make the address string contain at least 4 digits.\n@return string representation of address","static":false,"name":"getAddressString","comment":"Get the string representation of the starting address for\n this code unit.","params":[{"type_long":"boolean","name":"showBlockName","comment":"true if the string should include the memory block name","type_short":"boolean"},{"type_long":"boolean","name":"pad","comment":"if true, the address will be padded with leading zeros.  Even if pad is\n false, the string will be padded to make the address string contain at least 4 digits.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"string representation of address","type_short":"String"}},{"javadoc":"Set the named property with the given value at the address of this codeunit.\n@param name the name of the property.\n@param value value to be stored.","static":false,"name":"setProperty","comment":"Set the named property with the given value at the address of this codeunit.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property.","type_short":"String"},{"type_long":"ghidra.util.Saveable","name":"value","comment":"value to be stored.","type_short":"Saveable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the named property with the given value at the address of this codeunit.\n@param name the name of the property.\n@param value value to be stored.","static":false,"name":"setProperty","comment":"Set the named property with the given value at the address of this codeunit.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property.","type_short":"String"},{"type_long":"java.lang.String","name":"value","comment":"value to be stored.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the named property with the given value at the address of this codeunit.\n@param name the name of the property.\n@param value value to be stored.","static":false,"name":"setProperty","comment":"Set the named property with the given value at the address of this codeunit.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property.","type_short":"String"},{"type_long":"int","name":"value","comment":"value to be stored.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the named property.  This method is used for \"void\" properites. The\n property is either set or not set - there is no value\n@param name the name of the property.","static":false,"name":"setProperty","comment":"Set the named property.  This method is used for \"void\" properites. The\n property is either set or not set - there is no value","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the object property for name; returns null if\n there is no name property for this code unit.\n@param name the name of the property","static":false,"name":"getObjectProperty","comment":"Get the object property for name; returns null if\n there is no name property for this code unit.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.util.Saveable","comment":"","type_short":"Saveable"}},{"javadoc":"Get the string property for name; returns null if\n there is no name property for this code unit.\n@param name the name of the property","static":false,"name":"getStringProperty","comment":"Get the string property for name; returns null if\n there is no name property for this code unit.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Get the int property for name.\n@param name the name of the property\n@throws NoValueException if there is not name property\n for this code unit","static":false,"name":"getIntProperty","comment":"Get the int property for name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property","type_short":"String"}],"throws":[{"type_long":"ghidra.util.exception.NoValueException","comment":"if there is not name property\n for this code unit","type_short":"NoValueException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns true if the codeunit has the given property defined.\n@param name the name of the property","static":false,"name":"hasProperty","comment":"Returns true if the codeunit has the given property defined.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns whether this code unit is marked as having the\n name property.\n@param name the name of the property","static":false,"name":"getVoidProperty","comment":"Returns whether this code unit is marked as having the\n name property.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get an iterator over the property names.","static":false,"name":"propertyNames","comment":"Get an iterator over the property names.","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<java.lang.String>","comment":"","type_short":"Iterator"}},{"javadoc":"Remove the property with the given name from this code unit.\n@param name the name of the property","static":false,"name":"removeProperty","comment":"Remove the property with the given name from this code unit.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the property","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Invokes the visit() method of the specified PropertyVisitor if the named\n property exists for this code unit.\n@param visitor the class implementing the PropertyVisitor interface.\n@param propertyName the name of the property to be visited.","static":false,"name":"visitProperty","comment":"Invokes the visit() method of the specified PropertyVisitor if the named\n property exists for this code unit.","params":[{"type_long":"ghidra.util.prop.PropertyVisitor","name":"visitor","comment":"the class implementing the PropertyVisitor interface.","type_short":"PropertyVisitor"},{"type_long":"java.lang.String","name":"propertyName","comment":"the name of the property to be visited.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the label for this code unit.","static":false,"name":"getLabel","comment":"Get the label for this code unit.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Get the Symbols for this code unit.\n@throws ConcurrentModificationException if this object is no\n longer valid.","static":false,"name":"getSymbols","comment":"Get the Symbols for this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol[]","comment":"","type_short":"ghidra.program.model.symbol.Symbol[]"}},{"javadoc":"Get the Primary Symbol for this code unit.\n@throws ConcurrentModificationException if this object is no\n longer valid.","static":false,"name":"getPrimarySymbol","comment":"Get the Primary Symbol for this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Get the starting address for this code unit.","static":false,"name":"getMinAddress","comment":"Get the starting address for this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Get the ending address for this code unit.","static":false,"name":"getMaxAddress","comment":"Get the ending address for this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Get the mnemonic for this code unit, e.g., MOV, JMP","static":false,"name":"getMnemonicString","comment":"Get the mnemonic for this code unit, e.g., MOV, JMP","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Get the comment for the given type\n@param commentType either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT\n@return the comment string of the appropriate type or null if no comment of\n that type exists for this codeunit\n@throws IllegalArgumentException if type is not one of the\n three types of comments supported","static":false,"name":"getComment","comment":"Get the comment for the given type","params":[{"type_long":"int","name":"commentType","comment":"either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the comment string of the appropriate type or null if no comment of\n that type exists for this codeunit","type_short":"String"}},{"javadoc":"Get the comment for the given type and parse it into an array of strings\n such that each line is its own string.\n@param commentType either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT\n@return an array of strings where each item in the array is a line of text\n in the comment.  If there is no comment of the requested type, an empty array\n is returned.\n@throws IllegalArgumentException if type is not one of the\n three types of comments supported","static":false,"name":"getCommentAsArray","comment":"Get the comment for the given type and parse it into an array of strings\n such that each line is its own string.","params":[{"type_long":"int","name":"commentType","comment":"either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String[]","comment":"an array of strings where each item in the array is a line of text\n in the comment.  If there is no comment of the requested type, an empty array\n is returned.","type_short":"java.lang.String[]"}},{"javadoc":"Set the comment for the given comment type.  Passing <tt>null<\/tt> clears the comment\n@param commentType either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT\n@param comment comment for code unit; null clears the comment\n@throws IllegalArgumentException if type is not one of the\n three types of comments supported","static":false,"name":"setComment","comment":"Set the comment for the given comment type.  Passing null clears the comment","params":[{"type_long":"int","name":"commentType","comment":"either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT","type_short":"int"},{"type_long":"java.lang.String","name":"comment","comment":"comment for code unit; null clears the comment","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the comment (with each line in its own string) for the given comment type\n@param commentType either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT\n@param comment an array of strings where each string is a single line of the comment.\n@throws IllegalArgumentException if type is not one of the\n three types of comments supported","static":false,"name":"setCommentAsArray","comment":"Set the comment (with each line in its own string) for the given comment type","params":[{"type_long":"int","name":"commentType","comment":"either EOL_COMMENT, PRE_COMMENT, \n POST_COMMENT, or REPEATABLE_COMMENT","type_short":"int"},{"type_long":"java.lang.String[]","name":"comment","comment":"an array of strings where each string is a single line of the comment.","type_short":"java.lang.String[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return true if the given CodeUnit follows\n directly after this code unit.\n@param codeUnit the codeUnit being tested to see if it follows this codeUnit.","static":false,"name":"isSuccessor","comment":"Return true if the given CodeUnit follows\n directly after this code unit.","params":[{"type_long":"ghidra.program.model.listing.CodeUnit","name":"codeUnit","comment":"the codeUnit being tested to see if it follows this codeUnit.","type_short":"CodeUnit"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get length of this code unit.","static":false,"name":"getLength","comment":"Get length of this code unit.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get the bytes that make up this code unit.\n@return an array of bytes that are in memory at the codeunits address.  The\n array length is the same as the codeUnits length\n@throws MemoryAccessException if the full number of bytes could not be read.","static":false,"name":"getBytes","comment":"Get the bytes that make up this code unit.","params":[],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the full number of bytes could not be read.","type_short":"MemoryAccessException"}],"return":{"type_long":"byte[]","comment":"an array of bytes that are in memory at the codeunits address.  The\n array length is the same as the codeUnits length","type_short":"byte[]"}},{"javadoc":"Copies max(buffer.length, code unit length) bytes into buffer starting at location offset in buffer.\n@param buffer byte array to copy into\n@param bufferOffset offset in byte array the copy will start\n@throws MemoryAccessException if the full number of bytes could not be read.","static":false,"name":"getBytesInCodeUnit","comment":"Copies max(buffer.length, code unit length) bytes into buffer starting at location offset in buffer.","params":[{"type_long":"byte[]","name":"buffer","comment":"byte array to copy into","type_short":"byte[]"},{"type_long":"int","name":"bufferOffset","comment":"offset in byte array the copy will start","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the full number of bytes could not be read.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if address is contained in the range of this codeUnit\n@param testAddr the address to test.","static":false,"name":"contains","comment":"Returns true if address is contained in the range of this codeUnit","params":[{"type_long":"ghidra.program.model.address.Address","name":"testAddr","comment":"the address to test.","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Compares the given address to the address range of this node.\n@param addr address to compare.\n@return a negative integer if this addr is greater than the maximum range address\n         zero if addr is in the range\n         a positive integer if addr is less than minimum range address","static":false,"name":"compareTo","comment":"Compares the given address to the address range of this node.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to compare.","type_short":"Address"}],"throws":[],"return":{"type_long":"int","comment":"a negative integer if this addr is greater than the maximum range address\n         zero if addr is in the range\n         a positive integer if addr is less than minimum range address","type_short":"int"}},{"javadoc":"Add a reference to the mnemonic for this code unit.\n@param refAddr address to add as a reference.\n@param refType the type of reference to add.\n@param sourceType the source of this reference","static":false,"name":"addMnemonicReference","comment":"Add a reference to the mnemonic for this code unit.","params":[{"type_long":"ghidra.program.model.address.Address","name":"refAddr","comment":"address to add as a reference.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"the type of reference to add.","type_short":"RefType"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"sourceType","comment":"the source of this reference","type_short":"SourceType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Remove a reference to the mnemonic for this code unit.\n@param refAddr the address to remove as a reference.","static":false,"name":"removeMnemonicReference","comment":"Remove a reference to the mnemonic for this code unit.","params":[{"type_long":"ghidra.program.model.address.Address","name":"refAddr","comment":"the address to remove as a reference.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get references for the mnemonic for this code unit.\n@return an array of memory references. A zero length array will be \n returned if there are no references for the mnemonic.","static":false,"name":"getMnemonicReferences","comment":"Get references for the mnemonic for this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference[]","comment":"an array of memory references. A zero length array will be \n returned if there are no references for the mnemonic.","type_short":"ghidra.program.model.symbol.Reference[]"}},{"javadoc":"Get the references for the operand index.\n@param index operand index (0 is the first operand)","static":false,"name":"getOperandReferences","comment":"Get the references for the operand index.","params":[{"type_long":"int","name":"index","comment":"operand index (0 is the first operand)","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference[]","comment":"","type_short":"ghidra.program.model.symbol.Reference[]"}},{"javadoc":"Get the primary reference for the operand index.\n@param index operand index (0 is the first operand)","static":false,"name":"getPrimaryReference","comment":"Get the primary reference for the operand index.","params":[{"type_long":"int","name":"index","comment":"operand index (0 is the first operand)","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"","type_short":"Reference"}},{"javadoc":"Add a memory reference to the operand at the given index.\n@param index operand index\n@param refAddr reference address\n@param type the reference type to be added.\n@param sourceType the source of this reference","static":false,"name":"addOperandReference","comment":"Add a memory reference to the operand at the given index.","params":[{"type_long":"int","name":"index","comment":"operand index","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"refAddr","comment":"reference address","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.RefType","name":"type","comment":"the reference type to be added.","type_short":"RefType"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"sourceType","comment":"the source of this reference","type_short":"SourceType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Remove a reference to the operand.\n@param index operand index\n@param refAddr address referencing the operand","static":false,"name":"removeOperandReference","comment":"Remove a reference to the operand.","params":[{"type_long":"int","name":"index","comment":"operand index","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"refAddr","comment":"address referencing the operand","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get ALL memory references FROM this code unit.\n@return an array of memory references from this codeUnit or an empty array\n if there are no references.","static":false,"name":"getReferencesFrom","comment":"Get ALL memory references FROM this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference[]","comment":"an array of memory references from this codeUnit or an empty array\n if there are no references.","type_short":"ghidra.program.model.symbol.Reference[]"}},{"javadoc":"Get an iterator over all references TO this code unit.","static":false,"name":"getReferenceIteratorTo","comment":"Get an iterator over all references TO this code unit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.ReferenceIterator","comment":"","type_short":"ReferenceIterator"}},{"javadoc":"Returns the program that generated this CodeUnit.","static":false,"name":"getProgram","comment":"Returns the program that generated this CodeUnit.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"Gets the external reference (if any) at the opIndex\n@param opIndex the operand index to look for external references\n@return the external reference at the operand or null if none exists.","static":false,"name":"getExternalReference","comment":"Gets the external reference (if any) at the opIndex","params":[{"type_long":"int","name":"opIndex","comment":"the operand index to look for external references","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.ExternalReference","comment":"the external reference at the operand or null if none exists.","type_short":"ExternalReference"}},{"javadoc":"Remove external reference (if any) at the given opIndex\n opIndex the index of the operand from which to remove any external reference.","static":false,"name":"removeExternalReference","comment":"Remove external reference (if any) at the given opIndex\n opIndex the index of the operand from which to remove any external reference.","params":[{"type_long":"int","name":"opIndex","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets a memory reference to be the primary reference at its\n address\/opIndex location. The primary reference is the one that\n is used in the getOperandRepresentation() method.\n@param ref the reference to be set as primary.","static":false,"name":"setPrimaryMemoryReference","comment":"Sets a memory reference to be the primary reference at its\n address\/opIndex location. The primary reference is the one that\n is used in the getOperandRepresentation() method.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"ref","comment":"the reference to be set as primary.","type_short":"Reference"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets a stack reference at the <code>offset<\/code> on the\n specified operand index, which effectively substitutes the previous\n operation interpretation\n <br>\n <i>NOTE: If another reference was previously set on the\n operand, then it will be replaced with this stack\n reference<\/i>\n@param opIndex the index of the operand to set this stack reference\n@param offset the (+\/-) offset from stack base address\n@param sourceType the source of this reference\n@param refType type of reference, RefType.READ,WRITE,PTR...","static":false,"name":"setStackReference","comment":"Sets a stack reference at the offset on the\n specified operand index, which effectively substitutes the previous\n operation interpretation\n \n NOTE: If another reference was previously set on the\n operand, then it will be replaced with this stack\n reference","params":[{"type_long":"int","name":"opIndex","comment":"the index of the operand to set this stack reference","type_short":"int"},{"type_long":"int","name":"offset","comment":"the (+\/-) offset from stack base address","type_short":"int"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"sourceType","comment":"the source of this reference","type_short":"SourceType"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"type of reference, RefType.READ,WRITE,PTR...","type_short":"RefType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets a register reference at the <code>offset<\/code> on the\n specified operand index, which effectively substitutes the previous\n operation interpretation\n <br>\n <i>NOTE: If another reference was previously set on the\n operand, then it will be replaced with this register\n reference<\/i>\n@param opIndex the index of the operand to set this register reference\n@param reg a register\n@param sourceType the source of this reference\n@param refType type of reference, RefType.READ,WRITE,PTR...","static":false,"name":"setRegisterReference","comment":"Sets a register reference at the offset on the\n specified operand index, which effectively substitutes the previous\n operation interpretation\n \n NOTE: If another reference was previously set on the\n operand, then it will be replaced with this register\n reference","params":[{"type_long":"int","name":"opIndex","comment":"the index of the operand to set this register reference","type_short":"int"},{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"a register","type_short":"Register"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"sourceType","comment":"the source of this reference","type_short":"SourceType"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"type of reference, RefType.READ,WRITE,PTR...","type_short":"RefType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the number of operands for this code unit.","static":false,"name":"getNumOperands","comment":"Get the number of operands for this code unit.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get the Address for the given operand index if one exists.  Data\n objects have one operand (the value).\n@param opIndex index of the operand.\n@return An addres if the operand represents a fully qualified\n address (given the context), or if the operand is a Scalar treated\n as an address. Null is returned if no address or scalar exists on that \n operand.","static":false,"name":"getAddress","comment":"Get the Address for the given operand index if one exists.  Data\n objects have one operand (the value).","params":[{"type_long":"int","name":"opIndex","comment":"index of the operand.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"An addres if the operand represents a fully qualified\n address (given the context), or if the operand is a Scalar treated\n as an address. Null is returned if no address or scalar exists on that \n operand.","type_short":"Address"}},{"javadoc":"Returns the scalar at the given operand index.  Data objects have\n one operand (the value).\n@param opIndex index of the operand.\n@return the scalar at the given operand index or null if no\n scalar exists at that index.","static":false,"name":"getScalar","comment":"Returns the scalar at the given operand index.  Data objects have\n one operand (the value).","params":[{"type_long":"int","name":"opIndex","comment":"index of the operand.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.scalar.Scalar","comment":"the scalar at the given operand index or null if no\n scalar exists at that index.","type_short":"Scalar"}}],"name":"CodeUnit","comment":"Interface common to both instructions and data.","fields":[{"type_long":"int","javadoc":"Indicator for a mnemonic (versus an operand).","static":true,"name":"MNEMONIC","comment":"Indicator for a mnemonic (versus an operand).","type_short":"int","constant_value":"-1"},{"type_long":"int","javadoc":"","static":true,"name":"NO_COMMENT","comment":"","type_short":"int","constant_value":"-1"},{"type_long":"int","javadoc":"comment type for end of line","static":true,"name":"EOL_COMMENT","comment":"comment type for end of line","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"comment type that goes before a code unit","static":true,"name":"PRE_COMMENT","comment":"comment type that goes before a code unit","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"comment type that follows after a code unit","static":true,"name":"POST_COMMENT","comment":"comment type that follows after a code unit","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"Property name for plate comment type","static":true,"name":"PLATE_COMMENT","comment":"Property name for plate comment type","type_short":"int","constant_value":"3"},{"type_long":"int","javadoc":"Property name for repeatable comment type","static":true,"name":"REPEATABLE_COMMENT","comment":"Property name for repeatable comment type","type_short":"int","constant_value":"4"},{"type_long":"java.lang.String","javadoc":"Any comment property.","static":true,"name":"COMMENT_PROPERTY","comment":"Any comment property.","type_short":"String","constant_value":"\"COMMENT__GHIDRA_\""},{"type_long":"java.lang.String","javadoc":"Property name for vertical space formatting","static":true,"name":"SPACE_PROPERTY","comment":"Property name for vertical space formatting","type_short":"String","constant_value":"\"Space\""},{"type_long":"java.lang.String","javadoc":"Property name for code units that are instructions","static":true,"name":"INSTRUCTION_PROPERTY","comment":"Property name for code units that are instructions","type_short":"String","constant_value":"\"INSTRUCTION__GHIDRA_\""},{"type_long":"java.lang.String","javadoc":"Property name for code units that are defined data","static":true,"name":"DEFINED_DATA_PROPERTY","comment":"Property name for code units that are defined data","type_short":"String","constant_value":"\"DEFINED_DATA__GHIDRA_\""}]}
