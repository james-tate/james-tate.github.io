{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"int","name":"grp","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getGroup","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getGroupSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getMinSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getAlign","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getAddressBase","comment":"","params":[],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getType","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"isExclusion","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isReverseStack","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isBigEndian","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isFloatExtended","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isLeftJustified","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getSpace","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"","type_short":"AddressSpace"}},{"javadoc":"","static":false,"name":"getJoinRecord","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.Varnode[]","comment":"","type_short":"ghidra.program.model.pcode.Varnode[]"}},{"javadoc":"","static":false,"name":"contains","comment":"","params":[{"type_long":"ghidra.program.model.lang.ParamEntry","name":"op2","comment":"","type_short":"ParamEntry"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"justifiedContain","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"sz","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Assuming the address is contained in this entry and we -skip- to a certain byte\n return the slot associated with that byte\n@param addr is the address to check (which MUST be contained)\n@param skip is the number of bytes to skip\n@return the slot index","static":false,"name":"getSlot","comment":"Assuming the address is contained in this entry and we -skip- to a certain byte\n return the slot associated with that byte","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"is the address to check (which MUST be contained)","type_short":"Address"},{"type_long":"int","name":"skip","comment":"is the number of bytes to skip","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the slot index","type_short":"int"}},{"javadoc":"Return the storage address assigned when allocating something of size -sz- assuming -slotnum- slots\n have already been assigned.  Set res.space to null if the -sz- is too small or if\n there are not enough slots left\n@param slotnum number of slots already assigned\n@param sz number of bytes to being assigned\n@param res the final storage address\n@return slotnum plus the number of slots used","static":false,"name":"getAddrBySlot","comment":"Return the storage address assigned when allocating something of size -sz- assuming -slotnum- slots\n have already been assigned.  Set res.space to null if the -sz- is too small or if\n there are not enough slots left","params":[{"type_long":"int","name":"slotnum","comment":"number of slots already assigned","type_short":"int"},{"type_long":"int","name":"sz","comment":"number of bytes to being assigned","type_short":"int"},{"type_long":"ghidra.app.plugin.processors.sleigh.VarnodeData","name":"res","comment":"the final storage address","type_short":"VarnodeData"}],"throws":[],"return":{"type_long":"int","comment":"slotnum plus the number of slots used","type_short":"int"}},{"javadoc":"Create a join record from an XML tag. Pieces of the join are encoded as a sequence of tag attributes\n@param el\n@throws XmlParseException","static":false,"name":"readJoinXML","comment":"Create a join record from an XML tag. Pieces of the join are encoded as a sequence of tag attributes","params":[{"type_long":"ghidra.xml.XmlElement","name":"el","comment":"","type_short":"XmlElement"},{"type_long":"ghidra.program.model.lang.CompilerSpec","name":"cspec","comment":"","type_short":"CompilerSpec"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"readXMLAddress","comment":"","params":[{"type_long":"ghidra.xml.XmlPullParser","name":"parser","comment":"","type_short":"XmlPullParser"},{"type_long":"ghidra.program.model.lang.CompilerSpec","name":"cspec","comment":"","type_short":"CompilerSpec"},{"type_long":"int","name":"size","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"restoreXml","comment":"","params":[{"type_long":"ghidra.xml.XmlPullParser","name":"parser","comment":"","type_short":"XmlPullParser"},{"type_long":"ghidra.program.model.lang.CompilerSpec","name":"cspec","comment":"","type_short":"CompilerSpec"},{"type_long":"boolean","name":"normalstack","comment":"","type_short":"boolean"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Unsigned less-than operation\n@param a\n@param b\n@return return true is a is less than b, where a and b are interpreted as unsigned integers","static":true,"name":"unsignedCompare","comment":"Unsigned less-than operation","params":[{"type_long":"long","name":"a","comment":"","type_short":"long"},{"type_long":"long","name":"b","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"boolean","comment":"return true is a is less than b, where a and b are interpreted as unsigned integers","type_short":"boolean"}},{"javadoc":"Return -1 if (op2,sz2) is not properly contained in (op1,sz1)\n If it is contained, return the endian aware offset of (op2,sz2)\n I.e. if the least significant byte of the op2 range falls on the least significant\n byte of the op1 range, return 0.  If it intersects the second least significant, return 1, etc.\n@param op1 base address of first range\n@param sz1 size of first range\n@param op2 base address of second range\n@param sz2 size of second range\n@param forceleft is true if containment is forced to be on the left even for big endian\n@return the endian aware offset or -1","static":true,"name":"justifiedContainAddress","comment":"Return -1 if (op2,sz2) is not properly contained in (op1,sz1)\n If it is contained, return the endian aware offset of (op2,sz2)\n I.e. if the least significant byte of the op2 range falls on the least significant\n byte of the op1 range, return 0.  If it intersects the second least significant, return 1, etc.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc1","comment":"","type_short":"AddressSpace"},{"type_long":"long","name":"offset1","comment":"","type_short":"long"},{"type_long":"int","name":"sz1","comment":"size of first range","type_short":"int"},{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc2","comment":"","type_short":"AddressSpace"},{"type_long":"long","name":"offset2","comment":"","type_short":"long"},{"type_long":"int","name":"sz2","comment":"size of second range","type_short":"int"},{"type_long":"boolean","name":"forceleft","comment":"is true if containment is forced to be on the left even for big endian","type_short":"boolean"},{"type_long":"boolean","name":"isBigEndian","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"int","comment":"the endian aware offset or -1","type_short":"int"}},{"javadoc":"","static":true,"name":"getMetatype","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"tp","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}}],"name":"ParamEntry","comment":"","fields":[{"type_long":"int","javadoc":"","static":true,"name":"FORCE_LEFT_JUSTIFY","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"REVERSE_STACK","comment":"","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"","static":true,"name":"SMALLSIZE_ZEXT","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"SMALLSIZE_SEXT","comment":"","type_short":"int","constant_value":"8"},{"type_long":"int","javadoc":"","static":true,"name":"IS_BIG_ENDIAN","comment":"","type_short":"int","constant_value":"16"},{"type_long":"int","javadoc":"","static":true,"name":"SMALLSIZE_INTTYPE","comment":"","type_short":"int","constant_value":"32"},{"type_long":"int","javadoc":"","static":true,"name":"SMALLSIZE_FLOAT","comment":"","type_short":"int","constant_value":"64"},{"type_long":"int","javadoc":"","static":true,"name":"TYPE_UNKNOWN","comment":"","type_short":"int","constant_value":"8"},{"type_long":"int","javadoc":"","static":true,"name":"TYPE_PTR","comment":"","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"","static":true,"name":"TYPE_FLOAT","comment":"","type_short":"int","constant_value":"3"},{"type_long":"int","javadoc":"","static":false,"name":"flags","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"type","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"group","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"groupsize","comment":"","type_short":"int","constant_value":null},{"type_long":"ghidra.program.model.address.AddressSpace","javadoc":"","static":false,"name":"spaceid","comment":"","type_short":"AddressSpace","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"addressbase","comment":"","type_short":"long","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"size","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"minsize","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"alignment","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"numslots","comment":"","type_short":"int","constant_value":null},{"type_long":"ghidra.program.model.pcode.Varnode[]","javadoc":"","static":false,"name":"joinrec","comment":"","type_short":"ghidra.program.model.pcode.Varnode[]","constant_value":null}]}
