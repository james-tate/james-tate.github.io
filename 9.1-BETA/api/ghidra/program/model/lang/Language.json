{"implements":[],"javadoc":"","static":false,"methods":[{"javadoc":"Returns the LanguageID of this language, which is used as a primary key to\n find the language when Ghidra loads it.\n@return the LanguageID of this language","static":false,"name":"getLanguageID","comment":"Returns the LanguageID of this language, which is used as a primary key to\n find the language when Ghidra loads it.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.LanguageID","comment":"the LanguageID of this language","type_short":"LanguageID"}},{"javadoc":"Returns the LanguageDescription of this language, which contains useful\n information about the characteristics of the language.\n@return the LanguageDescription of this language","static":false,"name":"getLanguageDescription","comment":"Returns the LanguageDescription of this language, which contains useful\n information about the characteristics of the language.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.LanguageDescription","comment":"the LanguageDescription of this language","type_short":"LanguageDescription"}},{"javadoc":"Returns a parallel instruction helper for this language or null\n if one has not been defined.\n@return parallel instruction helper or null if not applicable","static":false,"name":"getParallelInstructionHelper","comment":"Returns a parallel instruction helper for this language or null\n if one has not been defined.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.ParallelInstructionLanguageHelper","comment":"parallel instruction helper or null if not applicable","type_short":"ParallelInstructionLanguageHelper"}},{"javadoc":"Returns the processor name on which this language is based.\n \n For example, 30386, Pentium, 68010, etc.\n@return the processor name","static":false,"name":"getProcessor","comment":"Returns the processor name on which this language is based.\n \n For example, 30386, Pentium, 68010, etc.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Processor","comment":"the processor name","type_short":"Processor"}},{"javadoc":"Returns the major version for this language. Returning a version number\n different than before could cause the program to try and \"update\" itself.\n Those languages which do not support this feature may always return a\n constant value of 1.\n@return the language version number","static":false,"name":"getVersion","comment":"Returns the major version for this language. Returning a version number\n different than before could cause the program to try and \"update\" itself.\n Those languages which do not support this feature may always return a\n constant value of 1.","params":[],"throws":[],"return":{"type_long":"int","comment":"the language version number","type_short":"int"}},{"javadoc":"Returns the minor version for this language. Returning a minor version\n number different than before could cause the program to try and \"update\"\n itself. Those languages which do not support this feature may always\n return a constant value of 0.\n@return the language minor version number","static":false,"name":"getMinorVersion","comment":"Returns the minor version for this language. Returning a minor version\n number different than before could cause the program to try and \"update\"\n itself. Those languages which do not support this feature may always\n return a constant value of 0.","params":[],"throws":[],"return":{"type_long":"int","comment":"the language minor version number","type_short":"int"}},{"javadoc":"Get the AddressFactory for this language. The returned Address factory will allow\n addresses associated with physical, constant and unique spaces to be instantiated.  \n NOTE! this factory does not know about compiler or program specified spaces.  \n Spaces such as stack and overlay spaces are not defined by the language - \n if these are needed, Program.getAddressFactory() should be used instead.\n@return the AddressFactory for this language.\n@see Program#getAddressFactory()","static":false,"name":"getAddressFactory","comment":"Get the AddressFactory for this language. The returned Address factory will allow\n addresses associated with physical, constant and unique spaces to be instantiated.  \n NOTE! this factory does not know about compiler or program specified spaces.  \n Spaces such as stack and overlay spaces are not defined by the language - \n if these are needed, Program.getAddressFactory() should be used instead.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressFactory","comment":"the AddressFactory for this language.","type_short":"AddressFactory"}},{"javadoc":"Get the default memory\/code space.\n@return default address space","static":false,"name":"getDefaultSpace","comment":"Get the default memory\/code space.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"default address space","type_short":"AddressSpace"}},{"javadoc":"Get the preferred data space used by loaders for data sections.\n@return default data address space","static":false,"name":"getDefaultDataSpace","comment":"Get the preferred data space used by loaders for data sections.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"default data address space","type_short":"AddressSpace"}},{"javadoc":"get the Endian type for this language. (If a language supports both, then\n this returns an initial or default value.)\n@return true for BigEndian, false for LittleEndian.","static":false,"name":"isBigEndian","comment":"get the Endian type for this language. (If a language supports both, then\n this returns an initial or default value.)","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true for BigEndian, false for LittleEndian.","type_short":"boolean"}},{"javadoc":"Get instruction alignment in terms of bytes.\n@return instruction alignment","static":false,"name":"getInstructionAlignment","comment":"Get instruction alignment in terms of bytes.","params":[],"throws":[],"return":{"type_long":"int","comment":"instruction alignment","type_short":"int"}},{"javadoc":"Return true if the instructions in this language support Pcode.","static":false,"name":"supportsPcode","comment":"Return true if the instructions in this language support Pcode.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if the language has defined the specified location as\n volatile.\n@param addr location address","static":false,"name":"isVolatile","comment":"Returns true if the language has defined the specified location as\n volatile.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"location address","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get the InstructionPrototype that matches the bytes presented by the\n MemBuffer object.\n@param buf the MemBuffer that presents the bytes in Memory at some\n            address as if they were an array of bytes starting at index 0.\n@param context the processor context at the address to be disassembled\n@param inDelaySlot true if this instruction should be parsed as if it were in a\n            delay slot\n@return the InstructionPrototype that matches the bytes in buf.\n@exception InsufficientBytesException thrown if there are not enough bytes in memory to satisfy\n                a legal instruction.\n@exception UnknownInstructionException thrown if the byte pattern does not match any legal\n                instruction.","static":false,"name":"parse","comment":"Get the InstructionPrototype that matches the bytes presented by the\n MemBuffer object.","params":[{"type_long":"ghidra.program.model.mem.MemBuffer","name":"buf","comment":"the MemBuffer that presents the bytes in Memory at some\n            address as if they were an array of bytes starting at index 0.","type_short":"MemBuffer"},{"type_long":"ghidra.program.model.lang.ProcessorContext","name":"context","comment":"the processor context at the address to be disassembled","type_short":"ProcessorContext"},{"type_long":"boolean","name":"inDelaySlot","comment":"true if this instruction should be parsed as if it were in a\n            delay slot","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.lang.InsufficientBytesException","comment":"","type_short":"InsufficientBytesException"},{"type_long":"ghidra.program.model.lang.UnknownInstructionException","comment":"","type_short":"UnknownInstructionException"}],"return":{"type_long":"ghidra.program.model.lang.InstructionPrototype","comment":"the InstructionPrototype that matches the bytes in buf.","type_short":"InstructionPrototype"}},{"javadoc":"Get the total number of user defined pcode names.\n \n Note: only works for Pcode based languages","static":false,"name":"getNumberOfUserDefinedOpNames","comment":"Get the total number of user defined pcode names.\n \n Note: only works for Pcode based languages","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get the user define name for a given index. Certain pcode has operations\n defined only by name that when the pcode returns, only the index is\n known.\n \n Note: only works for Pcode based languages","static":false,"name":"getUserDefinedOpName","comment":"Get the user define name for a given index. Certain pcode has operations\n defined only by name that when the pcode returns, only the index is\n known.\n \n Note: only works for Pcode based languages","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns all the registers (each different size is a different register)\n for an address.\n@param address the register address for which to return all registers.\n@return all the registers (each different size is a different register)\n         for an address.","static":false,"name":"getRegisters","comment":"Returns all the registers (each different size is a different register)\n for an address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the register address for which to return all registers.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register[]","comment":"all the registers (each different size is a different register)\n         for an address.","type_short":"ghidra.program.model.lang.Register[]"}},{"javadoc":"Get a register given the address space it is in, its offset in the space\n and its size.\n@param addrspc address space the register is in\n@param offset offset of the register in the space\n@param size size of the register in bytes\n@return the register","static":false,"name":"getRegister","comment":"Get a register given the address space it is in, its offset in the space\n and its size.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"addrspc","comment":"address space the register is in","type_short":"AddressSpace"},{"type_long":"long","name":"offset","comment":"offset of the register in the space","type_short":"long"},{"type_long":"int","name":"size","comment":"size of the register in bytes","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"the register","type_short":"Register"}},{"javadoc":"get the array of Register objects that this language supports.\n@return the array of processor registers.","static":false,"name":"getRegisters","comment":"get the array of Register objects that this language supports.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register[]","comment":"the array of processor registers.","type_short":"ghidra.program.model.lang.Register[]"}},{"javadoc":"Get a register given the name of the register\n@param name Register name\n@return the register","static":false,"name":"getRegister","comment":"Get a register given the name of the register","params":[{"type_long":"java.lang.String","name":"name","comment":"Register name","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"the register","type_short":"Register"}},{"javadoc":"Get a register given it's underlying address location and size.\n@param addr location of the register in its address space\n@param size the size of the register (in bytes).  A value of 0 will return the \n            largest register at the specified addr\n@return the register","static":false,"name":"getRegister","comment":"Get a register given it's underlying address location and size.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"location of the register in its address space","type_short":"Address"},{"type_long":"int","name":"size","comment":"the size of the register (in bytes).  A value of 0 will return the \n            largest register at the specified addr","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"the register","type_short":"Register"}},{"javadoc":"Return the list of labels for well-known locations.\n@return AddressLabelPair[] empty array if there are no labels","static":false,"name":"getDefaultLabels","comment":"Return the list of labels for well-known locations.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.util.AddressLabelInfo>","comment":"AddressLabelPair[] empty array if there are no labels","type_short":"List"}},{"javadoc":"Get the default program counter register for this language if there is\n one.\n@return default program counter register.","static":false,"name":"getProgramCounter","comment":"Get the default program counter register for this language if there is\n one.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"default program counter register.","type_short":"Register"}},{"javadoc":"Returns context base register or null if one has not been defined by the\n language.","static":false,"name":"getContextBaseRegister","comment":"Returns context base register or null if one has not been defined by the\n language.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"","type_short":"Register"}},{"javadoc":"Returns the default memory blocks for this language.\n@return the default memory blocks for this language","static":false,"name":"getDefaultMemoryBlocks","comment":"Returns the default memory blocks for this language.","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.processors.generic.MemoryBlockDefinition[]","comment":"the default memory blocks for this language","type_short":"ghidra.app.plugin.processors.generic.MemoryBlockDefinition[]"}},{"javadoc":"Returns the default symbols for this language.\n@return the default symbols for this language","static":false,"name":"getDefaultSymbols","comment":"Returns the default symbols for this language.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.util.AddressLabelInfo>","comment":"the default symbols for this language","type_short":"List"}},{"javadoc":"Returns the name of the segmented space for this language, or the\n empty string if the memory model for this language is not\n segmented.\n@return the name of the segmented space or \"\"","static":false,"name":"getSegmentedSpace","comment":"Returns the name of the segmented space for this language, or the\n empty string if the memory model for this language is not\n segmented.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name of the segmented space or \"\"","type_short":"String"}},{"javadoc":"Returns an AddressSetView of the volatile addresses for this language\n@return an AddressSetView of the volatile addresses for this language","static":false,"name":"getVolatileAddresses","comment":"Returns an AddressSetView of the volatile addresses for this language","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"an AddressSetView of the volatile addresses for this language","type_short":"AddressSetView"}},{"javadoc":"Apply context settings to the ProgramContext as specified by the\n configuration\n@param ctx is the default program context","static":false,"name":"applyContextSettings","comment":"Apply context settings to the ProgramContext as specified by the\n configuration","params":[{"type_long":"ghidra.program.model.listing.DefaultProgramContext","name":"ctx","comment":"is the default program context","type_short":"DefaultProgramContext"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Refreshes the definition of this language if possible (statically defined\n languages can safely do nothing).\n@param taskMonitor monitor for progress back to the user\n@throws IOException","static":false,"name":"reloadLanguage","comment":"Refreshes the definition of this language if possible (statically defined\n languages can safely do nothing).","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"taskMonitor","comment":"monitor for progress back to the user","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a list of all compatible compiler spec descriptions.\n The first item in the list is the default.","static":false,"name":"getCompatibleCompilerSpecDescriptions","comment":"Returns a list of all compatible compiler spec descriptions.\n The first item in the list is the default.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.lang.CompilerSpecDescription>","comment":"","type_short":"List"}},{"javadoc":"Returns the compiler spec associated with a given CompilerSpecID.\n@param compilerSpecID the compiler spec id\n@return the compiler spec associated with the given id\n@throws CompilerSpecNotFoundException if no such compiler spec exists","static":false,"name":"getCompilerSpecByID","comment":"Returns the compiler spec associated with a given CompilerSpecID.","params":[{"type_long":"ghidra.program.model.lang.CompilerSpecID","name":"compilerSpecID","comment":"the compiler spec id","type_short":"CompilerSpecID"}],"throws":[{"type_long":"ghidra.program.model.lang.CompilerSpecNotFoundException","comment":"if no such compiler spec exists","type_short":"CompilerSpecNotFoundException"}],"return":{"type_long":"ghidra.program.model.lang.CompilerSpec","comment":"the compiler spec associated with the given id","type_short":"CompilerSpec"}},{"javadoc":"Returns the default compiler spec for this language, which is used\n when a loader cannot determine the compiler spec or for upgrades when a\n program had no compiler spec registered (seriously old program, like\n Ghidra 4.1 or earlier).  NOTE: this has NOTHING to do with the\n compiler spec registered for a program.  Use Program.getCompilerSpec()\n for that!\n@return the default compiler spec for this language","static":false,"name":"getDefaultCompilerSpec","comment":"Returns the default compiler spec for this language, which is used\n when a loader cannot determine the compiler spec or for upgrades when a\n program had no compiler spec registered (seriously old program, like\n Ghidra 4.1 or earlier).  NOTE: this has NOTHING to do with the\n compiler spec registered for a program.  Use Program.getCompilerSpec()\n for that!","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.CompilerSpec","comment":"the default compiler spec for this language","type_short":"CompilerSpec"}},{"javadoc":"Returns whether this lanugage has a property defined.\n@param key the property key\n@return if the property is defined","static":false,"name":"hasProperty","comment":"Returns whether this lanugage has a property defined.","params":[{"type_long":"java.lang.String","name":"key","comment":"the property key","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"if the property is defined","type_short":"boolean"}},{"javadoc":"Gets the value of a property as an int, returning defaultInt if undefined.\n@param key the property key\n@param defaultInt the default value to return if property is undefined\n@return the property value as an int, or the default value if undefined","static":false,"name":"getPropertyAsInt","comment":"Gets the value of a property as an int, returning defaultInt if undefined.","params":[{"type_long":"java.lang.String","name":"key","comment":"the property key","type_short":"String"},{"type_long":"int","name":"defaultInt","comment":"the default value to return if property is undefined","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the property value as an int, or the default value if undefined","type_short":"int"}},{"javadoc":"Gets the value of a property as a boolean, returning defaultBoolean if undefined.\n@param key the property key\n@param defaultBoolean the default value to return if property is undefined\n@return the property value as a boolean, or the default value if undefined","static":false,"name":"getPropertyAsBoolean","comment":"Gets the value of a property as a boolean, returning defaultBoolean if undefined.","params":[{"type_long":"java.lang.String","name":"key","comment":"the property key","type_short":"String"},{"type_long":"boolean","name":"defaultBoolean","comment":"the default value to return if property is undefined","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"the property value as a boolean, or the default value if undefined","type_short":"boolean"}},{"javadoc":"Gets the value of a property as a String, returning defaultString if undefined.\n@param key the property key\n@param defaultString the default value to return if property is undefined\n@return the property value as a String, or the default value if undefined","static":false,"name":"getProperty","comment":"Gets the value of a property as a String, returning defaultString if undefined.","params":[{"type_long":"java.lang.String","name":"key","comment":"the property key","type_short":"String"},{"type_long":"java.lang.String","name":"defaultString","comment":"the default value to return if property is undefined","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the property value as a String, or the default value if undefined","type_short":"String"}},{"javadoc":"Gets a property defined for this language, or null if that property isn't defined.\n@param key the property key\n@return the property value, or null if not defined","static":false,"name":"getProperty","comment":"Gets a property defined for this language, or null if that property isn't defined.","params":[{"type_long":"java.lang.String","name":"key","comment":"the property key","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the property value, or null if not defined","type_short":"String"}},{"javadoc":"Returns a read-only set view of the property keys defined on this language.\n@return read-only set of property keys","static":false,"name":"getPropertyKeys","comment":"Returns a read-only set view of the property keys defined on this language.","params":[],"throws":[],"return":{"type_long":"java.util.Set<java.lang.String>","comment":"read-only set of property keys","type_short":"Set"}},{"javadoc":"Returns whether the language has a valid manual defined.\n@return if the language has a manual","static":false,"name":"hasManual","comment":"Returns whether the language has a valid manual defined.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"if the language has a manual","type_short":"boolean"}},{"javadoc":"Get the ManualEntry for the given instruction mnemonic.\n@param instruction the instruction mnemonic\n@return the ManualEntry or null if instruction mnemonic not found","static":false,"name":"getManualEntry","comment":"Get the ManualEntry for the given instruction mnemonic.","params":[{"type_long":"java.lang.String","name":"instructionMnemonic","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.util.ManualEntry","comment":"the ManualEntry or null if instruction mnemonic not found","type_short":"ManualEntry"}},{"javadoc":"Returns a read-only set view of the instruction mnemonic keys defined on\n this language.\n@return read-only set of instruction mnemonic keys","static":false,"name":"getManualInstructionMnemonicKeys","comment":"Returns a read-only set view of the instruction mnemonic keys defined on\n this language.","params":[],"throws":[],"return":{"type_long":"java.util.Set<java.lang.String>","comment":"read-only set of instruction mnemonic keys","type_short":"Set"}},{"javadoc":"Returns the exception generated trying to load the manual, or null if it succeeded.\n@return the exception generated trying to load the manual, or null if it succeeded","static":false,"name":"getManualException","comment":"Returns the exception generated trying to load the manual, or null if it succeeded.","params":[],"throws":[],"return":{"type_long":"java.lang.Exception","comment":"the exception generated trying to load the manual, or null if it succeeded","type_short":"Exception"}},{"javadoc":"Returns the array of vector registers, sorted first by size and then by name.\n@return sorted array of vector registers.","static":false,"name":"getSortedVectorRegisters","comment":"Returns the array of vector registers, sorted first by size and then by name.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register[]","comment":"sorted array of vector registers.","type_short":"ghidra.program.model.lang.Register[]"}}],"name":"Language","comment":"","fields":[]}
