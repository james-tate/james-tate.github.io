{"implements":[],"javadoc":"Represents an instance of a string in a {@link MemBuffer}.\n <p>\n This class handles all the details of detecting a terminated string's length,\n converting the bytes in the membuffer into a java native String, and converting\n the raw String into a formatted human-readable version, according to the\n various {@link SettingsDefinition}s attached to the string data location.\n <p>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Returns true if the {@link Data} instance is a 'string'.\n@param data {@link Data} instance to test, null ok.\n@return boolean true if string data.","static":true,"name":"isString","comment":"Returns true if the Data instance is a 'string'.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"Data instance to test, null ok.","type_short":"Data"}],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if string data.","type_short":"boolean"}},{"javadoc":"","static":true,"name":"isChar","comment":"","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"","type_short":"Data"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns a new {@link StringDataInstance} using the bytes in the data codeunit.\n <p>\n@param data {@link Data} item\n@return new {@link StringDataInstance}, never NULL.  See {@link #NULL_INSTANCE}.","static":true,"name":"getStringDataInstance","comment":"Returns a new StringDataInstance using the bytes in the data codeunit.\n ","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"Data item","type_short":"Data"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringDataInstance","comment":"new StringDataInstance, never NULL.  See #NULL_INSTANCE.","type_short":"StringDataInstance"}},{"javadoc":"Returns a new {@link StringDataInstance} using the bytes in the MemBuffer.\n <p>\n@param dataType {@link DataType} of the bytes in the buffer.\n@param buf memory buffer containing the bytes.\n@param settings the Settings object\n@param length the length of the data.\n@return new {@link StringDataInstance}, never NULL.  See {@link #NULL_INSTANCE}.","static":true,"name":"getStringDataInstance","comment":"Returns a new StringDataInstance using the bytes in the MemBuffer.\n ","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"DataType of the bytes in the buffer.","type_short":"DataType"},{"type_long":"ghidra.program.model.mem.MemBuffer","name":"buf","comment":"memory buffer containing the bytes.","type_short":"MemBuffer"},{"type_long":"ghidra.docking.settings.Settings","name":"settings","comment":"the Settings object","type_short":"Settings"},{"type_long":"int","name":"length","comment":"the length of the data.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringDataInstance","comment":"new StringDataInstance, never NULL.  See #NULL_INSTANCE.","type_short":"StringDataInstance"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a string instance using the data in the {@link MemBuffer} and the settings\n pulled from the {@link AbstractStringDataType string data type}.\n@param stringDataType {@link AbstractStringDataType} common string base data type.\n@param settings {@link Settings} attached to the data location.\n@param buf {@link MemBuffer} containing the data.\n@param length Length passed from the caller to the datatype.  -1 indicates a 'probe'\n trying to detect the length of an unknown string, otherwise it will be the length\n of the containing field of the data instance.","static":false,"name":"<init>","comment":"Creates a string instance using the data in the MemBuffer and the settings\n pulled from the AbstractStringDataType.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"},{"type_long":"ghidra.docking.settings.Settings","name":"settings","comment":"Settings attached to the data location.","type_short":"Settings"},{"type_long":"ghidra.program.model.mem.MemBuffer","name":"buf","comment":"MemBuffer containing the data.","type_short":"MemBuffer"},{"type_long":"int","name":"length","comment":"Length passed from the caller to the datatype.  -1 indicates a 'probe'\n trying to detect the length of an unknown string, otherwise it will be the length\n of the containing field of the data instance.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.data.StringDataInstance","name":"copyFrom","comment":"","type_short":"StringDataInstance"},{"type_long":"ghidra.program.model.data.StringLayoutEnum","name":"newLayout","comment":"","type_short":"StringLayoutEnum"},{"type_long":"ghidra.program.model.mem.MemBuffer","name":"newBuf","comment":"","type_short":"MemBuffer"},{"type_long":"int","name":"newLen","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"getDataOrganization","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataOrganization","comment":"","type_short":"DataOrganization"}},{"javadoc":"","static":true,"name":"getLayoutFromDataType","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringLayoutEnum","comment":"","type_short":"StringLayoutEnum"}},{"javadoc":"","static":true,"name":"getCharsetNameFromDataTypeOrSettings","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"},{"type_long":"ghidra.docking.settings.Settings","name":"settings","comment":"","type_short":"Settings"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns the string name of the charset.\n@return string charset name","static":false,"name":"getCharsetName","comment":"Returns the string name of the charset.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"string charset name","type_short":"String"}},{"javadoc":"Returns the address of the {@link MemBuffer}.\n@return {@link Address} of the MemBuffer.","static":false,"name":"getAddress","comment":"Returns the address of the MemBuffer.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"Address of the MemBuffer.","type_short":"Address"}},{"javadoc":"","static":false,"name":"isBadCharSize","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isProbe","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isAlreadyDeterminedFixedLen","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isPascal","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the length of this string's data, in bytes.\n@return number of bytes in this string.","static":false,"name":"getDataLength","comment":"Returns the length of this string's data, in bytes.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of bytes in this string.","type_short":"int"}},{"javadoc":"Returns the length, in bytes, of the string data object contained in the\n {@link MemBuffer}, or -1 if the length could not be determined.\n <p>\n This is not the same as the number of characters in the string, or the number of bytes\n occupied by the characters.  For instance, pascal strings have a 1 or 2 byte length\n field that increases the size of the string data object beyond the characters in the\n string, and null terminated strings have don't include the null character, but its\n presence is included in the size of the string object.\n <p>\n For length-specified string data types that do not use null-terminators and with a\n known data instance length (ie. not a probe), this method just returns the\n value specified in the constructor {@code length} parameter, otherwise a null-terminator\n is searched for.\n <p>\n When searching for a null-terminator, the constructor {@code length} parameter will\n be respected or ignored depending on the {@link StringLayoutEnum}.\n <p>\n When the length parameter is ignored (ie. \"unbounded\" searching), the search is\n limited to {@link #MAX_STRING_LENGTH} bytes.\n <p>\n The MemBuffer's endian'ness is used to determine which end of the padded character\n field contains our n-bit character which will be tested for null-ness.  (not the\n endian'ness of the character set name - ie. \"UTF-16BE\")\n@return length of the string (NOT including null term if null term probe), in bytes,\n or -1 if no terminator found.","static":false,"name":"getStringLength","comment":"Returns the length, in bytes, of the string data object contained in the\n MemBuffer, or -1 if the length could not be determined.\n \n This is not the same as the number of characters in the string, or the number of bytes\n occupied by the characters.  For instance, pascal strings have a 1 or 2 byte length\n field that increases the size of the string data object beyond the characters in the\n string, and null terminated strings have don't include the null character, but its\n presence is included in the size of the string object.\n \n For length-specified string data types that do not use null-terminators and with a\n known data instance length (ie. not a probe), this method just returns the\n value specified in the constructor  parameter, otherwise a null-terminator\n is searched for.\n \n When searching for a null-terminator, the constructor  parameter will\n be respected or ignored depending on the StringLayoutEnum.\n \n When the length parameter is ignored (ie. \"unbounded\" searching), the search is\n limited to #MAX_STRING_LENGTH bytes.\n \n The MemBuffer's endian'ness is used to determine which end of the padded character\n field contains our n-bit character which will be tested for null-ness.  (not the\n endian'ness of the character set name - ie. \"UTF-16BE\")","params":[],"throws":[],"return":{"type_long":"int","comment":"length of the string (NOT including null term if null term probe), in bytes,\n or -1 if no terminator found.","type_short":"int"}},{"javadoc":"","static":false,"name":"getNullTerminatedLength","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns true if the string has a trailing NULL character within the data instance's\n bounds.\n@return boolean true if there is a trailing NULL character.","static":false,"name":"hasNullTerminator","comment":"Returns true if the string has a trailing NULL character within the data instance's\n bounds.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if there is a trailing NULL character.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getPascalLength","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"readChar","comment":"","params":[{"type_long":"byte[]","name":"charBuf","comment":"","type_short":"byte[]"},{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isNullChar","comment":"","params":[{"type_long":"byte[]","name":"charBuf","comment":"","type_short":"byte[]"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the string contained in the specified {@link MemBuffer}, or null if\n all the bytes of the string could not be read.\n <p>\n This method deals in characters of size {@link #charSize}, that might be\n {@link #paddedCharSize padded} to a larger size.  The raw n-byte characters\n are converted into a Java String using a Java {@link Charset} or by\n using a custom Ghidra conversion.  (see convertBytesToStringCustomCharset)\n <p>\n The MemBuffer's endian'ness is used to determine which end of the\n {@link #paddedCharSize padded } field contains our {@link #charSize}\n character bytes which will be used to create the java String.\n@return String containing the characters in buf or null if unable to read all\n {@code length} bytes from the membuffer.","static":false,"name":"getStringValue","comment":"Returns the string contained in the specified MemBuffer, or null if\n all the bytes of the string could not be read.\n \n This method deals in characters of size #charSize, that might be\n #paddedCharSize to a larger size.  The raw n-byte characters\n are converted into a Java String using a Java Charset or by\n using a custom Ghidra conversion.  (see convertBytesToStringCustomCharset)\n \n The MemBuffer's endian'ness is used to determine which end of the\n #paddedCharSize field contains our #charSize\n character bytes which will be used to create the java String.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"String containing the characters in buf or null if unable to read all\n  bytes from the membuffer.","type_short":"String"}},{"javadoc":"","static":false,"name":"getStringValueNoTrim","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getStringBytes","comment":"","params":[],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"getNormalStringCharBytes","comment":"","params":[],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"getPascalCharBytes","comment":"","params":[],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"isValidOffcutOffset","comment":"","params":[{"type_long":"int","name":"offcutBytes","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getCharOffset","comment":"","params":[{"type_long":"int","name":"charCount","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getOffcutLayout","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringLayoutEnum","comment":"","type_short":"StringLayoutEnum"}},{"javadoc":"","static":false,"name":"getBytesFromMemBuff","comment":"","params":[{"type_long":"ghidra.program.model.mem.MemBuffer","name":"memBuffer","comment":"","type_short":"MemBuffer"},{"type_long":"int","name":"copyLen","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"convertPaddedToUnpadded","comment":"","params":[{"type_long":"byte[]","name":"paddedBytes","comment":"","type_short":"byte[]"}],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"getMemoryEndianness","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Endian","comment":"","type_short":"Endian"}},{"javadoc":"","static":false,"name":"convertBytesToString","comment":"","params":[{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"},{"type_long":"ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo","name":"aci","comment":"","type_short":"AdjustedCharsetInfo"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getAdjustedCharsetInfo","comment":"","params":[{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo","comment":"","type_short":"AdjustedCharsetInfo"}},{"javadoc":"","static":false,"name":"convertStringToBytes","comment":"","params":[{"type_long":"java.lang.String","name":"s","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo","name":"aci","comment":"","type_short":"AdjustedCharsetInfo"}],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":true,"name":"getDataConverter","comment":"","params":[{"type_long":"ghidra.program.model.lang.Endian","name":"endian","comment":"","type_short":"Endian"}],"throws":[],"return":{"type_long":"ghidra.util.DataConverter","comment":"","type_short":"DataConverter"}},{"javadoc":"","static":true,"name":"convertBytesToStringCustomCharset","comment":"","params":[{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"},{"type_long":"ghidra.program.model.data.StringDataInstance.AdjustedCharsetInfo","name":"aci","comment":"","type_short":"AdjustedCharsetInfo"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getEndiannessFromBOM","comment":"","params":[{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"},{"type_long":"int","name":"charSize","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Endian","comment":"","type_short":"Endian"}},{"javadoc":"Returns a formatted version of the string returned by {@link #getStringValue()}.\n <p>\n The resulting string will be formatted with quotes around the parts that contain\n plain ASCII alpha characters (and simple escape sequences), and out-of-range\n byte-ish values listed as comma separated hex-encoded values:\n <p>\n Example (quotes are part of result): {@code \"Test\\tstring\",01,02,\"Second\\npart\",00}\n@return formatted String","static":false,"name":"getStringRepresentation","comment":"Returns a formatted version of the string returned by #getStringValue().\n \n The resulting string will be formatted with quotes around the parts that contain\n plain ASCII alpha characters (and simple escape sequences), and out-of-range\n byte-ish values listed as comma separated hex-encoded values:\n \n Example (quotes are part of result): ","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"formatted String","type_short":"String"}},{"javadoc":"Trims trailing nulls off the end of the string.\n@param s String to trim\n@return new String without any trailing null chars.","static":false,"name":"trimNulls","comment":"Trims trailing nulls off the end of the string.","params":[{"type_long":"java.lang.String","name":"s","comment":"String to trim","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"new String without any trailing null chars.","type_short":"String"}},{"javadoc":"Returns the value of the stored\n {@link TranslationSettingsDefinition#getTranslatedValue(Settings) translated settings}\n string.\n <p>\n@return previously translated string.","static":false,"name":"getTranslatedValue","comment":"Returns the value of the stored\n TranslationSettingsDefinition#getTranslatedValue(Settings)\n string.\n ","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"previously translated string.","type_short":"String"}},{"javadoc":"Returns true if the user should be shown the translated value of the string instead\n of the real value.\n@return boolean true if should show previously translated value.","static":false,"name":"isShowTranslation","comment":"Returns true if the user should be shown the translated value of the string instead\n of the real value.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if should show previously translated value.","type_short":"boolean"}},{"javadoc":"Convert a char value in memory into its canonical unicode representation, using\n attached charset and encoding information.\n <p>\n This implementation treats the char value as a 1 element long string and reuses the string\n logic to read it from memory using charset info.\n@return String containing the representation of the single char.","static":false,"name":"getCharRepresentation","comment":"Convert a char value in memory into its canonical unicode representation, using\n attached charset and encoding information.\n \n This implementation treats the char value as a 1 element long string and reuses the string\n logic to read it from memory using charset info.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"String containing the representation of the single char.","type_short":"String"}},{"javadoc":"","static":false,"name":"isMismatchedCharBytes","comment":"","params":[{"type_long":"byte[]","name":"originalCharBytes","comment":"","type_short":"byte[]"},{"type_long":"int","name":"codePoint","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"getTranslatedStringRepresentation","comment":"","params":[{"type_long":"java.lang.String","name":"translatedString","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getLabel","comment":"","params":[{"type_long":"java.lang.String","name":"prefixStr","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"abbrevPrefixStr","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"defaultStr","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.data.DataTypeDisplayOptions","name":"options","comment":"","type_short":"DataTypeDisplayOptions"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getOffcutLabelString","comment":"","params":[{"type_long":"java.lang.String","name":"prefixStr","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"abbrevPrefixStr","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"defaultStr","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.data.DataTypeDisplayOptions","name":"options","comment":"","type_short":"DataTypeDisplayOptions"},{"type_long":"int","name":"byteOffset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns a new {@link StringDataInstance} that points to the string characters\n that start at {@code byteOffset} from the start of this instance.\n <p>\n If the requested offset is not valid, the base string instance (itself) will be returned\n instead of a new instance.\n <p>\n@param byteOffset number of bytes from start of data instance to start new instance.\n@return new StringDataInstance, or <code>this<\/code> if offset not valid.","static":false,"name":"getByteOffcut","comment":"Returns a new StringDataInstance that points to the string characters\n that start at  from the start of this instance.\n \n If the requested offset is not valid, the base string instance (itself) will be returned\n instead of a new instance.\n ","params":[{"type_long":"int","name":"byteOffset","comment":"number of bytes from start of data instance to start new instance.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringDataInstance","comment":"new StringDataInstance, or this if offset not valid.","type_short":"StringDataInstance"}},{"javadoc":"Create a new {@link StringDataInstance} that points to a portion of this\n instance, starting at a character offset (whereever that may be) into the data.\n <p>\n@param offsetChars number of characters from the beginning of the string to start\n the new StringDataInstance.\n@return new {@link StringDataInstance} pointing to a subset of characters, or the\n <code>this<\/code> instance if there was an error.","static":false,"name":"getCharOffcut","comment":"Create a new StringDataInstance that points to a portion of this\n instance, starting at a character offset (whereever that may be) into the data.\n ","params":[{"type_long":"int","name":"offsetChars","comment":"number of characters from the beginning of the string to start\n the new StringDataInstance.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.StringDataInstance","comment":"new StringDataInstance pointing to a subset of characters, or the\n this instance if there was an error.","type_short":"StringDataInstance"}},{"javadoc":"Maps a {@link StringDataInstance} (this type) to the String DataType that best\n can handle this type of data.\n <p>\n I dare myself to type Type one more time.\n <p>\n@return {@link DataType}, defaulting to {@link StringDataType} if no direct match found.","static":false,"name":"getStringDataTypeGuess","comment":"Maps a StringDataInstance (this type) to the String DataType that best\n can handle this type of data.\n \n I dare myself to type Type one more time.\n ","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"DataType, defaulting to StringDataType if no direct match found.","type_short":"DataType"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}}],"name":"StringDataInstance","comment":"Represents an instance of a string in a MemBuffer.\n \n This class handles all the details of detecting a terminated string's length,\n converting the bytes in the membuffer into a java native String, and converting\n the raw String into a formatted human-readable version, according to the\n various SettingsDefinitions attached to the string data location.\n ","fields":[{"type_long":"ghidra.program.model.data.StringDataInstance","javadoc":"A {@link StringDataInstance} that represents a non-existent string.\n <p>\n Methods on this instance generally return null.","static":true,"name":"NULL_INSTANCE","comment":"A StringDataInstance that represents a non-existent string.\n \n Methods on this instance generally return null.","type_short":"StringDataInstance","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"MAX_STRING_LENGTH","comment":"","type_short":"int","constant_value":"16384"},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"DEFAULT_CHARSET_NAME","comment":"","type_short":"String","constant_value":"\"US-ASCII\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"UNKNOWN","comment":"","type_short":"String","constant_value":"\"??\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"UNKNOWN_DOT_DOT_DOT","comment":"","type_short":"String","constant_value":"\"??...\""},{"type_long":"java.lang.String","javadoc":"A string with a single char that is the Byte-Order-Mark character.","static":true,"name":"BOM_RESULT_STR","comment":"A string with a single char that is the Byte-Order-Mark character.","type_short":"String","constant_value":"\"﻿\""},{"type_long":"int","javadoc":"","static":true,"name":"SIZEOF_PASCAL255_STR_LEN_FIELD","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"SIZEOF_PASCAL64k_STR_LEN_FIELD","comment":"","type_short":"int","constant_value":"2"},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"charsetName","comment":"","type_short":"String","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"charSize","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"paddedCharSize","comment":"","type_short":"int","constant_value":null},{"type_long":"ghidra.program.model.data.StringLayoutEnum","javadoc":"","static":false,"name":"stringLayout","comment":"","type_short":"StringLayoutEnum","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"translatedValue","comment":"","type_short":"String","constant_value":null},{"type_long":"ghidra.program.model.lang.Endian","javadoc":"","static":false,"name":"endianSetting","comment":"","type_short":"Endian","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"showTranslation","comment":"","type_short":"boolean","constant_value":null},{"type_long":"ghidra.program.model.data.RenderUnicodeSettingsDefinition.RENDER_ENUM","javadoc":"","static":false,"name":"renderSetting","comment":"","type_short":"RENDER_ENUM","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"length","comment":"","type_short":"int","constant_value":null},{"type_long":"ghidra.program.model.mem.MemBuffer","javadoc":"","static":false,"name":"buf","comment":"","type_short":"MemBuffer","constant_value":null},{"type_long":"java.util.Map<generic.stl.Pair<ghidra.program.model.data.StringLayoutEnum,java.lang.String>,ghidra.program.model.data.DataType>","javadoc":"Maps a {@link StringDataInstance}'s layout and charset info into the best String\n DataType that can handle this type of data instance.\n <p>\n An entry with a null charset name is equivalent to any charset.","static":true,"name":"dataTypeMap","comment":"Maps a StringDataInstance's layout and charset info into the best String\n DataType that can handle this type of data instance.\n \n An entry with a null charset name is equivalent to any charset.","type_short":"Map","constant_value":null}]}
