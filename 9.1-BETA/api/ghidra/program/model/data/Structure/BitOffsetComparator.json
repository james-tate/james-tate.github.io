{"implements":["java.util.Comparator"],"javadoc":"<code>BitOffsetComparator<\/code> provides ability to compare an normalized bit offset\n (see {@link #getNormalizedBitfieldOffset(int, int, int, int, boolean)} with a\n {@link DataTypeComponent} object.  The offset will be considered equal (0) if the component \n contains the offset.  A normalized component bit numbering is used to establish the footprint\n of each component with an ordinal-based ordering (assumes specific LE\/BE allocation rules).  \n Bit offsets for this comparator number the first allocated bit of the structure as 0 and the\n last allocated bit of the structure as (8 * structLength) - 1.  For big-endian bitfields\n the msb of the bitfield will be assigned the lower bit-number (assumes msb-allocated-first), \n while little-endian will perform similar numbering assuming byte-swap and bit-reversal of the \n storage unit (assumes lsb-allocated-first).  Both cases result in a normalized view where \n normalized bit-0 is allocated first.\n \n Example:\n    \n Big-Endian (normalized view):\n    | . . . . . . . 7 | 8 9 . . . . . . |\n    |<--------------------------------->| storage-size (2-bytes)\n                        |<--------------| bit-offset (6, lsb position within storage unit)\n                    |<--->|               bit-size (3)\n                        \n Little-Endian (normalized view, w\/ storage byte-swap and bit-reversal):\n    | . . . . . . 6 7 | 8 . . . . . . . |\n    |------------>|                       bit-offset (6, lsb position within storage unit)\n                  |<--->|                 bit-size (3)","static":true,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"boolean","name":"bigEndian","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"compare","comment":"","params":[{"type_long":"java.lang.Object","name":"o1","comment":"","type_short":"Object"},{"type_long":"java.lang.Object","name":"o2","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Compute the normalized bit offset of a bitfield relative to the start of a structure.\n \n NOTE: This implementation currently relies only on endianess to dictate bit allocation\n ordering.  If future support is added for alternate bitfield packing, this implementation will\n require modification.\n@param byteOffset byte offset within structure of storage unit\n@param storageSize storage unit size (i.e., component length)\n@param effectiveBitSize size of bitfield in bits\n@param bitOffset left shift amount for bitfield based upon a big-endian view of the\n storage unit\n@param bigEndian true if big-endian packing applies\n@return normalized bit-offset","static":true,"name":"getNormalizedBitfieldOffset","comment":"Compute the normalized bit offset of a bitfield relative to the start of a structure.\n \n NOTE: This implementation currently relies only on endianess to dictate bit allocation\n ordering.  If future support is added for alternate bitfield packing, this implementation will\n require modification.","params":[{"type_long":"int","name":"byteOffset","comment":"byte offset within structure of storage unit","type_short":"int"},{"type_long":"int","name":"storageSize","comment":"storage unit size (i.e., component length)","type_short":"int"},{"type_long":"int","name":"effectiveBitSize","comment":"size of bitfield in bits","type_short":"int"},{"type_long":"int","name":"bitOffset","comment":"left shift amount for bitfield based upon a big-endian view of the\n storage unit","type_short":"int"},{"type_long":"boolean","name":"bigEndian","comment":"true if big-endian packing applies","type_short":"boolean"}],"throws":[],"return":{"type_long":"int","comment":"normalized bit-offset","type_short":"int"}}],"name":"BitOffsetComparator","comment":"BitOffsetComparator provides ability to compare an normalized bit offset\n (see #getNormalizedBitfieldOffset(int, int, int, int, boolean) with a\n DataTypeComponent object.  The offset will be considered equal (0) if the component \n contains the offset.  A normalized component bit numbering is used to establish the footprint\n of each component with an ordinal-based ordering (assumes specific LE\/BE allocation rules).  \n Bit offsets for this comparator number the first allocated bit of the structure as 0 and the\n last allocated bit of the structure as (8 * structLength) - 1.  For big-endian bitfields\n the msb of the bitfield will be assigned the lower bit-number (assumes msb-allocated-first), \n while little-endian will perform similar numbering assuming byte-swap and bit-reversal of the \n storage unit (assumes lsb-allocated-first).  Both cases result in a normalized view where \n normalized bit-0 is allocated first.\n \n Example:\n    \n Big-Endian (normalized view):\n    | . . . . . . . 7 | 8 9 . . . . . . |\n    |---------------------------------| storage-size (2-bytes)\n                        |--------------| bit-offset (6, lsb position within storage unit)\n                    |---|               bit-size (3)\n                        \n Little-Endian (normalized view, w\/ storage byte-swap and bit-reversal):\n    | . . . . . . 6 7 | 8 . . . . . . . |\n    |------------|                       bit-offset (6, lsb position within storage unit)\n                  |---|                 bit-size (3)","fields":[{"type_long":"boolean","javadoc":"","static":false,"name":"bigEndian","comment":"","type_short":"boolean","constant_value":null}]}
