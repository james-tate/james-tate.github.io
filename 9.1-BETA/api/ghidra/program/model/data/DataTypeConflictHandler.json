{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Due to the locking concerns which can arise with a DataTypeConflictHandler,\n definition of new implementations must be done here.","static":false,"name":"<init>","comment":"Due to the locking concerns which can arise with a DataTypeConflictHandler,\n definition of new implementations must be done here.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Callback to handle conflicts in a datatype manager when new datatypes are added that\n have the same name as an existing datatype. The implementer of this interface should do\n one of the following:\n \t\treturn the addedDataType - which means to replace the existingDataType with the addedDataType\n \t\t\t\t\t\t\t(may throw exception if the datatypes are not compatible)\n \t\treturn the existingDataType the addedDataType will be ignored and the existing dataType will\n \t\t\t\t\t\t\tbe used.\n \t\treturn a new DataType with a new name\/category\n@param addedDataType the datatype being added.\n@param existingDataType the datatype that exists with the same name\/category as the one added\n@return an enum specify how to handle the conflict","static":false,"name":"resolveConflict","comment":"Callback to handle conflicts in a datatype manager when new datatypes are added that\n have the same name as an existing datatype. The implementer of this interface should do\n one of the following:\n \t\treturn the addedDataType - which means to replace the existingDataType with the addedDataType\n \t\t\t\t\t\t\t(may throw exception if the datatypes are not compatible)\n \t\treturn the existingDataType the addedDataType will be ignored and the existing dataType will\n \t\t\t\t\t\t\tbe used.\n \t\treturn a new DataType with a new name\/category","params":[{"type_long":"ghidra.program.model.data.DataType","name":"addedDataType","comment":"the datatype being added.","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"existingDataType","comment":"the datatype that exists with the same name\/category as the one added","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeConflictHandler.ConflictResult","comment":"an enum specify how to handle the conflict","type_short":"ConflictResult"}},{"javadoc":"Callback invoked when an associated dataType is being resolved and its local version of the\n dataType is different from the source archive's dataType.  This method returns true if the\n local version should be updated to the archive's version of the dataType.  Otherwise, the\n local dataType will be used (without updating) in the resolve operation.\n@param sourceDataType\n@param localDataType\n@return true if the localDataType should be updated to be equivalent to the sourceDataType.","static":false,"name":"shouldUpdate","comment":"Callback invoked when an associated dataType is being resolved and its local version of the\n dataType is different from the source archive's dataType.  This method returns true if the\n local version should be updated to the archive's version of the dataType.  Otherwise, the\n local dataType will be used (without updating) in the resolve operation.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"sourceDataType","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"localDataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the localDataType should be updated to be equivalent to the sourceDataType.","type_short":"boolean"}},{"javadoc":"Returns the appropriate handler for recursive resolve calls.","static":false,"name":"getSubsequentHandler","comment":"Returns the appropriate handler for recursive resolve calls.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","comment":"","type_short":"DataTypeConflictHandler"}}],"name":"DataTypeConflictHandler","comment":"","fields":[{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"","static":true,"name":"DEFAULT_HANDLER","comment":"","type_short":"DataTypeConflictHandler","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"","static":true,"name":"DEFAULT_SUBSEQUENT_HANDLER","comment":"","type_short":"DataTypeConflictHandler","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"","static":true,"name":"REPLACE_HANDLER","comment":"","type_short":"DataTypeConflictHandler","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"","static":true,"name":"SUBSEQUENT_REPLACE_HANDLER","comment":"","type_short":"DataTypeConflictHandler","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"","static":true,"name":"KEEP_HANDLER","comment":"","type_short":"DataTypeConflictHandler","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"This {@link DataTypeConflictHandler conflict handler} attempts to match conflicting\n {@link Composite composite data types} (structure or union) when they have compatible\n data layouts.  (Data types that are exactly equiv will not be subjected to conflict\n handling and will never reach here)\n <p>\n A default\/empty sized structure, or structures with the same size are candidates\n for matching.\n <p>\n Structures that have a subset of the other's field definition are candidates for matching.\n <p>\n When a candidate data type is matched with an existing data type, this conflict handler\n will specify that the new data type is:<p>\n <ul>\n <li>discarded and replaced by the existing data type ({@link ConflictResult#USE_EXISTING})\n <li>used to overwrite the existing data type ({@link ConflictResult#REPLACE_EXISTING})\n <\/ul>\n or the candidate data type was <b>NOT<\/b> matched with an existing data type, and the new data type is:<p>\n <ul>\n <li>kept, but renamed with a .conflictNNNN suffix to make it unique ({@link ConflictResult#RENAME_AND_ADD})\n <\/ul>\n <b>NOTE:<\/b> structures with alignment (instead of being statically laid out) are not\n treated specially and will not match other aligned or non-aligned structures.","static":true,"name":"REPLACE_EMPTY_STRUCTS_OR_RENAME_AND_ADD_HANDLER","comment":"This DataTypeConflictHandler attempts to match conflicting\n Composite (structure or union) when they have compatible\n data layouts.  (Data types that are exactly equiv will not be subjected to conflict\n handling and will never reach here)\n \n A default\/empty sized structure, or structures with the same size are candidates\n for matching.\n \n Structures that have a subset of the other's field definition are candidates for matching.\n \n When a candidate data type is matched with an existing data type, this conflict handler\n will specify that the new data type is:\n \n discarded and replaced by the existing data type (ConflictResult#USE_EXISTING)\n used to overwrite the existing data type (ConflictResult#REPLACE_EXISTING)\n \n or the candidate data type was NOT matched with an existing data type, and the new data type is:\n \n kept, but renamed with a .conflictNNNN suffix to make it unique (ConflictResult#RENAME_AND_ADD)\n \n NOTE: structures with alignment (instead of being statically laid out) are not\n treated specially and will not match other aligned or non-aligned structures.","type_short":"DataTypeConflictHandler","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeConflictHandler","javadoc":"","static":true,"name":"BUILT_IN_MANAGER_HANDLER","comment":"","type_short":"DataTypeConflictHandler","constant_value":null}]}
