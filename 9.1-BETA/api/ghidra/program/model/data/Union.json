{"implements":["ghidra.program.model.data.Composite"],"javadoc":"The union interface.\n <p>\n NOTE: The use of bitfields within all unions assumes a default packing where bit allocation \n always starts with byte-0 of the union.  Bit allocation order is dictated by data organization\n endianess (byte-0 msb allocated first for big-endian, while byte-0 lsb allocated first for little-endian).","static":false,"methods":[{"javadoc":"Inserts a new bitfield at the specified ordinal position in this union.\n For both aligned and unaligned unions the bitfield starts with bit-0 (lsb) of the first byte \n for little-endian, and with bit-7 (msb) of the first byte for big-endian.  This is the \n default behavior for most compilers.  Insertion behavior may not work as expected if \n packing rules differ from this.\n@param ordinal the ordinal where the new datatype is to be inserted.\n@param baseDataType the bitfield base datatype (certain restrictions apply).\n@param bitSize the declared bitfield size in bits.  The effective bit size may be\n adjusted based upon the specified baseDataType.\n@param componentName the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the bitfield component created whose associated data type will\n be BitFieldDataType.\n@throws InvalidDataTypeException if the specified baseDataType is\n not a valid base type for bitfields.\n@throws ArrayIndexOutOfBoundsException if ordinal is less than 0 or greater than the \n current number of components.","static":false,"name":"insertBitField","comment":"Inserts a new bitfield at the specified ordinal position in this union.\n For both aligned and unaligned unions the bitfield starts with bit-0 (lsb) of the first byte \n for little-endian, and with bit-7 (msb) of the first byte for big-endian.  This is the \n default behavior for most compilers.  Insertion behavior may not work as expected if \n packing rules differ from this.","params":[{"type_long":"int","name":"ordinal","comment":"the ordinal where the new datatype is to be inserted.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"baseDataType","comment":"the bitfield base datatype (certain restrictions apply).","type_short":"DataType"},{"type_long":"int","name":"bitSize","comment":"the declared bitfield size in bits.  The effective bit size may be\n adjusted based upon the specified baseDataType.","type_short":"int"},{"type_long":"java.lang.String","name":"componentName","comment":"the field name to associate with this component.","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the comment to associate with this component.","type_short":"String"}],"throws":[{"type_long":"ghidra.program.model.data.InvalidDataTypeException","comment":"if the specified baseDataType is\n not a valid base type for bitfields.","type_short":"InvalidDataTypeException"},{"type_long":"java.lang.ArrayIndexOutOfBoundsException","comment":"if ordinal is less than 0 or greater than the \n current number of components.","type_short":"ArrayIndexOutOfBoundsException"}],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the bitfield component created whose associated data type will\n be BitFieldDataType.","type_short":"DataTypeComponent"}}],"name":"Union","comment":"The union interface.\n \n NOTE: The use of bitfields within all unions assumes a default packing where bit allocation \n always starts with byte-0 of the union.  Bit allocation order is dictated by data organization\n endianess (byte-0 msb allocated first for big-endian, while byte-0 lsb allocated first for little-endian).","fields":[]}
