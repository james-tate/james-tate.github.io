{"implements":["ghidra.program.model.address.AddressSetView"],"javadoc":"CodeBlock represents some group of Instructions\/Data.  Each block\n has some set of source blocks that flow into it and some\n set of destination blocks that flow out of it.  A BlockModel\n is used to produce CodeBlocks.  Each model produces blocks\n based on its interpretation of Instruction\/Data grouping and flow\n between those groups.","static":false,"methods":[{"javadoc":"Return the first start address of the CodeBlock.\n Depending on the model used to generate the CodeBlock,\n there may be multiple entry points to the block.  This will\n return the first start address for the block.  It should\n always return the same address for a given block if there\n is more than one entry point.\n@return the first start address of the block.","static":false,"name":"getFirstStartAddress","comment":"Return the first start address of the CodeBlock.\n Depending on the model used to generate the CodeBlock,\n there may be multiple entry points to the block.  This will\n return the first start address for the block.  It should\n always return the same address for a given block if there\n is more than one entry point.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the first start address of the block.","type_short":"Address"}},{"javadoc":"Get all the entry points to this block.  Depending on the\n model, there may be more than one entry point.\n Entry points will be returned in natural sorted order.\n@return an array of entry points to this block.\n a zero length array if there are no entry points.","static":false,"name":"getStartAddresses","comment":"Get all the entry points to this block.  Depending on the\n model, there may be more than one entry point.\n Entry points will be returned in natural sorted order.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address[]","comment":"an array of entry points to this block.\n a zero length array if there are no entry points.","type_short":"ghidra.program.model.address.Address[]"}},{"javadoc":"Return the name of the block.\n@return name of block,\n  normally the symbol at the starting address","static":false,"name":"getName","comment":"Return the name of the block.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"name of block,\n  normally the symbol at the starting address","type_short":"String"}},{"javadoc":"Return, in theory, how things flow out of this node.\n If there are any abnormal ways to flow out of this node,\n (ie: jump, call, etc...) then the flow type of the node\n takes on that type.\n If there are multiple unique ways out of the node, then we\n should return FlowType.UNKNOWN.\n Fallthrough is returned if that is the only way out.\n@return flow type of this node","static":false,"name":"getFlowType","comment":"Return, in theory, how things flow out of this node.\n If there are any abnormal ways to flow out of this node,\n (ie: jump, call, etc...) then the flow type of the node\n takes on that type.\n If there are multiple unique ways out of the node, then we\n should return FlowType.UNKNOWN.\n Fallthrough is returned if that is the only way out.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.FlowType","comment":"flow type of this node","type_short":"FlowType"}},{"javadoc":"Get the number of CodeBlocks that flow into this CodeBlock.\n Note that this is almost as much work as getting the actual source references.\n@param monitor task monitor which allows user to cancel operation.\n@return number of source CodeBlocks.\n@throws CancelledException if the monitor cancels the operation.\n@see #getSources(ghidra.util.task.TaskMonitor)","static":false,"name":"getNumSources","comment":"Get the number of CodeBlocks that flow into this CodeBlock.\n Note that this is almost as much work as getting the actual source references.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"number of source CodeBlocks.","type_short":"int"}},{"javadoc":"Get an Iterator over the CodeBlocks that flow into this CodeBlock.\n@param monitor task monitor which allows user to cancel operation.\n@return An iterator over CodeBlocks referencing this Block.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getSources","comment":"Get an Iterator over the CodeBlocks that flow into this CodeBlock.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockReferenceIterator","comment":"An iterator over CodeBlocks referencing this Block.","type_short":"CodeBlockReferenceIterator"}},{"javadoc":"Get the number of CodeBlocks this block flows to.\n Note that this is almost as much work as getting the actual destination references.\n@param monitor task monitor which allows user to cancel operation.\n@return number of destination CodeBlocks.\n@throws CancelledException if the monitor cancels the operation.\n@see #getDestinations(ghidra.util.task.TaskMonitor)","static":false,"name":"getNumDestinations","comment":"Get the number of CodeBlocks this block flows to.\n Note that this is almost as much work as getting the actual destination references.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"number of destination CodeBlocks.","type_short":"int"}},{"javadoc":"Get an Iterator over the CodeBlocks that are flowed to from this\n CodeBlock.\n@param monitor task monitor which allows user to cancel operation.\n@return An iterator over CodeBlocks refered to by this Block.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getDestinations","comment":"Get an Iterator over the CodeBlocks that are flowed to from this\n CodeBlock.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockReferenceIterator","comment":"An iterator over CodeBlocks refered to by this Block.","type_short":"CodeBlockReferenceIterator"}},{"javadoc":"Get the model instance which was used to generate this block.\n@return the model used to build this CodeBlock","static":false,"name":"getModel","comment":"Get the model instance which was used to generate this block.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.block.CodeBlockModel","comment":"the model used to build this CodeBlock","type_short":"CodeBlockModel"}}],"name":"CodeBlock","comment":"CodeBlock represents some group of Instructions\/Data.  Each block\n has some set of source blocks that flow into it and some\n set of destination blocks that flow out of it.  A BlockModel\n is used to produce CodeBlocks.  Each model produces blocks\n based on its interpretation of Instruction\/Data grouping and flow\n between those groups.","fields":[]}
