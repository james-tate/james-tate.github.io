{"implements":[],"javadoc":"Adapter to access records in the symbol table.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets a new SymbolDatabaseAdapter\n@param dbHandle the database handle.\n@param openMode the openmode\n@param addrMap the address map\n@param monitor the progress monitor.\n@throws VersionException if the database table does not match the adapter.\n@throws CancelledException if the user cancels an upgrade.\n@throws IOException if a database io error occurs.","static":true,"name":"getAdapter","comment":"Gets a new SymbolDatabaseAdapter","params":[{"type_long":"db.DBHandle","name":"dbHandle","comment":"the database handle.","type_short":"DBHandle"},{"type_long":"int","name":"openMode","comment":"the openmode","type_short":"int"},{"type_long":"ghidra.program.database.map.AddressMap","name":"addrMap","comment":"the address map","type_short":"AddressMap"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the progress monitor.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.VersionException","comment":"if the database table does not match the adapter.","type_short":"VersionException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels an upgrade.","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if a database io error occurs.","type_short":"IOException"}],"return":{"type_long":"ghidra.program.database.symbol.SymbolDatabaseAdapter","comment":"","type_short":"SymbolDatabaseAdapter"}},{"javadoc":"","static":true,"name":"findReadOnlyAdapter","comment":"","params":[{"type_long":"db.DBHandle","name":"handle","comment":"","type_short":"DBHandle"},{"type_long":"ghidra.program.database.map.AddressMap","name":"addrMap","comment":"","type_short":"AddressMap"}],"throws":[{"type_long":"ghidra.util.exception.VersionException","comment":"","type_short":"VersionException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.program.database.symbol.SymbolDatabaseAdapter","comment":"","type_short":"SymbolDatabaseAdapter"}},{"javadoc":"Create a new symbol\n@param name name of the symbol\n@param addr address of the symbol\n@param parentSymbolID the id of the containing namespace symbol\n@param symbolType the type of this symbol\n@param data1 place to store a long value that depends on the symbol type\n@param data2 place to store an int value that depends on the symbol type\n@param data3 place to store a String value that depends on the symbol type\n@param source the source of this symbol\n <br>Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT.\n@return the new record\n@throws IOException if there was a problem accessing the database\n@throws IllegalArgumentException if you try to set the source to DEFAULT for a symbol type\n that doesn't allow it.","static":false,"name":"createSymbol","comment":"Create a new symbol","params":[{"type_long":"java.lang.String","name":"name","comment":"name of the symbol","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"long","name":"parentSymbolID","comment":"the id of the containing namespace symbol","type_short":"long"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"symbolType","comment":"the type of this symbol","type_short":"SymbolType"},{"type_long":"long","name":"data1","comment":"place to store a long value that depends on the symbol type","type_short":"long"},{"type_long":"int","name":"data2","comment":"place to store an int value that depends on the symbol type","type_short":"int"},{"type_long":"java.lang.String","name":"data3","comment":"place to store a String value that depends on the symbol type","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT.","type_short":"SourceType"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"the new record","type_short":"Record"}},{"javadoc":"Get the record with the given symbol ID\n@param symbolID key for the database record\n@return record with the given symbolID\n@throws IOException if there was a problem accessing the database","static":false,"name":"getSymbolRecord","comment":"Get the record with the given symbol ID","params":[{"type_long":"long","name":"symbolID","comment":"key for the database record","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"record with the given symbolID","type_short":"Record"}},{"javadoc":"Remove the record for the given symbol ID\n@param symbolID key for the database record\n@throws IOException if there was a problem accessing the database","static":false,"name":"removeSymbol","comment":"Remove the record for the given symbol ID","params":[{"type_long":"long","name":"symbolID","comment":"key for the database record","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Check if the address has a symbol defined at it\n@param addr address to filter on\n@return true if there exists a record with the given address\n@throws IOException if there was a problem accessing the database","static":false,"name":"hasSymbol","comment":"Check if the address has a symbol defined at it","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to filter on","type_short":"Address"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if there exists a record with the given address","type_short":"boolean"}},{"javadoc":"Get the symbolIDs at the given address.\n@param addr address to filter on\n@return array of database keys\n@throws IOException if there was a problem accessing the database","static":false,"name":"getSymbolIDs","comment":"Get the symbolIDs at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to filter on","type_short":"Address"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"long[]","comment":"array of database keys","type_short":"long[]"}},{"javadoc":"Get the number of symbols.","static":false,"name":"getSymbolCount","comment":"Get the number of symbols.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get an iterator over all the symbols in ascending address order.\n@return \n@throws IOException if there was a problem accessing the database","static":false,"name":"getSymbolsByAddress","comment":"Get an iterator over all the symbols in ascending address order.","params":[{"type_long":"boolean","name":"forward","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"db.RecordIterator","comment":"","type_short":"RecordIterator"}},{"javadoc":"Get an iterator over all the symbols starting at startAddr.\n@param startAddr start address of where to get symbols\n@throws IOException if there was a problem accessing the database","static":false,"name":"getSymbolsByAddress","comment":"Get an iterator over all the symbols starting at startAddr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"start address of where to get symbols","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"db.RecordIterator","comment":"","type_short":"RecordIterator"}},{"javadoc":"Update the table with the given record.\n@param record\n@throws IOException if there was a problem accessing the database","static":false,"name":"updateSymbolRecord","comment":"Update the table with the given record.","params":[{"type_long":"db.Record","name":"record","comment":"","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get all of the symbols.\n@throws IOException if there was a problem accessing the database","static":false,"name":"getSymbols","comment":"Get all of the symbols.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"db.RecordIterator","comment":"","type_short":"RecordIterator"}},{"javadoc":"Get symbols in the given range.\n@throws IOException if there was a problem accessing the database","static":false,"name":"getSymbols","comment":"Get symbols in the given range.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem accessing the database","type_short":"IOException"}],"return":{"type_long":"db.RecordIterator","comment":"","type_short":"RecordIterator"}},{"javadoc":"Update the address in all records to reflect the movement of a symbol address.\n@param oldAddr the original symbol address\n@param newAddr the new symbol address\n@throws IOException","static":false,"name":"moveAddress","comment":"Update the address in all records to reflect the movement of a symbol address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"oldAddr","comment":"the original symbol address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"newAddr","comment":"the new symbol address","type_short":"Address"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Update the addresses in all records to reflect the movement of a memory block.\n@param fromAddr minimum address of the original block to be moved\n@param toAddr the new minimum address after the block move\n@param length the number of bytes in the memory block being moved\n@param monitor progress monitor\n@return returns the set of addresses where symbols where not moved because they were anchored\n@throws CancelledException\n@throws IOException","static":false,"name":"moveAddressRange","comment":"Update the addresses in all records to reflect the movement of a memory block.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"minimum address of the original block to be moved","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"the new minimum address after the block move","type_short":"Address"},{"type_long":"long","name":"length","comment":"the number of bytes in the memory block being moved","type_short":"long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"progress monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"returns the set of addresses where symbols where not moved because they were anchored","type_short":"void"}},{"javadoc":"Delete all records which contain addresses within the specified range\n@param startAddr minimum address in range\n@param endAddr maximum address in range\n@param monitor progress monitor\n@return returns the set of addresses where symbols where not deleted because they were anchored\n@throws CancelledException\n@throws IOException","static":false,"name":"deleteAddressRange","comment":"Delete all records which contain addresses within the specified range","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"minimum address in range","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"endAddr","comment":"maximum address in range","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"progress monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.Set<ghidra.program.model.address.Address>","comment":"returns the set of addresses where symbols where not deleted because they were anchored","type_short":"Set"}},{"javadoc":"Get all symbols contained within the specified namespace\n@param id the namespace id.\n@return an iterator over all symbols in the given namespace.\n@throws IOException","static":false,"name":"getSymbolsByNamespace","comment":"Get all symbols contained within the specified namespace","params":[{"type_long":"long","name":"id","comment":"the namespace id.","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.RecordIterator","comment":"an iterator over all symbols in the given namespace.","type_short":"RecordIterator"}},{"javadoc":"Get symbols starting with the specified name in name order\n@param name name to start with.\n@return a record iterator over the symbols.\n@throws IOException if a database io error occurs.","static":false,"name":"getSymbolsByName","comment":"Get symbols starting with the specified name in name order","params":[{"type_long":"java.lang.String","name":"name","comment":"name to start with.","type_short":"String"}],"throws":[{"type_long":"java.io.IOException","comment":"if a database io error occurs.","type_short":"IOException"}],"return":{"type_long":"db.RecordIterator","comment":"a record iterator over the symbols.","type_short":"RecordIterator"}},{"javadoc":"Returns the maximum symbol address within the specified address space.\n Intended for update use only.\n@param space address space\n@return maximum symbol address within space or null if none are found.","static":false,"name":"getMaxSymbolAddress","comment":"Returns the maximum symbol address within the specified address space.\n Intended for update use only.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"space","comment":"address space","type_short":"AddressSpace"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"maximum symbol address within space or null if none are found.","type_short":"Address"}},{"javadoc":"Returns the underlying symbol table (for upgrade use only).","static":false,"name":"getTable","comment":"Returns the underlying symbol table (for upgrade use only).","params":[],"throws":[],"return":{"type_long":"db.Table","comment":"","type_short":"Table"}}],"name":"SymbolDatabaseAdapter","comment":"Adapter to access records in the symbol table.","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"SYMBOL_TABLE_NAME","comment":"","type_short":"String","constant_value":"\"Symbols\""},{"type_long":"db.Schema","javadoc":"","static":true,"name":"SYMBOL_SCHEMA","comment":"","type_short":"Schema","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_NAME_COL","comment":"","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_ADDR_COL","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_PARENT_COL","comment":"","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_TYPE_COL","comment":"","type_short":"int","constant_value":"3"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_DATA1_COL","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_DATA2_COL","comment":"","type_short":"int","constant_value":"5"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_DATA3_COL","comment":"","type_short":"int","constant_value":"6"},{"type_long":"int","javadoc":"","static":true,"name":"SYMBOL_FLAGS_COL","comment":"","type_short":"int","constant_value":"7"},{"type_long":"byte","javadoc":"","static":true,"name":"SYMBOL_SOURCE_BITS","comment":"","type_short":"byte","constant_value":"3"},{"type_long":"byte","javadoc":"","static":true,"name":"SYMBOL_PINNED_FLAG","comment":"","type_short":"byte","constant_value":"4"}]}
