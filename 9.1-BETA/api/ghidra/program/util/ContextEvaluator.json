{"implements":[],"javadoc":"ContextEvaluator provides a callback mechanism for the SymbolicPropogator as code is evaluated.","static":false,"methods":[{"javadoc":"Evaluate the current instruction given the context before the instruction is evaluated\n@param context describes current state of registers\n@param instr instruction whose context has not yet been applied\n@return true if evaluation should stop","static":false,"name":"evaluateContextBefore","comment":"Evaluate the current instruction given the context before the instruction is evaluated","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"describes current state of registers","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"instruction whose context has not yet been applied","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"true if evaluation should stop","type_short":"boolean"}},{"javadoc":"Evaluate the current instruction given the final context for the instruction\n@param context describes current state of registers\n@param instr instruction whose context has been applied\n@return true if evaluation should stop, false to continue evaluation","static":false,"name":"evaluateContext","comment":"Evaluate the current instruction given the final context for the instruction","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"describes current state of registers","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"instruction whose context has been applied","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"true if evaluation should stop, false to continue evaluation","type_short":"boolean"}},{"javadoc":"Evaluate the reference that has been found on this instruction. Computed values that are used as an\n address will be passed to this function.  For example a value passed to a function, or a stored\n constant value.\n@param context current program context\n@param instr instruction on which this reference was detected\n@param pcodeop the PcodeOp operation that is causing this reference\n@param address address being referenced\n@param size size of the item being referenced (only non-zero if load or store of data)\n@param refType reference type (flow, data\/read\/write)\n@return false if the reference should be ignored (or has been taken care of by this routine)","static":false,"name":"evaluateReference","comment":"Evaluate the reference that has been found on this instruction. Computed values that are used as an\n address will be passed to this function.  For example a value passed to a function, or a stored\n constant value.","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"current program context","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"instruction on which this reference was detected","type_short":"Instruction"},{"type_long":"int","name":"pcodeop","comment":"the PcodeOp operation that is causing this reference","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"address being referenced","type_short":"Address"},{"type_long":"int","name":"size","comment":"size of the item being referenced (only non-zero if load or store of data)","type_short":"int"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"reference type (flow, data\/read\/write)","type_short":"RefType"}],"throws":[],"return":{"type_long":"boolean","comment":"false if the reference should be ignored (or has been taken care of by this routine)","type_short":"boolean"}},{"javadoc":"Evaluate a potential constant to be used as an address or an interesting constant that\n should have a reference created for it.  Computed values that are not know to be used as an address will\n be passed to this function.  For example a value passed to a function, or a stored constant value.\n@param context current program context\n@param instr instruction on which this reference was detected\n@param pcodeop the PcodeOp operation that is causing this potential constant\n@param constant constant value (in constant.getOffset() )\n@param size size of constant value in bytes\n@param refType reference type (flow, data\/read\/write)\n@return the original address unchanged if it should be a reference\n         null if the constant reference should not be created\n         a new address if the value should be a different address or address space\n             Using something like instr.getProgram().getAddressFactory().getDefaultAddressSpace();","static":false,"name":"evaluateConstant","comment":"Evaluate a potential constant to be used as an address or an interesting constant that\n should have a reference created for it.  Computed values that are not know to be used as an address will\n be passed to this function.  For example a value passed to a function, or a stored constant value.","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"current program context","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"instruction on which this reference was detected","type_short":"Instruction"},{"type_long":"int","name":"pcodeop","comment":"the PcodeOp operation that is causing this potential constant","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"constant","comment":"constant value (in constant.getOffset() )","type_short":"Address"},{"type_long":"int","name":"size","comment":"size of constant value in bytes","type_short":"int"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"reference type (flow, data\/read\/write)","type_short":"RefType"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the original address unchanged if it should be a reference\n         null if the constant reference should not be created\n         a new address if the value should be a different address or address space\n             Using something like instr.getProgram().getAddressFactory().getDefaultAddressSpace();","type_short":"Address"}},{"javadoc":"Evaluate the instruction for an unknown destination\n@param context current register context\n@param instruction instruction that has an unknown destination\n@return true if the evaluation should stop, false to continue evaluation","static":false,"name":"evaluateDestination","comment":"Evaluate the instruction for an unknown destination","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"current register context","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"instruction that has an unknown destination","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the evaluation should stop, false to continue evaluation","type_short":"boolean"}},{"javadoc":"Called when a value is needed for a register that is unknown\n@param context current register context\n@param instruction instruction that has an unknown destination\n@param node varnode for the register being accessed to obtain a value\n@return null if the varnode should not have an assumed value.\n         a long value if the varnode such as a Global Register should have an assumed constant","static":false,"name":"unknownValue","comment":"Called when a value is needed for a register that is unknown","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"current register context","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"instruction that has an unknown destination","type_short":"Instruction"},{"type_long":"ghidra.program.model.pcode.Varnode","name":"node","comment":"varnode for the register being accessed to obtain a value","type_short":"Varnode"}],"throws":[],"return":{"type_long":"java.lang.Long","comment":"null if the varnode should not have an assumed value.\n         a long value if the varnode such as a Global Register should have an assumed constant","type_short":"Long"}},{"javadoc":"Follow all branches, even if the condition evaluates to false, indicating it shouldn't be followed.\n@return true if false evaluated conditional branches should be followed.","static":false,"name":"followFalseConditionalBranches","comment":"Follow all branches, even if the condition evaluates to false, indicating it shouldn't be followed.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if false evaluated conditional branches should be followed.","type_short":"boolean"}},{"javadoc":"Evaluate the reference that has been found on this instruction that points into an unknown space that\n has been designated as tracked.\n@param context current program context\n@param instr instruction on which this reference was detected\n@param address address being referenced\n@return false if the reference should be ignored (or has been taken care of by this routine)\n         true to allow the reference to be created","static":false,"name":"evaluateSymbolicReference","comment":"Evaluate the reference that has been found on this instruction that points into an unknown space that\n has been designated as tracked.","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"current program context","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"instruction on which this reference was detected","type_short":"Instruction"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"address being referenced","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"false if the reference should be ignored (or has been taken care of by this routine)\n         true to allow the reference to be created","type_short":"boolean"}},{"javadoc":"Evaluate the address and check if the access to the value in the memory location to be read\n The address is read-only and is not close to this address.\n@param context current program context\n@param addr Address of memory where location is attempting to be read\n@return true if the access should be allowed","static":false,"name":"allowAccess","comment":"Evaluate the address and check if the access to the value in the memory location to be read\n The address is read-only and is not close to this address.","params":[{"type_long":"ghidra.program.util.VarnodeContext","name":"context","comment":"current program context","type_short":"VarnodeContext"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"Address of memory where location is attempting to be read","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the access should be allowed","type_short":"boolean"}}],"name":"ContextEvaluator","comment":"ContextEvaluator provides a callback mechanism for the SymbolicPropogator as code is evaluated.","fields":[]}
