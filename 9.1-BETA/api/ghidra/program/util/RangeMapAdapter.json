{"implements":[],"javadoc":"","static":false,"methods":[{"javadoc":"Returns the byte array that has been associated with the given index.\n@param address the address at which to retrieve a byte array.\n@return the byte array that has been associated with the given index or null if no such\n association exists.","static":false,"name":"getValue","comment":"Returns the byte array that has been associated with the given index.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address at which to retrieve a byte array.","type_short":"Address"}],"throws":[],"return":{"type_long":"byte[]","comment":"the byte array that has been associated with the given index or null if no such\n association exists.","type_short":"byte[]"}},{"javadoc":"Move all values within an address range to a new range.\n@param fromAddr the first address of the range to be moved.\n@param toAddr the address where to the range is to be moved.\n@param length the number of addresses to move.\n@param monitor the task monitor.\n@throws CancelledException if the user canceled the operation via the task monitor.\n@throws AddressOverflowException if the length is such that a address wrap occurs","static":false,"name":"moveAddressRange","comment":"Move all values within an address range to a new range.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"the first address of the range to be moved.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"the address where to the range is to be moved.","type_short":"Address"},{"type_long":"long","name":"length","comment":"the number of addresses to move.","type_short":"long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user canceled the operation via the task monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Associates the given byte array with all indexes in the given range.  Any existing values\n will be over written.\n@param start the first address in the range.\n@param end the last Address(inclusive) in the range.\n@param bytes the bytes to associate with the range.","static":false,"name":"set","comment":"Associates the given byte array with all indexes in the given range.  Any existing values\n will be over written.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the first address in the range.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the last Address(inclusive) in the range.","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"the bytes to associate with the range.","type_short":"byte[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns an {@link IndexRangeIterator} over all stored values in the given range.  If the\n given range intersects an actual stored range either at the beginning or end, the iterator\n will return those ranges truncated to fit within the given range.\n@param start the first Address in the range.\n@param end the last Address (inclusive) index in the range.\n@return an {@link IndexRangeIterator} over all stored values.","static":false,"name":"getAddressRangeIterator","comment":"Returns an IndexRangeIterator over all stored values in the given range.  If the\n given range intersects an actual stored range either at the beginning or end, the iterator\n will return those ranges truncated to fit within the given range.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the first Address in the range.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the last Address (inclusive) index in the range.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressRangeIterator","comment":"an IndexRangeIterator over all stored values.","type_short":"AddressRangeIterator"}},{"javadoc":"Returns an {@link IndexRangeIterator} over all stored values.\n@return an {@link IndexRangeIterator} over all stored values.","static":false,"name":"getAddressRangeIterator","comment":"Returns an IndexRangeIterator over all stored values.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressRangeIterator","comment":"an IndexRangeIterator over all stored values.","type_short":"AddressRangeIterator"}},{"javadoc":"Clears all associated values in the given range.\n@param start the first address in the range to clear.\n@param end the end address in the range to clear.","static":false,"name":"clearRange","comment":"Clears all associated values in the given range.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the first address in the range to clear.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end address in the range to clear.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears all values.","static":false,"name":"clearAll","comment":"Clears all values.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if this storage has no associated values for any address\n@return true if this storage has no associated values for any address","static":false,"name":"isEmpty","comment":"Returns true if this storage has no associated values for any address","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this storage has no associated values for any address","type_short":"boolean"}},{"javadoc":"Update table name and values to reflect new base register\n@param translator\n@param mapReg\n@param monitor\n@throws CancelledException","static":false,"name":"setLanguage","comment":"Update table name and values to reflect new base register","params":[{"type_long":"ghidra.program.util.LanguageTranslator","name":"translator","comment":"","type_short":"LanguageTranslator"},{"type_long":"ghidra.program.model.lang.Register","name":"mapReg","comment":"","type_short":"Register"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the bounding address-range containing addr and the the same value throughout.\n This range will be limited by any value change associated with the base register.\n@param register\n@param addr\n@return single value address-range containing addr","static":false,"name":"getValueRangeContaining","comment":"Returns the bounding address-range containing addr and the the same value throughout.\n This range will be limited by any value change associated with the base register.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressRange","comment":"single value address-range containing addr","type_short":"AddressRange"}},{"javadoc":"Verify that adapter is in a writable state (i.e., valid transaction has been started).\n@throws IllegalStateException if not in a writable state","static":false,"name":"checkWritableState","comment":"Verify that adapter is in a writable state (i.e., valid transaction has been started).","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"RangeMapAdapter","comment":"","fields":[]}
