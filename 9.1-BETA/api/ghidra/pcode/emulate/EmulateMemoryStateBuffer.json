{"implements":["ghidra.program.model.mem.MemBuffer"],"javadoc":"<code>MemoryStateBuffer<\/code> provides a MemBuffer for instruction parsing use\n which wraps an emulator MemoryState.  This implementation wraps all specified \n memory offsets within the associated address space.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.pcode.memstate.MemoryState","name":"memState","comment":"","type_short":"MemoryState"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setAddress","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getAddress","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"availableInSpace","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getWrappedAddress","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Determine if request is valid and compute wrapped memory offset relative to \n current buffer address.  A request is invalid if too close to the end of the \n memory space to read the requested number of bytes.\n@param offset relative offset\n@param size read request size\n@return absolute memory offset (wrapped)\n@throws MemoryAccessException","static":false,"name":"checkGetRequest","comment":"Determine if request is valid and compute wrapped memory offset relative to \n current buffer address.  A request is invalid if too close to the end of the \n memory space to read the requested number of bytes.","params":[{"type_long":"int","name":"offset","comment":"relative offset","type_short":"int"},{"type_long":"int","name":"size","comment":"read request size","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"long","comment":"absolute memory offset (wrapped)","type_short":"long"}},{"javadoc":"","static":false,"name":"getBigInteger","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"int","name":"size","comment":"","type_short":"int"},{"type_long":"boolean","name":"signed","comment":"","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"java.math.BigInteger","comment":"","type_short":"BigInteger"}},{"javadoc":"","static":false,"name":"getBytes","comment":"","params":[{"type_long":"byte[]","name":"b","comment":"","type_short":"byte[]"},{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getByte","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"byte","comment":"","type_short":"byte"}},{"javadoc":"","static":false,"name":"getShort","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"short","comment":"","type_short":"short"}},{"javadoc":"","static":false,"name":"getInt","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getLong","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getMemory","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.mem.Memory","comment":"","type_short":"Memory"}},{"javadoc":"","static":false,"name":"isBigEndian","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"EmulateMemoryStateBuffer","comment":"MemoryStateBuffer provides a MemBuffer for instruction parsing use\n which wraps an emulator MemoryState.  This implementation wraps all specified \n memory offsets within the associated address space.","fields":[{"type_long":"ghidra.pcode.memstate.MemoryState","javadoc":"","static":false,"name":"memState","comment":"","type_short":"MemoryState","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"address","comment":"","type_short":"Address","constant_value":null}]}
