{"implements":[],"javadoc":"All storage\/state for a pcode emulator machine\n\n Every piece of information in a pcode emulator machine is representable as a triple\n (AddressSpace,offset,size).  This class allows getting and setting\n of all state information of this form.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"MemoryState constructor for a specified processor language\n@param language","static":false,"name":"<init>","comment":"MemoryState constructor for a specified processor language","params":[{"type_long":"ghidra.program.model.lang.Language","name":"language","comment":"","type_short":"Language"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getVarnode","comment":"","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"","type_short":"Register"}],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.Varnode","comment":"","type_short":"Varnode"}},{"javadoc":"MemoryBanks associated with specific address spaces must be registers with this MemoryState\n via this method.  Each address space that will be used during emulation must be registered\n separately.  The MemoryState object does not assume responsibility for freeing the MemoryBank.\n@param bank is a pointer to the MemoryBank to be registered","static":false,"name":"setMemoryBank","comment":"MemoryBanks associated with specific address spaces must be registers with this MemoryState\n via this method.  Each address space that will be used during emulation must be registered\n separately.  The MemoryState object does not assume responsibility for freeing the MemoryBank.","params":[{"type_long":"ghidra.pcode.memstate.MemoryBank","name":"bank","comment":"is a pointer to the MemoryBank to be registered","type_short":"MemoryBank"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Any MemoryBank that has been registered with this MemoryState can be retrieved via this\n method if the MemoryBank's associated address space is known.\n@param spc is the address space of the desired MemoryBank\n@return the MemoryBank or null if no bank is associated with spc.","static":false,"name":"getMemoryBank","comment":"Any MemoryBank that has been registered with this MemoryState can be retrieved via this\n method if the MemoryBank's associated address space is known.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"is the address space of the desired MemoryBank","type_short":"AddressSpace"}],"throws":[],"return":{"type_long":"ghidra.pcode.memstate.MemoryBank","comment":"the MemoryBank or null if no bank is associated with spc.","type_short":"MemoryBank"}},{"javadoc":"A convenience method for setting a value directly on a varnode rather than\n breaking out the components\n@param vn the varnode location to be written\n@param cval the value to write into the varnode location","static":false,"name":"setValue","comment":"A convenience method for setting a value directly on a varnode rather than\n breaking out the components","params":[{"type_long":"ghidra.program.model.pcode.Varnode","name":"vn","comment":"the varnode location to be written","type_short":"Varnode"},{"type_long":"long","name":"cval","comment":"the value to write into the varnode location","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"A convenience method for setting a value directly on a register rather than\n breaking out the components\n@param reg the register location to be written\n@param cval the value to write into the register location","static":false,"name":"setValue","comment":"A convenience method for setting a value directly on a register rather than\n breaking out the components","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"the register location to be written","type_short":"Register"},{"type_long":"long","name":"cval","comment":"the value to write into the register location","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is a convenience method for setting registers by name.\n Any register name known to the language can be used as a write location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main setValue routine.\n@param nm is the name of the register\n@param cval is the value to write to the register","static":false,"name":"setValue","comment":"This is a convenience method for setting registers by name.\n Any register name known to the language can be used as a write location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main setValue routine.","params":[{"type_long":"java.lang.String","name":"nm","comment":"is the name of the register","type_short":"String"},{"type_long":"long","name":"cval","comment":"is the value to write to the register","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is the main interface for writing values to the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.\n@param spc is the address space to write to\n@param off is the offset where the value should be written\n@param size is the number of bytes to be written\n@param cval is the value to be written","static":false,"name":"setValue","comment":"This is the main interface for writing values to the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"is the address space to write to","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"is the offset where the value should be written","type_short":"long"},{"type_long":"int","name":"size","comment":"is the number of bytes to be written","type_short":"int"},{"type_long":"long","name":"cval","comment":"is the value to be written","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"A convenience method for reading a value directly from a varnode rather\n than querying for the offset and space\n@param vn the varnode location to be read\n@return the value read from the varnode location","static":false,"name":"getValue","comment":"A convenience method for reading a value directly from a varnode rather\n than querying for the offset and space","params":[{"type_long":"ghidra.program.model.pcode.Varnode","name":"vn","comment":"the varnode location to be read","type_short":"Varnode"}],"throws":[],"return":{"type_long":"long","comment":"the value read from the varnode location","type_short":"long"}},{"javadoc":"A convenience method for reading a value directly from a register rather\n than querying for the offset and space\n@param reg the register location to be read\n@return the value read from the register location","static":false,"name":"getValue","comment":"A convenience method for reading a value directly from a register rather\n than querying for the offset and space","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"the register location to be read","type_short":"Register"}],"throws":[],"return":{"type_long":"long","comment":"the value read from the register location","type_short":"long"}},{"javadoc":"This is a convenience method for reading registers by name.\n any register name known to the language can be used as a read location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main getValue routine.\n@param nm is the name of the register\n@return the value associated with that register","static":false,"name":"getValue","comment":"This is a convenience method for reading registers by name.\n any register name known to the language can be used as a read location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main getValue routine.","params":[{"type_long":"java.lang.String","name":"nm","comment":"is the name of the register","type_short":"String"}],"throws":[],"return":{"type_long":"long","comment":"the value associated with that register","type_short":"long"}},{"javadoc":"This is the main interface for reading values from the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.\n@param spc is the address space being queried\n@param off is the offset of the value being queried\n@param size is the number of bytes to query\n@return the queried value","static":false,"name":"getValue","comment":"This is the main interface for reading values from the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"is the address space being queried","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"is the offset of the value being queried","type_short":"long"},{"type_long":"int","name":"size","comment":"is the number of bytes to query","type_short":"int"}],"throws":[],"return":{"type_long":"long","comment":"the queried value","type_short":"long"}},{"javadoc":"A convenience method for setting a value directly on a varnode rather than\n breaking out the components\n@param vn the varnode location to be written\n@param cval the value to write into the varnode location","static":false,"name":"setValue","comment":"A convenience method for setting a value directly on a varnode rather than\n breaking out the components","params":[{"type_long":"ghidra.program.model.pcode.Varnode","name":"vn","comment":"the varnode location to be written","type_short":"Varnode"},{"type_long":"java.math.BigInteger","name":"cval","comment":"the value to write into the varnode location","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"A convenience method for setting a value directly on a register rather than\n breaking out the components\n@param reg the register location to be written\n@param cval the value to write into the register location","static":false,"name":"setValue","comment":"A convenience method for setting a value directly on a register rather than\n breaking out the components","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"the register location to be written","type_short":"Register"},{"type_long":"java.math.BigInteger","name":"cval","comment":"the value to write into the register location","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is a convenience method for setting registers by name.\n Any register name known to the language can be used as a write location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main setValue routine.\n@param nm is the name of the register\n@param cval is the value to write to the register","static":false,"name":"setValue","comment":"This is a convenience method for setting registers by name.\n Any register name known to the language can be used as a write location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main setValue routine.","params":[{"type_long":"java.lang.String","name":"nm","comment":"is the name of the register","type_short":"String"},{"type_long":"java.math.BigInteger","name":"cval","comment":"is the value to write to the register","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is the main interface for writing values to the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.\n@param spc is the address space to write to\n@param off is the offset where the value should be written\n@param size is the number of bytes to be written\n@param cval is the value to be written","static":false,"name":"setValue","comment":"This is the main interface for writing values to the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"is the address space to write to","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"is the offset where the value should be written","type_short":"long"},{"type_long":"int","name":"size","comment":"is the number of bytes to be written","type_short":"int"},{"type_long":"java.math.BigInteger","name":"cval","comment":"is the value to be written","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"A convenience method for reading a value directly from a varnode rather\n than querying for the offset and space\n@param vn the varnode location to be read\n@param signed true if signed value should be returned, false for unsigned value\n@return the unsigned value read from the varnode location","static":false,"name":"getBigInteger","comment":"A convenience method for reading a value directly from a varnode rather\n than querying for the offset and space","params":[{"type_long":"ghidra.program.model.pcode.Varnode","name":"vn","comment":"the varnode location to be read","type_short":"Varnode"},{"type_long":"boolean","name":"signed","comment":"true if signed value should be returned, false for unsigned value","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"the unsigned value read from the varnode location","type_short":"BigInteger"}},{"javadoc":"A convenience method for reading a value directly from a register rather\n than querying for the offset and space\n@param reg the register location to be read\n@return the unsigned value read from the register location","static":false,"name":"getBigInteger","comment":"A convenience method for reading a value directly from a register rather\n than querying for the offset and space","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"the register location to be read","type_short":"Register"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"the unsigned value read from the register location","type_short":"BigInteger"}},{"javadoc":"This is a convenience method for reading registers by name.\n any register name known to the language can be used as a read location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main getValue routine.\n@param nm is the name of the register\n@return the unsigned value associated with that register","static":false,"name":"getBigInteger","comment":"This is a convenience method for reading registers by name.\n any register name known to the language can be used as a read location.\n The associated address space, offset, and size is looked up and automatically\n passed to the main getValue routine.","params":[{"type_long":"java.lang.String","name":"nm","comment":"is the name of the register","type_short":"String"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"the unsigned value associated with that register","type_short":"BigInteger"}},{"javadoc":"This is the main interface for reading values from the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.\n@param spc is the address space being queried\n@param off is the offset of the value being queried\n@param size is the number of bytes to query\n@param signed true if signed value should be returned, false for unsigned value\n@return the queried unsigned value","static":false,"name":"getBigInteger","comment":"This is the main interface for reading values from the MemoryState.\n If there is no registered MemoryBank for the desired address space, or\n if there is some other error, an exception is thrown.","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"is the address space being queried","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"is the offset of the value being queried","type_short":"long"},{"type_long":"int","name":"size","comment":"is the number of bytes to query","type_short":"int"},{"type_long":"boolean","name":"signed","comment":"true if signed value should be returned, false for unsigned value","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"the queried unsigned value","type_short":"BigInteger"}},{"javadoc":"This is the main interface for reading a range of bytes from the MemorySate.\n The MemoryBank associated with the address space of the query is looked up\n and the request is forwarded to the getChunk method on the MemoryBank. If there\n is no registered MemoryBank or some other error, an exception is thrown.\n All getLongValue methods utilize this method to read the bytes from the\n appropriate memory bank.\n@param res the result buffer for storing retrieved bytes\n@param spc the desired address space\n@param off the starting offset of the byte range being read\n@param size the number of bytes being read\n@param stopOnUnintialized if true a partial read is permitted and returned size may be \n smaller than size requested\n@return number of bytes actually read\n@throws LowlevelError if spc has not been mapped within this MemoryState or memory fault\n handler generated error","static":false,"name":"getChunk","comment":"This is the main interface for reading a range of bytes from the MemorySate.\n The MemoryBank associated with the address space of the query is looked up\n and the request is forwarded to the getChunk method on the MemoryBank. If there\n is no registered MemoryBank or some other error, an exception is thrown.\n All getLongValue methods utilize this method to read the bytes from the\n appropriate memory bank.","params":[{"type_long":"byte[]","name":"res","comment":"the result buffer for storing retrieved bytes","type_short":"byte[]"},{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"the desired address space","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"the starting offset of the byte range being read","type_short":"long"},{"type_long":"int","name":"size","comment":"the number of bytes being read","type_short":"int"},{"type_long":"boolean","name":"stopOnUnintialized","comment":"if true a partial read is permitted and returned size may be \n smaller than size requested","type_short":"boolean"}],"throws":[],"return":{"type_long":"int","comment":"number of bytes actually read","type_short":"int"}},{"javadoc":"This is the main interface for setting values for a range of bytes in the MemoryState.\n The MemoryBank associated with the desired address space is looked up and the\n write is forwarded to the setChunk method on the MemoryBank. If there is no\n registered MemoryBank or some other error, an exception  is throw.\n All setValue methods utilize this method to read the bytes from the\n appropriate memory bank.\n@param val the byte values to be written into the MemoryState\n@param spc the address space being written\n@param off the starting offset of the range being written\n@param size the number of bytes to write\n@throws LowlevelError if spc has not been mapped within this MemoryState","static":false,"name":"setChunk","comment":"This is the main interface for setting values for a range of bytes in the MemoryState.\n The MemoryBank associated with the desired address space is looked up and the\n write is forwarded to the setChunk method on the MemoryBank. If there is no\n registered MemoryBank or some other error, an exception  is throw.\n All setValue methods utilize this method to read the bytes from the\n appropriate memory bank.","params":[{"type_long":"byte[]","name":"val","comment":"the byte values to be written into the MemoryState","type_short":"byte[]"},{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"the address space being written","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"the starting offset of the range being written","type_short":"long"},{"type_long":"int","name":"size","comment":"the number of bytes to write","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is the main interface for setting the initialization status for a range of bytes\n in the MemoryState.\n The MemoryBank associated with the desired address space is looked up and the\n write is forwarded to the setInitialized method on the MemoryBank. If there is no\n registered MemoryBank or some other error, an exception  is throw.\n All setValue methods utilize this method to read the bytes from the\n appropriate memory bank.\n@param initialized indicates if range should be marked as initialized or not\n@param spc the address space being written\n@param off the starting offset of the range being written\n@param size the number of bytes to write","static":false,"name":"setInitialized","comment":"This is the main interface for setting the initialization status for a range of bytes\n in the MemoryState.\n The MemoryBank associated with the desired address space is looked up and the\n write is forwarded to the setInitialized method on the MemoryBank. If there is no\n registered MemoryBank or some other error, an exception  is throw.\n All setValue methods utilize this method to read the bytes from the\n appropriate memory bank.","params":[{"type_long":"boolean","name":"initialized","comment":"indicates if range should be marked as initialized or not","type_short":"boolean"},{"type_long":"ghidra.program.model.address.AddressSpace","name":"spc","comment":"the address space being written","type_short":"AddressSpace"},{"type_long":"long","name":"off","comment":"the starting offset of the range being written","type_short":"long"},{"type_long":"int","name":"size","comment":"the number of bytes to write","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"MemoryState","comment":"All storage\/state for a pcode emulator machine\n\n Every piece of information in a pcode emulator machine is representable as a triple\n (AddressSpace,offset,size).  This class allows getting and setting\n of all state information of this form.","fields":[{"type_long":"ghidra.program.model.lang.Language","javadoc":"","static":false,"name":"language","comment":"","type_short":"Language","constant_value":null},{"type_long":"generic.stl.VectorSTL<ghidra.pcode.memstate.MemoryBank>","javadoc":"","static":false,"name":"memspace","comment":"","type_short":"VectorSTL","constant_value":null},{"type_long":"java.util.Map<ghidra.program.model.lang.Register,ghidra.program.model.pcode.Varnode>","javadoc":"","static":false,"name":"regVarnodeCache","comment":"","type_short":"Map","constant_value":null}]}
