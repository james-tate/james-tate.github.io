{"implements":[],"javadoc":"File caching implementation.\n <p>\n Caches files based on a hash of the contents of the file.<br>\n Files are retrieved using the hash string.<p>\n Cached files are stored in a file with a name that is the hex encoded value of the hash.\n Cached files are organized into a nested directory structure to prevent\n overwhelming a single directory with thousands of files.\n <p>\n Nested directory structure is based on the file's name:\n   File: AABBCCDDEEFF...\n   Directory (2 level nesting): AA\/BB\/AABBCCDDEEFF...\n <p>\n Cache size is not bounded.\n <p>\n Cache maint is done during startup if interval since last maint has been exceeded\n <p>\n No file data is maintained in memory.\n <p>\n No file is moved or removed from the cache after being added (except during startup)\n as there is no use count or reference tracking of the files.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Creates a new {@link FileCache} instance where files are stored under the specified\n {@code cacheDir}\n <p>\n@param cacheDir where to store the files\n@throws IOException if there was a problem creating subdirectories under cacheDir or\n when pruning expired files.","static":false,"name":"<init>","comment":"Creates a new FileCache instance where files are stored under the specified\n \n ","params":[{"type_long":"java.io.File","name":"cacheDir","comment":"where to store the files","type_short":"File"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was a problem creating subdirectories under cacheDir or\n when pruning expired files.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Deletes all stored files from this file cache that are under a \"NN\" two hex digit\n nesting dir.\n <p>\n Will cause other processes which are accessing or updating the cache to error.","static":false,"name":"purge","comment":"Deletes all stored files from this file cache that are under a \"NN\" two hex digit\n nesting dir.\n \n Will cause other processes which are accessing or updating the cache to error.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a {@link File} to the cache, returning a {@link FileCacheEntry}.\n@param f {@link File} to add to cache.\n@param monitor {@link TaskMonitor} to monitor for cancel and to update progress.\n@return {@link FileCacheEntry} with new File and md5.\n@throws IOException if error\n@throws CancelledException if canceled","static":false,"name":"addFile","comment":"Adds a File to the cache, returning a FileCacheEntry.","params":[{"type_long":"java.io.File","name":"f","comment":"File to add to cache.","type_short":"File"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to monitor for cancel and to update progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if canceled","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with new File and md5.","type_short":"FileCacheEntry"}},{"javadoc":"Returns a {@link FileCacheEntry} for the matching file, based on its MD5, or\n NULL if there is no matching file.\n <p>\n Tweaks the file's last modified time to implement a LRU.\n@param md5 md5 string.\n@return {@link FileCacheEntry} with a File and it's md5 string or {@code null} if no\n matching file exists in cache.","static":false,"name":"getFile","comment":"Returns a FileCacheEntry for the matching file, based on its MD5, or\n NULL if there is no matching file.\n \n Tweaks the file's last modified time to implement a LRU.","params":[{"type_long":"java.lang.String","name":"md5","comment":"md5 string.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with a File and it's md5 string or  if no\n matching file exists in cache.","type_short":"FileCacheEntry"}},{"javadoc":"Get a file (by md5) from the cache, returns NULL if not found.\n <p>\n@param md5 file md5 string.\n@return File or null if not found.","static":false,"name":"getFileByMD5","comment":"Get a file (by md5) from the cache, returns NULL if not found.\n ","params":[{"type_long":"java.lang.String","name":"md5","comment":"file md5 string.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"File or null if not found.","type_short":"FileCacheEntry"}},{"javadoc":"Prunes cache if interval since last maintenance exceeds {@link #MAINT_INTERVAL_MS}\n <p>\n Only called during construction, and the only known multi-process conflict that can occur\n is when re-writing the \"lastMaint\" timestamp file, which isn't a problem as its the\n approximate timestamp of that file that is important, not the contents.\n@throws IOException if error when writing metadata file.","static":false,"name":"performCacheMaintIfNeeded","comment":"Prunes cache if interval since last maintenance exceeds #MAINT_INTERVAL_MS\n \n Only called during construction, and the only known multi-process conflict that can occur\n is when re-writing the \"lastMaint\" timestamp file, which isn't a problem as its the\n approximate timestamp of that file that is important, not the contents.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if error when writing metadata file.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Prunes files in cache if they are old, calculates space used by cache.","static":false,"name":"performCacheMaint","comment":"Prunes files in cache if they are old, calculates space used by cache.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cacheMaintForDir","comment":"","params":[{"type_long":"java.io.File","name":"dir","comment":"","type_short":"File"},{"type_long":"int","name":"nestingLevel","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cacheMaintForLeafDir","comment":"","params":[{"type_long":"java.io.File","name":"dir","comment":"","type_short":"File"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isCacheFileName","comment":"","params":[{"type_long":"java.lang.String","name":"s","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Adds a contents of a stream to the cache, returning the md5 identifier of the stream.\n <p>\n The stream is copied into a temp file in the cacheDir\/new directory while its md5\n is calculated.  The temp file is then moved into its final location\n based on the md5 of the stream: AA\/BB\/CC\/AABBCCDDEEFF....\n <p>\n The monitor progress is updated with the number of bytes that are being copied.  No\n message or maximum is set.\n <p>\n@param is {@link InputStream} to add to the cache.  Not closed when done.\n@param monitor {@link TaskMonitor} that will be checked for canceling and updating progress.\n@return {@link FileCacheEntry} with file info and md5, never null.\n@throws IOException if error\n@throws CancelledException if canceled","static":false,"name":"addStream","comment":"Adds a contents of a stream to the cache, returning the md5 identifier of the stream.\n \n The stream is copied into a temp file in the cacheDir\/new directory while its md5\n is calculated.  The temp file is then moved into its final location\n based on the md5 of the stream: AA\/BB\/CC\/AABBCCDDEEFF....\n \n The monitor progress is updated with the number of bytes that are being copied.  No\n message or maximum is set.\n ","params":[{"type_long":"java.io.InputStream","name":"is","comment":"InputStream to add to the cache.  Not closed when done.","type_short":"InputStream"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor that will be checked for canceling and updating progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if canceled","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with file info and md5, never null.","type_short":"FileCacheEntry"}},{"javadoc":"Adds a file to the cache, using a 'pusher' strategy where the producer is given a\n {@link OutputStream} to write to.\n <p>\n Unbeknownst to the producer, but knownst to us, the outputstream is really a\n {@link HashingOutputStream} that will allow us to get the MD5 hash when the producer\n is finished pushing.\n@param pusher functional callback that will accept an {@link OutputStream} and write\n to it.\n <pre> (os) -> { os.write(.....); }<\/pre>\n@param monitor {@link TaskMonitor} that will be checked for cancel and updated with\n file io progress.\n@return a new {@link FileCacheEntry} with the newly added cache file's File and MD5,\n never null.\n@throws IOException if an IO error\n@throws CancelledException if the user cancels","static":false,"name":"pushStream","comment":"Adds a file to the cache, using a 'pusher' strategy where the producer is given a\n OutputStream to write to.\n \n Unbeknownst to the producer, but knownst to us, the outputstream is really a\n HashingOutputStream that will allow us to get the MD5 hash when the producer\n is finished pushing.","params":[{"type_long":"ghidra.formats.gfilesystem.DerivedFilePushProducer","name":"pusher","comment":"functional callback that will accept an OutputStream and write\n to it.\n  (os) - { os.write(.....); }","type_short":"DerivedFilePushProducer"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor that will be checked for cancel and updated with\n file io progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if an IO error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"a new FileCacheEntry with the newly added cache file's File and MD5,\n never null.","type_short":"FileCacheEntry"}},{"javadoc":"Adds a File to this cache, consuming the file.\n <p>\n This method makes some assumptions:\n <p>\n 1) Directories are never removed - when ensuring that a nested directory exists\n before placing a new file into that directory, there is no locking mechanism\n and if another process removed the directory between the check for the directory's\n existence and the attempt to place the file into the directory.  Solution: no\n process may remove a nested directory after it has been created.\n 2) The source file is co-located with the cache directory to ensure its on the\n same physical filesystem volume.\n <p>\n@param tmpFile the File to add to the cache\n@param md5 hex string md5 of the file\n@param fileLen the length in bytes of the file being added\n@return a new {@link FileCacheEntry} with the File's location and its md5\n@throws IOException if an file error occurs","static":false,"name":"addTmpFileToCache","comment":"Adds a File to this cache, consuming the file.\n \n This method makes some assumptions:\n \n 1) Directories are never removed - when ensuring that a nested directory exists\n before placing a new file into that directory, there is no locking mechanism\n and if another process removed the directory between the check for the directory's\n existence and the attempt to place the file into the directory.  Solution: no\n process may remove a nested directory after it has been created.\n 2) The source file is co-located with the cache directory to ensure its on the\n same physical filesystem volume.\n ","params":[{"type_long":"java.io.File","name":"tmpFile","comment":"the File to add to the cache","type_short":"File"},{"type_long":"java.lang.String","name":"md5","comment":"hex string md5 of the file","type_short":"String"},{"type_long":"long","name":"fileLen","comment":"the length in bytes of the file being added","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"if an file error occurs","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"a new FileCacheEntry with the File's location and its md5","type_short":"FileCacheEntry"}},{"javadoc":"","static":false,"name":"getCacheRelPath","comment":"","params":[{"type_long":"java.lang.String","name":"md5","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Number of files added to this cache.\n@return Number of files added to this cache","static":false,"name":"getFileAddCount","comment":"Number of files added to this cache.","params":[],"throws":[],"return":{"type_long":"int","comment":"Number of files added to this cache","type_short":"int"}},{"javadoc":"Number of times a file-add was a no-op and the contents were already present\n in the cache.\n@return Number of times a file-add was a no-op and the contents were already present\n in the cache.","static":false,"name":"getFileReUseCount","comment":"Number of times a file-add was a no-op and the contents were already present\n in the cache.","params":[],"throws":[],"return":{"type_long":"int","comment":"Number of times a file-add was a no-op and the contents were already present\n in the cache.","type_short":"int"}},{"javadoc":"Estimate of the number of bytes in the cache.\n@return estimate of the number of bytes in the cache - could be very wrong","static":false,"name":"getStorageEstimateBytes","comment":"Estimate of the number of bytes in the cache.","params":[],"throws":[],"return":{"type_long":"long","comment":"estimate of the number of bytes in the cache - could be very wrong","type_short":"long"}},{"javadoc":"How old (in milliseconds) files must be before being aged-off during cache maintenance.\n@return Max cache file age in milliseconds.","static":false,"name":"getMaxFileAgeMS","comment":"How old (in milliseconds) files must be before being aged-off during cache maintenance.","params":[],"throws":[],"return":{"type_long":"long","comment":"Max cache file age in milliseconds.","type_short":"long"}}],"name":"FileCache","comment":"File caching implementation.\n \n Caches files based on a hash of the contents of the file.\n Files are retrieved using the hash string.\n Cached files are stored in a file with a name that is the hex encoded value of the hash.\n Cached files are organized into a nested directory structure to prevent\n overwhelming a single directory with thousands of files.\n \n Nested directory structure is based on the file's name:\n   File: AABBCCDDEEFF...\n   Directory (2 level nesting): AA\/BB\/AABBCCDDEEFF...\n \n Cache size is not bounded.\n \n Cache maint is done during startup if interval since last maint has been exceeded\n \n No file data is maintained in memory.\n \n No file is moved or removed from the cache after being added (except during startup)\n as there is no use count or reference tracking of the files.","fields":[{"type_long":"java.util.regex.Pattern","javadoc":"","static":true,"name":"NESTING_DIR_NAME_REGEX","comment":"","type_short":"Pattern","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"MD5_BYTE_LEN","comment":"","type_short":"int","constant_value":"16"},{"type_long":"int","javadoc":"","static":true,"name":"MD5_HEXSTR_LEN","comment":"","type_short":"int","constant_value":"32"},{"type_long":"int","javadoc":"","static":true,"name":"NESTING_LEVEL","comment":"","type_short":"int","constant_value":"2"},{"type_long":"long","javadoc":"","static":true,"name":"MAX_FILE_AGE_MS","comment":"","type_short":"long","constant_value":"86400000"},{"type_long":"long","javadoc":"","static":true,"name":"MAINT_INTERVAL_MS","comment":"","type_short":"long","constant_value":"172800000"},{"type_long":"java.io.File","javadoc":"","static":false,"name":"cacheDir","comment":"","type_short":"File","constant_value":null},{"type_long":"java.io.File","javadoc":"","static":false,"name":"newDir","comment":"","type_short":"File","constant_value":null},{"type_long":"java.io.File","javadoc":"","static":false,"name":"lastMaintFile","comment":"","type_short":"File","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"fileAddCount","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"fileReUseCount","comment":"","type_short":"int","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"storageEstimateBytes","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"lastMaintTS","comment":"","type_short":"long","constant_value":null}]}
