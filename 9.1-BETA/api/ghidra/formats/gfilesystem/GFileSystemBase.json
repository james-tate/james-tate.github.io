{"implements":["ghidra.formats.gfilesystem.GFileSystem"],"javadoc":"This is the original GFileSystem implementation abstract base class, with most of the\n initially implemented filesystem types extending this class.\n <p>\n The new GFileSystem interface is being retro-fitted into this equation to support\n better probing and factory syntax, and new implementations should be based on\n the interface instead of extending this abstract class.\n <p>\n NOTE:\n ALL GFileSystem sub-CLASSES MUST END IN \"FileSystem\".\n If not, the ClassSearcher will not find them.\n Yes, it is an implementation detail.\n <p>\n GFileSystemBase instances are constructed when probing a container file and are queried\n with {@link #isValid(TaskMonitor)} to determine if the container file is handled\n by the GFileSystemBase subclass.<p>\n The {@link ByteProvider} given to the constructor is not considered 'owned' by\n the GFileSystemBase instance until after it passes the {@link #isValid(TaskMonitor) isValid}\n check and is {@link #open(TaskMonitor) opened}.\n <p>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"java.lang.String","name":"fileSystemName","comment":"","type_short":"String"},{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"","type_short":"ByteProvider"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getFSRL","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","comment":"","type_short":"FSRLRoot"}},{"javadoc":"","static":false,"name":"setFSRL","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","name":"fsrl","comment":"","type_short":"FSRLRoot"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setFilesystemService","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.FileSystemService","name":"fsService","comment":"","type_short":"FileSystemService"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if this file system implementation\n can handle the bytes provided.\n This method should perform the minimal amount of\n checks required to determine validity.\n Keep it quick and tight!\n@param monitor a task monitor\n@return true if valid for the byte provider\n@throws IOException if an I\/O error occurs","static":false,"name":"isValid","comment":"Returns true if this file system implementation\n can handle the bytes provided.\n This method should perform the minimal amount of\n checks required to determine validity.\n Keep it quick and tight!","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"a task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if valid for the byte provider","type_short":"boolean"}},{"javadoc":"Opens the file system.\n@throws IOException if an I\/O error occurs\n@throws CryptoException if an encryption error occurs","static":false,"name":"open","comment":"Opens the file system.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs","type_short":"IOException"},{"type_long":"ghidra.util.exception.CryptoException","comment":"if an encryption error occurs","type_short":"CryptoException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Closes the file system.\n All resources should be released. (programs, temporary files, etc.)\n@throws IOException if an I\/O error occurs","static":false,"name":"close","comment":"Closes the file system.\n All resources should be released. (programs, temporary files, etc.)","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isClosed","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the name of this file system.\n@return the name of this file system","static":false,"name":"getName","comment":"Returns the name of this file system.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name of this file system","type_short":"String"}},{"javadoc":"","static":false,"name":"getListing","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.GFile","name":"directory","comment":"","type_short":"GFile"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.util.List<ghidra.formats.gfilesystem.GFile>","comment":"","type_short":"List"}},{"javadoc":"Legacy implementation of {@link #getInputStream(GFile, TaskMonitor)}.\n@param file {@link GFile} to get an InputStream for\n@param monitor {@link TaskMonitor} to watch and update progress\n@return new {@link InputStream} contains the contents of the file or NULL if the\n file doesn't have data.\n@throws IOException if IO problem\n@throws CancelledException if user cancels.\n@throws CryptoException if crypto problem.","static":false,"name":"getData","comment":"Legacy implementation of #getInputStream(GFile, TaskMonitor).","params":[{"type_long":"ghidra.formats.gfilesystem.GFile","name":"file","comment":"GFile to get an InputStream for","type_short":"GFile"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update progress","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if IO problem","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.CryptoException","comment":"if crypto problem.","type_short":"CryptoException"}],"return":{"type_long":"java.io.InputStream","comment":"new InputStream contains the contents of the file or NULL if the\n file doesn't have data.","type_short":"InputStream"}},{"javadoc":"","static":false,"name":"getInputStream","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.GFile","name":"file","comment":"","type_short":"GFile"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.io.InputStream","comment":"","type_short":"InputStream"}},{"javadoc":"Writes the given bytes to a tempfile in the temp directory.\n@param bytes the bytes to write\n@param fileName the prefix of the temp file name","static":false,"name":"debug","comment":"Writes the given bytes to a tempfile in the temp directory.","params":[{"type_long":"byte[]","name":"bytes","comment":"the bytes to write","type_short":"byte[]"},{"type_long":"java.lang.String","name":"fileName","comment":"the prefix of the temp file name","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"lookup","comment":"","params":[{"type_long":"java.lang.String","name":"path","comment":"","type_short":"String"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.GFile","comment":"","type_short":"GFile"}},{"javadoc":"","static":false,"name":"getRefManager","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FileSystemRefManager","comment":"","type_short":"FileSystemRefManager"}}],"name":"GFileSystemBase","comment":"This is the original GFileSystem implementation abstract base class, with most of the\n initially implemented filesystem types extending this class.\n \n The new GFileSystem interface is being retro-fitted into this equation to support\n better probing and factory syntax, and new implementations should be based on\n the interface instead of extending this abstract class.\n \n NOTE:\n ALL GFileSystem sub-CLASSES MUST END IN \"FileSystem\".\n If not, the ClassSearcher will not find them.\n Yes, it is an implementation detail.\n \n GFileSystemBase instances are constructed when probing a container file and are queried\n with #isValid(TaskMonitor) to determine if the container file is handled\n by the GFileSystemBase subclass.\n The ByteProvider given to the constructor is not considered 'owned' by\n the GFileSystemBase instance until after it passes the #isValid(TaskMonitor)\n check and is #open(TaskMonitor).\n ","fields":[{"type_long":"java.lang.String","javadoc":"","static":false,"name":"fileSystemName","comment":"","type_short":"String","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.GFileImpl","javadoc":"","static":false,"name":"root","comment":"","type_short":"GFileImpl","constant_value":null},{"type_long":"ghidra.app.util.bin.ByteProvider","javadoc":"","static":false,"name":"provider","comment":"","type_short":"ByteProvider","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","javadoc":"","static":false,"name":"fsFSRL","comment":"","type_short":"FSRLRoot","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FileSystemRefManager","javadoc":"","static":false,"name":"refManager","comment":"","type_short":"FileSystemRefManager","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FileSystemService","javadoc":"","static":false,"name":"fsService","comment":"","type_short":"FileSystemService","constant_value":null}]}
