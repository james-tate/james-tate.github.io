{"implements":[],"javadoc":"Provides methods for dealing with GFilesystem files and {@link GFileSystem filesystems}.\n <p>\n Most methods take {@link FSRL} references to files as a way to decouple dependencies and\n reduce forced filesystem instantiation.\n <p>\n (ie. a {@link GFile} instance is only valid if its {@link GFileSystem} is open, which\n means that its parent probably also has to be open, recursively, etc, whereas a FSRL\n is always valid and does not force the instantiation of parent objects)\n <p>\n {@link GFileSystem Filesystems} should be used via {@link FileSystemRef filesystem ref}\n handles that ensure the filesystem is pinned in memory and won't be close()ed while\n you are using it.\n <p>\n If you are working with {@link GFile} instances, you should have a\n {@link FileSystemRef fs ref} that you are using to pin the filesystem.\n <p>\n Thread-safe.\n <p>\n\n\n TODO list:\n\n Refactor fileInfo -> needs dialog to show properties\n Refactor GFile.getInfo() to return Map<> instead of String.\n Persistant filesystem - when reopen tool, filesystems should auto-reopen\n Unify GhidraFileChooser with GFileSystem\n   add \"Mounted Filesystems\" button to show currently opened GFilesystems?\n Dockable filesystem browser in FrontEnd\n Reorg filesystem browser right-click popup menu to be more Eclipse action-like\n \tShow In -> Project tree\n             Tool [CodeBrowser name]\n  Import\n  Open With -> Text Viewer\n               Image Viewer\n  Export -> To Project dir\n            To Home dir\n            To Dir\n            To Eclipse Project\n            Decompiled source\n ProgramMappingService - more robust, precache when open project.\n Make BatchImportDialog modeless, drag-and-drop to src list\n\n Testing:\n\n More format tests\n Large test binary support","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":true,"name":"getInstance","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FileSystemService","comment":"","type_short":"FileSystemService"}},{"javadoc":"Creates a FilesystemService instance, using the {@link Application}'s default value\n for {@link Application#getUserCacheDirectory() user cache directory} as the\n cache directory.","static":false,"name":"<init>","comment":"Creates a FilesystemService instance, using the Application's default value\n for Application#getUserCacheDirectory() as the\n cache directory.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a FilesystemService instance, using the supplied directory as its file caching\n root directory.\n@param fscacheDir {@link File Root dir} to use to store files placed into cache.","static":false,"name":"<init>","comment":"Creates a FilesystemService instance, using the supplied directory as its file caching\n root directory.","params":[{"type_long":"java.io.File","name":"fscacheDir","comment":"File to use to store files placed into cache.","type_short":"File"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Forcefully closes all open filesystems and clears caches.","static":false,"name":"clear","comment":"Forcefully closes all open filesystems and clears caches.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Close unused filesystems.","static":false,"name":"closeUnusedFileSystems","comment":"Close unused filesystems.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a direct reference to a filesystem that represents the local filesystem.\n@return {@link GFileSystem} that represents the local filesystem.","static":false,"name":"getLocalFS","comment":"Returns a direct reference to a filesystem that represents the local filesystem.","params":[],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.GFileSystem","comment":"GFileSystem that represents the local filesystem.","type_short":"GFileSystem"}},{"javadoc":"Returns true of there is a {@link GFileSystem filesystem} mounted at the requested\n {@link FSRL} location.\n@param fsrl {@link FSRL} container to query for mounted filesystem\n@return boolean true if filesystem mounted at location.","static":false,"name":"isFilesystemMountedAt","comment":"Returns true of there is a GFileSystem mounted at the requested\n FSRL location.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL container to query for mounted filesystem","type_short":"FSRL"}],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if filesystem mounted at location.","type_short":"boolean"}},{"javadoc":"Returns the {@link GFile} pointed to by the FSRL, along with a {@link FileSystemRef}\n that the caller is responsible for releasing (either explicitly via\n {@code result.fsRef.close()} or via the {@link RefdFile#close()}).\n@param fsrl {@link FSRL} of the desired file\n@param monitor {@link TaskMonitor} so the user can cancel\n@return a {@link RefdFile} which contains the resultant {@link GFile} and a\n {@link FileSystemRef} that needs to be closed, or {@code null} if the filesystem\n does not have the requested file.\n@throws CancelledException if the user cancels\n@throws IOException if there was a file io problem","static":false,"name":"getRefdFile","comment":"Returns the GFile pointed to by the FSRL, along with a FileSystemRef\n that the caller is responsible for releasing (either explicitly via\n  or via the RefdFile#close()).","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the desired file","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor so the user can cancel","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if there was a file io problem","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.RefdFile","comment":"a RefdFile which contains the resultant GFile and a\n FileSystemRef that needs to be closed, or  if the filesystem\n does not have the requested file.","type_short":"RefdFile"}},{"javadoc":"Return a {@link FileCacheEntry} with information about the requested file specified\n by the FSRL, forcing a read\/cache add of the file is it is missing from the cache.\n <p>\n Never returns NULL, instead throws IOException.\n@param fsrl {@link FSRL} of the desired file.\n@param monitor {@link TaskMonitor} to watch and update with progress.\n@return new {@link FileCacheEntry} with info about the cached file.\n@throws IOException if IO error when getting file.\n@throws CancelledException if user canceled.","static":false,"name":"getCacheFile","comment":"Return a FileCacheEntry with information about the requested file specified\n by the FSRL, forcing a read\/cache add of the file is it is missing from the cache.\n \n Never returns NULL, instead throws IOException.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the desired file.","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update with progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if IO error when getting file.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user canceled.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"new FileCacheEntry with info about the cached file.","type_short":"FileCacheEntry"}},{"javadoc":"Returns a filesystem instance for the requested {@link FSRLRoot}, either from an already\n loaded instance in the global fscache, or by instantiating the requested filesystem\n from its container file (in a possibly recursive manner, depending on the depth\n of the FSLR)\n <p>\n Never returns NULL, instead throws IOException if there is a problem.\n <p>\n The caller is responsible for releasing the {@link FileSystemRef}.\n <p>\n@param fsFSRL {@link FSRLRoot} of file system you want a reference to.\n@param monitor {@link TaskMonitor} to allow the user to cancel.\n@return a new {@link FileSystemRef} that the caller is responsible for closing when\n no longer needed, never {@code null}.\n@throws IOException if there was an io problem.\n@throws CancelledException if the user cancels.","static":false,"name":"getFilesystem","comment":"Returns a filesystem instance for the requested FSRLRoot, either from an already\n loaded instance in the global fscache, or by instantiating the requested filesystem\n from its container file (in a possibly recursive manner, depending on the depth\n of the FSLR)\n \n Never returns NULL, instead throws IOException if there is a problem.\n \n The caller is responsible for releasing the FileSystemRef.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","name":"fsFSRL","comment":"FSRLRoot of file system you want a reference to.","type_short":"FSRLRoot"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to allow the user to cancel.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was an io problem.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileSystemRef","comment":"a new FileSystemRef that the caller is responsible for closing when\n no longer needed, never .","type_short":"FileSystemRef"}},{"javadoc":"Adds a {@link GFile file}'s stream's contents to the file cache, returning its MD5 hash.\n@param file {@link GFile} not really used currently\n@param is {@link InputStream} to add to the cache.\n@param monitor {@link TaskMonitor} to monitor and update.\n@return string with new file's md5.\n@throws IOException if IO error\n@throws CancelledException if user canceled.","static":false,"name":"addFileToCache","comment":"Adds a GFile's stream's contents to the file cache, returning its MD5 hash.","params":[{"type_long":"ghidra.formats.gfilesystem.GFile","name":"file","comment":"GFile not really used currently","type_short":"GFile"},{"type_long":"java.io.InputStream","name":"is","comment":"InputStream to add to the cache.","type_short":"InputStream"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to monitor and update.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if IO error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user canceled.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"string with new file's md5.","type_short":"FileCacheEntry"}},{"javadoc":"Stores a stream in the file cache.\n <p>\n@param is {@link InputStream} to store in the cache.\n@param monitor {@link TaskMonitor} to watch and update.\n@return {@link File} location of the new file.\n@throws IOException if IO error\n@throws CancelledException if the user cancels.","static":false,"name":"addStreamToCache","comment":"Stores a stream in the file cache.\n ","params":[{"type_long":"java.io.InputStream","name":"is","comment":"InputStream to store in the cache.","type_short":"InputStream"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if IO error","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"File location of the new file.","type_short":"FileCacheEntry"}},{"javadoc":"Returns a {@link File java.io.file} with the data from the requested FSRL.\n Simple local files will be returned directly, and files nested in containers\n will be located in the file cache directory and have a 'random' name.\n <p>\n Never returns nulls, throws IOException if not found or error.\n@param fsrl {@link FSRL} of the desired file.\n@param monitor {@link TaskMonitor} to watch and update.\n@return {@link File} of the desired file in the cache, never null.\n@throws CancelledException if user cancels.\n@throws IOException if IO problem.","static":false,"name":"getFile","comment":"Returns a File with the data from the requested FSRL.\n Simple local files will be returned directly, and files nested in containers\n will be located in the file cache directory and have a 'random' name.\n \n Never returns nulls, throws IOException if not found or error.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the desired file.","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if IO problem.","type_short":"IOException"}],"return":{"type_long":"java.io.File","comment":"File of the desired file in the cache, never null.","type_short":"File"}},{"javadoc":"","static":false,"name":"getMD5","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Builds a {@link FSRL} of a {@link File file} located on the local filesystem.\n@param f {@link File} on the local filesystem\n@return {@link FSRL} pointing to the same file, never null","static":false,"name":"getLocalFSRL","comment":"Builds a FSRL of a File located on the local filesystem.","params":[{"type_long":"java.io.File","name":"f","comment":"File on the local filesystem","type_short":"File"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FSRL","comment":"FSRL pointing to the same file, never null","type_short":"FSRL"}},{"javadoc":"Converts a java {@link File} instance into a GFilesystem {@link GFile} hosted on the\n {@link #getLocalFS() local filesystem}.\n <p>\n@param f {@link File} on the local filesystem\n@return {@link GFile} representing the same file or {@code null} if there was a problem\n with the file path.","static":false,"name":"getLocalGFile","comment":"Converts a java File instance into a GFilesystem GFile hosted on the\n #getLocalFS().\n ","params":[{"type_long":"java.io.File","name":"f","comment":"File on the local filesystem","type_short":"File"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.GFile","comment":"GFile representing the same file or  if there was a problem\n with the file path.","type_short":"GFile"}},{"javadoc":"Returns a {@link ByteProvider} with the contents of the requested {@link GFile file}\n (in the Global file cache directory).\n <p>\n Never returns null, throws IOException if there was a problem.\n <p>\n Caller is responsible for {@link ByteProvider#close() closing()} the ByteProvider\n when finished.\n@param fsrl {@link FSRL} file to wrap\n@param monitor {@link TaskMonitor} to watch and update.\n@return new {@link ByteProvider}\n@throws CancelledException if user cancels\n@throws IOException if IO problem.","static":false,"name":"getByteProvider","comment":"Returns a ByteProvider with the contents of the requested GFile\n (in the Global file cache directory).\n \n Never returns null, throws IOException if there was a problem.\n \n Caller is responsible for ByteProvider#close() the ByteProvider\n when finished.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL file to wrap","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if IO problem.","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.bin.ByteProvider","comment":"new ByteProvider","type_short":"ByteProvider"}},{"javadoc":"Returns a reference to a file in the FileCache that contains the\n derived (ie. decompressed or decrypted) contents of a source file, as well as\n its md5.\n <p>\n If the file was not present in the cache, the {@link DerivedFileProducer producer}\n lambda will be called and it will be responsible for returning an {@link InputStream}\n which has the derived contents, which will be added to the file cache for next time.\n <p>\n@param fsrl {@link FSRL} of the source (or container) file that this derived file is based on\n@param derivedName a unique string identifying the derived file inside the source (or container) file\n@param producer a {@link DerivedFileProducer callback or lambda} that returns an\n {@link InputStream} that will be streamed into a file and placed into the file cache.\n Example: <pre>(file) -> { return new XYZDecryptorInputStream(file); }<\/pre>\n@param monitor {@link TaskMonitor} that will be monitor for cancel requests and updated\n with file io progress\n@return {@link FileCacheEntry} with file and md5 fields\n@throws CancelledException if the user cancels\n@throws IOException if there was an io error","static":false,"name":"getDerivedFile","comment":"Returns a reference to a file in the FileCache that contains the\n derived (ie. decompressed or decrypted) contents of a source file, as well as\n its md5.\n \n If the file was not present in the cache, the DerivedFileProducer\n lambda will be called and it will be responsible for returning an InputStream\n which has the derived contents, which will be added to the file cache for next time.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the source (or container) file that this derived file is based on","type_short":"FSRL"},{"type_long":"java.lang.String","name":"derivedName","comment":"a unique string identifying the derived file inside the source (or container) file","type_short":"String"},{"type_long":"ghidra.formats.gfilesystem.DerivedFileProducer","name":"producer","comment":"a DerivedFileProducer that returns an\n InputStream that will be streamed into a file and placed into the file cache.\n Example: (file) - { return new XYZDecryptorInputStream(file); }","type_short":"DerivedFileProducer"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor that will be monitor for cancel requests and updated\n with file io progress","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if there was an io error","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with file and md5 fields","type_short":"FileCacheEntry"}},{"javadoc":"Returns a reference to a file in the FileCache that contains the\n derived (ie. decompressed or decrypted) contents of a source file, as well as\n its md5.\n <p>\n If the file was not present in the cache, the {@link DerivedFilePushProducer push producer}\n lambda will be called and it will be responsible for producing and writing the derived\n file's bytes to a {@link OutputStream}, which will be added to the file cache for next time.\n <p>\n@param fsrl {@link FSRL} of the source (or container) file that this derived file is based on\n@param derivedName a unique string identifying the derived file inside the source (or container) file\n@param pusher a {@link DerivedFilePushProducer callback or lambda} that recieves a {@link OutputStream}.\n Example: <pre>(os) -> { ...write to outputstream os here...; }<\/pre>\n@param monitor {@link TaskMonitor} that will be monitor for cancel requests and updated\n with file io progress\n@return {@link FileCacheEntry} with file and md5 fields\n@throws CancelledException if the user cancels\n@throws IOException if there was an io error","static":false,"name":"getDerivedFilePush","comment":"Returns a reference to a file in the FileCache that contains the\n derived (ie. decompressed or decrypted) contents of a source file, as well as\n its md5.\n \n If the file was not present in the cache, the DerivedFilePushProducer\n lambda will be called and it will be responsible for producing and writing the derived\n file's bytes to a OutputStream, which will be added to the file cache for next time.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the source (or container) file that this derived file is based on","type_short":"FSRL"},{"type_long":"java.lang.String","name":"derivedName","comment":"a unique string identifying the derived file inside the source (or container) file","type_short":"String"},{"type_long":"ghidra.formats.gfilesystem.DerivedFilePushProducer","name":"pusher","comment":"a DerivedFilePushProducer that recieves a OutputStream.\n Example: (os) - { ...write to outputstream os here...; }","type_short":"DerivedFilePushProducer"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor that will be monitor for cancel requests and updated\n with file io progress","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if there was an io error","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileCacheEntry","comment":"FileCacheEntry with file and md5 fields","type_short":"FileCacheEntry"}},{"javadoc":"Returns true if the specified derived file exists in the file cache.\n@param fsrl {@link FSRL} of the container\n@param derivedName name of the derived file inside of the container\n@param monitor {@link TaskMonitor}\n@return boolean true if file exists at time of query, false if file is not in cache\n@throws CancelledException if user cancels\n@throws IOException if other IO error","static":false,"name":"hasDerivedFile","comment":"Returns true if the specified derived file exists in the file cache.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the container","type_short":"FSRL"},{"type_long":"java.lang.String","name":"derivedName","comment":"name of the derived file inside of the container","type_short":"String"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if other IO error","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"boolean true if file exists at time of query, false if file is not in cache","type_short":"boolean"}},{"javadoc":"Returns true if the container file probably holds one of the currently supported\n filesystem types.\n <p>\n@param containerFSRL {@link FSRL} of the file being queried.\n@param monitor {@link TaskMonitor} to watch and update progress.\n@return boolean true if the file probably is a container, false otherwise.\n@throws CancelledException if user cancels.\n@throws IOException if IO problem.","static":false,"name":"isFileFilesystemContainer","comment":"Returns true if the container file probably holds one of the currently supported\n filesystem types.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"containerFSRL","comment":"FSRL of the file being queried.","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if IO problem.","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"boolean true if the file probably is a container, false otherwise.","type_short":"boolean"}},{"javadoc":"Auto-detects a filesystem in the container file pointed to by the FSRL.\n <p>\n Returns a filesystem instance for the requested container file, either from an already\n loaded instance in the Global fs cache, or by probing for a filesystem in the container\n file using the {@link FileSystemFactoryMgr}.\n <p>\n Returns null if no filesystem implementation was found that could handle the container\n file.\n@param containerFSRL {@link FSRL} of the file container\n@param monitor {@link TaskMonitor} to watch and update progress.\n@param conflictResolver {@link FileSystemProbeConflictResolver} to handle choosing\n the correct file system type among multiple results, or null if you want\n {@link FileSystemProbeConflictResolver#CHOOSEFIRST} .\n@return new {@link FileSystemRef} or null\n@throws CancelledException if user cancels.\n@throws IOException if IO problem.","static":false,"name":"probeFileForFilesystem","comment":"Auto-detects a filesystem in the container file pointed to by the FSRL.\n \n Returns a filesystem instance for the requested container file, either from an already\n loaded instance in the Global fs cache, or by probing for a filesystem in the container\n file using the FileSystemFactoryMgr.\n \n Returns null if no filesystem implementation was found that could handle the container\n file.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"containerFSRL","comment":"FSRL of the file container","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update progress.","type_short":"TaskMonitor"},{"type_long":"ghidra.formats.gfilesystem.FileSystemProbeConflictResolver","name":"conflictResolver","comment":"FileSystemProbeConflictResolver to handle choosing\n the correct file system type among multiple results, or null if you want\n FileSystemProbeConflictResolver#CHOOSEFIRST .","type_short":"FileSystemProbeConflictResolver"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if IO problem.","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileSystemRef","comment":"new FileSystemRef or null","type_short":"FileSystemRef"}},{"javadoc":"Auto-detects a filesystem in the container file pointed to by the FSRL.\n <p>\n Returns a filesystem instance for the requested container file, either from an already\n loaded instance in the Global fs cache, or by probing for a filesystem in the container\n file using a {@link FileSystemFactoryMgr}.\n <p>\n Returns null if no filesystem implementation was found that could handle the container\n file.\n@param containerFSRL {@link FSRL} of the file container\n@param monitor {@link TaskMonitor} to watch and update progress.\n@param conflictResolver {@link FileSystemProbeConflictResolver} to handle choosing\n the correct file system type among multiple results, or null if you want\n {@link FileSystemProbeConflictResolver#CHOOSEFIRST} .\n@param priorityFilter minimum filesystem {@link FileSystemInfo#priority()} to allow\n when using file system factories to probe the container.\n@return new {@link FileSystemRef} or null\n@throws CancelledException if user cancels.\n@throws IOException if IO problem.","static":false,"name":"probeFileForFilesystem","comment":"Auto-detects a filesystem in the container file pointed to by the FSRL.\n \n Returns a filesystem instance for the requested container file, either from an already\n loaded instance in the Global fs cache, or by probing for a filesystem in the container\n file using a FileSystemFactoryMgr.\n \n Returns null if no filesystem implementation was found that could handle the container\n file.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"containerFSRL","comment":"FSRL of the file container","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update progress.","type_short":"TaskMonitor"},{"type_long":"ghidra.formats.gfilesystem.FileSystemProbeConflictResolver","name":"conflictResolver","comment":"FileSystemProbeConflictResolver to handle choosing\n the correct file system type among multiple results, or null if you want\n FileSystemProbeConflictResolver#CHOOSEFIRST .","type_short":"FileSystemProbeConflictResolver"},{"type_long":"int","name":"priorityFilter","comment":"minimum filesystem FileSystemInfo#priority() to allow\n when using file system factories to probe the container.","type_short":"int"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if IO problem.","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FileSystemRef","comment":"new FileSystemRef or null","type_short":"FileSystemRef"}},{"javadoc":"Mount a specific file system (by class) using a specified container file.\n <p>\n The newly constructed \/ mounted file system is not managed by this FileSystemService\n or controlled with {@link FileSystemRef}s.\n <p>\n The caller is responsible for closing the resultant file system instance when it is\n no longer needed.\n <p>\n@param containerFSRL a reference to the file that contains the file system image\n@param fsClass the GFileSystem derived class that implements the specific file system\n@param monitor {@link TaskMonitor} to allow the user to cancel\n@return new {@link GFileSystem} instance, caller is responsible for closing() when done.\n@throws CancelledException if user cancels\n@throws IOException if file io error or wrong file system type.","static":false,"name":"mountSpecificFileSystem","comment":"Mount a specific file system (by class) using a specified container file.\n \n The newly constructed \/ mounted file system is not managed by this FileSystemService\n or controlled with FileSystemRefs.\n \n The caller is responsible for closing the resultant file system instance when it is\n no longer needed.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"containerFSRL","comment":"a reference to the file that contains the file system image","type_short":"FSRL"},{"type_long":"java.lang.Class<FSTYPE>","name":"fsClass","comment":"the GFileSystem derived class that implements the specific file system","type_short":"Class"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to allow the user to cancel","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if file io error or wrong file system type.","type_short":"IOException"}],"return":{"type_long":"FSTYPE","comment":"new GFileSystem instance, caller is responsible for closing() when done.","type_short":"FSTYPE"}},{"javadoc":"Open the file system contained at the specified location.\n <p>\n The newly constructed \/ mounted file system is not managed by this FileSystemService\n or controlled with {@link FileSystemRef}s.\n <p>\n The caller is responsible for closing the resultant file system instance when it is\n no longer needed.\n <p>\n@param containerFSRL a reference to the file that contains the file system image\n@param monitor {@link TaskMonitor} to allow the user to cancel\n@return new {@link GFileSystem} instance, caller is responsible for closing() when done.\n@throws CancelledException if user cancels\n@throws IOException if file io error or wrong file system type.","static":false,"name":"openFileSystemContainer","comment":"Open the file system contained at the specified location.\n \n The newly constructed \/ mounted file system is not managed by this FileSystemService\n or controlled with FileSystemRefs.\n \n The caller is responsible for closing the resultant file system instance when it is\n no longer needed.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"containerFSRL","comment":"a reference to the file that contains the file system image","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to allow the user to cancel","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if file io error or wrong file system type.","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.GFileSystem","comment":"new GFileSystem instance, caller is responsible for closing() when done.","type_short":"GFileSystem"}},{"javadoc":"Returns a cloned copy of the {@code FSRL} that should have MD5 values specified.\n (excluding GFile objects that don't have data streams)\n <p>\n Also implements a best-effort caching of non-root filesystem FSRL's MD5 values.\n (ie. the md5 values of files inside of containers are cached.  The md5 value of\n files on the real OS filesystem are not cached)\n <p>\n@param fsrl {@link FSRL} of the file that should be forced to have a MD5\n@param monitor {@link TaskMonitor} to watch and update with progress.\n@return possibly new {@link FSRL} instance with a MD5 value.\n@throws CancelledException if user cancels.\n@throws IOException if IO problem.","static":false,"name":"getFullyQualifiedFSRL","comment":"Returns a cloned copy of the  that should have MD5 values specified.\n (excluding GFile objects that don't have data streams)\n \n Also implements a best-effort caching of non-root filesystem FSRL's MD5 values.\n (ie. the md5 values of files inside of containers are cached.  The md5 value of\n files on the real OS filesystem are not cached)\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the file that should be forced to have a MD5","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to watch and update with progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if IO problem.","type_short":"IOException"}],"return":{"type_long":"ghidra.formats.gfilesystem.FSRL","comment":"possibly new FSRL instance with a MD5 value.","type_short":"FSRL"}},{"javadoc":"Returns true if the specified file is on the local computer's\n filesystem.\n@param gfile file to query\n@return true if local, false if the path points to an embedded file in a container.","static":false,"name":"isLocal","comment":"Returns true if the specified file is on the local computer's\n filesystem.","params":[{"type_long":"ghidra.formats.gfilesystem.GFile","name":"gfile","comment":"file to query","type_short":"GFile"}],"throws":[],"return":{"type_long":"boolean","comment":"true if local, false if the path points to an embedded file in a container.","type_short":"boolean"}},{"javadoc":"Returns true if the specified location is a path on the local computer's\n filesystem.\n@param fsrl {@link FSRL} path to query\n@return true if local, false if the path points to an embedded file in a container.","static":false,"name":"isLocal","comment":"Returns true if the specified location is a path on the local computer's\n filesystem.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL path to query","type_short":"FSRL"}],"throws":[],"return":{"type_long":"boolean","comment":"true if local, false if the path points to an embedded file in a container.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getFileHash","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.GFile","name":"gfile","comment":"","type_short":"GFile"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns a list of all detected GFilesystem filesystem names.\n <p>\n See {@link FileSystemFactoryMgr#getAllFilesystemNames()}.\n@return {@link List} of strings.","static":false,"name":"getAllFilesystemNames","comment":"Returns a list of all detected GFilesystem filesystem names.\n \n See FileSystemFactoryMgr#getAllFilesystemNames().","params":[],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"List of strings.","type_short":"List"}},{"javadoc":"Returns a list of all currently mounted filesystems.\n <p>\n As a FSRL is returned, there is no guarantee that the filesystem will still be\n mounted when you later use values from the list.\n <p>\n@return {@link List} of {@link FSRLRoot} of currently mounted filesystems.","static":false,"name":"getMountedFilesystems","comment":"Returns a list of all currently mounted filesystems.\n \n As a FSRL is returned, there is no guarantee that the filesystem will still be\n mounted when you later use values from the list.\n ","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.formats.gfilesystem.FSRLRoot>","comment":"List of FSRLRoot of currently mounted filesystems.","type_short":"List"}},{"javadoc":"Returns a new FilesystemRef handle to an already mounted filesystem.\n <p>\n The caller is responsible for releasing the ref.\n <p>\n Returns null if there is no filesystem mounted at {@code fsFSRL}.\n@param fsFSRL {@link FSRLRoot} of file system to get a {@link FileSystemRef} to.\n@return new {@link FileSystemRef} or null if requested file system not mounted.","static":false,"name":"getMountedFilesystem","comment":"Returns a new FilesystemRef handle to an already mounted filesystem.\n \n The caller is responsible for releasing the ref.\n \n Returns null if there is no filesystem mounted at .","params":[{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","name":"fsFSRL","comment":"FSRLRoot of file system to get a FileSystemRef to.","type_short":"FSRLRoot"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FileSystemRef","comment":"new FileSystemRef or null if requested file system not mounted.","type_short":"FileSystemRef"}},{"javadoc":"Interns the FSRLRoot so that its parent parts are shared with already interned instances.\n <p>\n Caller needs to hold sync mutex\n@param fsrl {@link FSRLRoot} to intern-alize.\n@return possibly different {@link FSRLRoot} instance that has shared parent references\n instead of unique bespoke instances.","static":false,"name":"intern","comment":"Interns the FSRLRoot so that its parent parts are shared with already interned instances.\n \n Caller needs to hold sync mutex","params":[{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","name":"fsrl","comment":"FSRLRoot to intern-alize.","type_short":"FSRLRoot"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","comment":"possibly different FSRLRoot instance that has shared parent references\n instead of unique bespoke instances.","type_short":"FSRLRoot"}},{"javadoc":"Interns the FSRL so that its parent parts are shared with already interned instances.\n <p>\n Caller needs to hold sync mutex.\n <p>\n Only {@link FSRLRoot} instances are cached in the intern map, {@link FSRL} instances\n are not.\n@param fsrl {@link FSRL} to intern-alize.\n@return possibly different {@link FSRL} instance that has shared parent references\n instead of unique bespoke instances.","static":false,"name":"intern","comment":"Interns the FSRL so that its parent parts are shared with already interned instances.\n \n Caller needs to hold sync mutex.\n \n Only FSRLRoot instances are cached in the intern map, FSRL instances\n are not.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL to intern-alize.","type_short":"FSRL"}],"throws":[],"return":{"type_long":"ghidra.formats.gfilesystem.FSRL","comment":"possibly different FSRL instance that has shared parent references\n instead of unique bespoke instances.","type_short":"FSRL"}}],"name":"FileSystemService","comment":"Provides methods for dealing with GFilesystem files and GFileSystem.\n \n Most methods take FSRL references to files as a way to decouple dependencies and\n reduce forced filesystem instantiation.\n \n (ie. a GFile instance is only valid if its GFileSystem is open, which\n means that its parent probably also has to be open, recursively, etc, whereas a FSRL\n is always valid and does not force the instantiation of parent objects)\n \n GFileSystem should be used via FileSystemRef\n handles that ensure the filesystem is pinned in memory and won't be close()ed while\n you are using it.\n \n If you are working with GFile instances, you should have a\n FileSystemRef that you are using to pin the filesystem.\n \n Thread-safe.\n \n\n\n TODO list:\n\n Refactor fileInfo - needs dialog to show properties\n Refactor GFile.getInfo() to return Map instead of String.\n Persistant filesystem - when reopen tool, filesystems should auto-reopen\n Unify GhidraFileChooser with GFileSystem\n   add \"Mounted Filesystems\" button to show currently opened GFilesystems?\n Dockable filesystem browser in FrontEnd\n Reorg filesystem browser right-click popup menu to be more Eclipse action-like\n \tShow In - Project tree\n             Tool [CodeBrowser name]\n  Import\n  Open With - Text Viewer\n               Image Viewer\n  Export - To Project dir\n            To Home dir\n            To Dir\n            To Eclipse Project\n            Decompiled source\n ProgramMappingService - more robust, precache when open project.\n Make BatchImportDialog modeless, drag-and-drop to src list\n\n Testing:\n\n More format tests\n Large test binary support","fields":[{"type_long":"int","javadoc":"","static":true,"name":"FSRL_INTERN_SIZE","comment":"","type_short":"int","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.LocalFileSystem","javadoc":"","static":false,"name":"localFS","comment":"","type_short":"LocalFileSystem","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FSRLRoot","javadoc":"","static":false,"name":"localFSRL","comment":"","type_short":"FSRLRoot","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.factory.FileSystemFactoryMgr","javadoc":"","static":false,"name":"fsFactoryMgr","comment":"","type_short":"FileSystemFactoryMgr","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FileCache","javadoc":"","static":false,"name":"fileCache","comment":"","type_short":"FileCache","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FileSystemCache","javadoc":"","static":false,"name":"filesystemCache","comment":"","type_short":"FileSystemCache","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FileCacheNameIndex","javadoc":"","static":false,"name":"fileCacheNameIndex","comment":"","type_short":"FileCacheNameIndex","constant_value":null},{"type_long":"ghidra.formats.gfilesystem.FileFingerprintCache","javadoc":"","static":false,"name":"fileFingerprintCache","comment":"","type_short":"FileFingerprintCache","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"fsCacheMaintIntervalMS","comment":"","type_short":"long","constant_value":null},{"type_long":"ghidra.util.datastruct.FixedSizeHashMap<ghidra.formats.gfilesystem.FSRLRoot,ghidra.formats.gfilesystem.FSRLRoot>","javadoc":"LRU hashmap, limited in size to FSRL_INTERN_SIZE.","static":false,"name":"fsrlInternMap","comment":"LRU hashmap, limited in size to FSRL_INTERN_SIZE.","type_short":"FixedSizeHashMap","constant_value":null}]}
