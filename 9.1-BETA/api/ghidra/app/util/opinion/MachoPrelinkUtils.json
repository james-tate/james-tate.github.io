{"implements":[],"javadoc":"Utilities methods for working with Mach-O PRELINK binaries.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Parses the provider looking for PRELINK XML.\n@param provider The provider to parse.\n@param monitor A monitor.\n@return A list of discovered {@link PrelinkMap}s.  An empty list indicates that the provider\n   did not represent valid Mach-O PRELINK binary.\n@throws IOException if there was an IO-related issue.\n@throws JDOMException if there was a issue parsing the PRELINK XML.","static":true,"name":"parsePrelinkXml","comment":"Parses the provider looking for PRELINK XML.","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"The provider to parse.","type_short":"ByteProvider"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"A monitor.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was an IO-related issue.","type_short":"IOException"},{"type_long":"org.jdom.JDOMException","comment":"if there was a issue parsing the PRELINK XML.","type_short":"JDOMException"}],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.macho.prelink.PrelinkMap>","comment":"A list of discovered PrelinkMaps.  An empty list indicates that the provider\n   did not represent valid Mach-O PRELINK binary.","type_short":"List"}},{"javadoc":"Scans the provider looking for PRELINK Mach-O headers.  \n <p>\n NOTE: The \"System\" Mach-O at offset 0 is not considered a PRELINK Mach-O.\n <p>\n NOTE: We used to scan on 0x1000, and then 0x10 byte boundaries.  Now iOS 12 seems to \n put them on 0x8-byte boundaries.\n@param provider The provider to scan.\n@param monitor A monitor.\n@return A list of provider offsets where PRELINK Mach-O headers start (not including the\n   \"System\" Mach-O at offset 0).\n@throws IOException If there was an IO-related issue searching for PRELINK Mach-O headers.","static":true,"name":"findPrelinkMachoHeaderOffsets","comment":"Scans the provider looking for PRELINK Mach-O headers.  \n \n NOTE: The \"System\" Mach-O at offset 0 is not considered a PRELINK Mach-O.\n \n NOTE: We used to scan on 0x1000, and then 0x10 byte boundaries.  Now iOS 12 seems to \n put them on 0x8-byte boundaries.","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"The provider to scan.","type_short":"ByteProvider"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"A monitor.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"If there was an IO-related issue searching for PRELINK Mach-O headers.","type_short":"IOException"}],"return":{"type_long":"java.util.List<java.lang.Long>","comment":"A list of provider offsets where PRELINK Mach-O headers start (not including the\n   \"System\" Mach-O at offset 0).","type_short":"List"}},{"javadoc":"Forms a bidirectional mapping of PRELINK XML to Mach-O header offset in the given provider.\n@param provider The PRELINK Mach-O provider.\n@param prelinkList A list of {@link PrelinkMap}s.\n@param machoHeaderOffsets A list of provider offsets where PRELINK Mach-O headers start (not \n   including the \"System\" Mach-O at offset 0).\n@param monitor A monitor\n@return A bidirectional mapping of PRELINK XML to Mach-O header offset in the given provider.\n@throws MachException If there was a problem parsing a Mach-O header.\n@throws IOException If there was an IO-related issue mapping PRELINK XML to Mach-O headers.","static":true,"name":"matchPrelinkToMachoHeaderOffsets","comment":"Forms a bidirectional mapping of PRELINK XML to Mach-O header offset in the given provider.","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"The PRELINK Mach-O provider.","type_short":"ByteProvider"},{"type_long":"java.util.List<ghidra.app.util.bin.format.macho.prelink.PrelinkMap>","name":"prelinkList","comment":"A list of PrelinkMaps.","type_short":"List"},{"type_long":"java.util.List<java.lang.Long>","name":"machoHeaderOffsets","comment":"A list of provider offsets where PRELINK Mach-O headers start (not \n   including the \"System\" Mach-O at offset 0).","type_short":"List"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"A monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.app.util.bin.format.macho.MachException","comment":"If there was a problem parsing a Mach-O header.","type_short":"MachException"},{"type_long":"java.io.IOException","comment":"If there was an IO-related issue mapping PRELINK XML to Mach-O headers.","type_short":"IOException"}],"return":{"type_long":"org.apache.commons.collections4.BidiMap<ghidra.app.util.bin.format.macho.prelink.PrelinkMap,java.lang.Long>","comment":"A bidirectional mapping of PRELINK XML to Mach-O header offset in the given provider.","type_short":"BidiMap"}},{"javadoc":"Gets the start address of the PRELINK Mach-O's in memory.\n <p>\n NOTE: This method only works for pre iOS 12 binaries.  If called on an iOS 12 binary, it will\n fail and return 0 because the __PRELINK_TEXT segment has a size of 0.  In this case, some\n other means of computing the start address of the PRELINK Mach-O's must be used.\n@param header The Mach-O header.\n@return The start address of the PRELINK Mach-O's in memory, or 0 if it could not be found.","static":true,"name":"getPrelinkStartAddr","comment":"Gets the start address of the PRELINK Mach-O's in memory.\n \n NOTE: This method only works for pre iOS 12 binaries.  If called on an iOS 12 binary, it will\n fail and return 0 because the __PRELINK_TEXT segment has a size of 0.  In this case, some\n other means of computing the start address of the PRELINK Mach-O's must be used.","params":[{"type_long":"ghidra.app.util.bin.format.macho.MachHeader","name":"header","comment":"The Mach-O header.","type_short":"MachHeader"}],"throws":[],"return":{"type_long":"long","comment":"The start address of the PRELINK Mach-O's in memory, or 0 if it could not be found.","type_short":"long"}},{"javadoc":"Checks to see if the provider at the given offset represents a valid Mach-O file that we can\n load (ie, we support the processor).  If it does, a valid {@link LoadSpec} for the Mach-O is \n returned.\n@param provider The provider.\n@param offset The offset within the provider to check.\n@return True A valid {@link LoadSpec} for the Mach-O at the given provider's offset, or null \n   if it is not a Mach-O or a valid {@link LoadSpec} could not be found.\n@throws IOException if there was an IO-related problem.","static":true,"name":"getMachoLoadSpec","comment":"Checks to see if the provider at the given offset represents a valid Mach-O file that we can\n load (ie, we support the processor).  If it does, a valid LoadSpec for the Mach-O is \n returned.","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"The provider.","type_short":"ByteProvider"},{"type_long":"long","name":"offset","comment":"The offset within the provider to check.","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"if there was an IO-related problem.","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.opinion.LoadSpec","comment":"True A valid LoadSpec for the Mach-O at the given provider's offset, or null \n   if it is not a Mach-O or a valid LoadSpec could not be found.","type_short":"LoadSpec"}}],"name":"MachoPrelinkUtils","comment":"Utilities methods for working with Mach-O PRELINK binaries.","fields":[]}
