{"implements":[],"javadoc":"PseudoDisassembler.java\n \n Useful for disassembling and getting an Instruction or creating Data\n at a location in memory when you don't want the program to be changed.\n \n The Instructions or Data that area created are PseudoInstruction's and\n PseudoData's.  They act like regular instructions in most respects, but\n they don't exist in the program.  No references, symbols, are created or\n will be saved when the program is saved.\n \n You do not need to have an open transaction on the program to use the\n PseudoDisassembler.\n \n The PseudoDisassembler can also be used to check if something is a valid\n subroutine.  The algorithm it uses could definitely use some tuning, but\n it generally works well.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Create a pseudo disassembler for the given program.","static":false,"name":"<init>","comment":"Create a pseudo disassembler for the given program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.lang.Language","name":"lang","comment":"","type_short":"Language"},{"type_long":"ghidra.program.model.mem.Memory","name":"mem","comment":"","type_short":"Memory"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the maximum number of instructions to check\n@param maxNumInstructions - maximum number of instructions to check before returning","static":false,"name":"setMaxInstructions","comment":"Set the maximum number of instructions to check","params":[{"type_long":"int","name":"maxNumInstructions","comment":"- maximum number of instructions to check before returning","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set flag to respect Execute bit on memory if present on any memory\n@param respect - true, respect execute bit on memory blocks","static":false,"name":"setRespectExecuteFlag","comment":"Set flag to respect Execute bit on memory if present on any memory","params":[{"type_long":"boolean","name":"respect","comment":"- true, respect execute bit on memory blocks","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Disassemble a single instruction.  The program is not affected.\n@param addr location to disassemble\n@return a PseudoInstruction\n@throws InsufficientBytesException\n@throws UnknownInstructionException\n@throws UnknownContextException","static":false,"name":"disassemble","comment":"Disassemble a single instruction.  The program is not affected.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"location to disassemble","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.lang.InsufficientBytesException","comment":"","type_short":"InsufficientBytesException"},{"type_long":"ghidra.program.model.lang.UnknownInstructionException","comment":"","type_short":"UnknownInstructionException"},{"type_long":"ghidra.program.model.lang.UnknownContextException","comment":"","type_short":"UnknownContextException"}],"return":{"type_long":"ghidra.app.util.PseudoInstruction","comment":"a PseudoInstruction","type_short":"PseudoInstruction"}},{"javadoc":"Disassemble a single instruction.  The program is not affected.\n@param addr\n@param disassemblerContext\n@param isInDelaySlot\n@return \n@throws InsufficientBytesException\n@throws UnknownInstructionException\n@throws UnknownContextException","static":false,"name":"disassemble","comment":"Disassemble a single instruction.  The program is not affected.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"ghidra.app.util.PseudoDisassemblerContext","name":"disassemblerContext","comment":"","type_short":"PseudoDisassemblerContext"},{"type_long":"boolean","name":"isInDelaySlot","comment":"","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.lang.InsufficientBytesException","comment":"","type_short":"InsufficientBytesException"},{"type_long":"ghidra.program.model.lang.UnknownInstructionException","comment":"","type_short":"UnknownInstructionException"},{"type_long":"ghidra.program.model.lang.UnknownContextException","comment":"","type_short":"UnknownContextException"}],"return":{"type_long":"ghidra.app.util.PseudoInstruction","comment":"","type_short":"PseudoInstruction"}},{"javadoc":"Disassemble a location in memory with the given set of bytes.\n Useful when the address has no actual bytes defined, or you want to use\n your own bytes instead of what is in the program at the address.\n@param addr address to disassemble\n@param bytes bytes to use instead of those currently defined in program\n@return PseudoInstruction.\n@throws InsufficientBytesException\n@throws UnknownInstructionException\n@throws UnknownContextException","static":false,"name":"disassemble","comment":"Disassemble a location in memory with the given set of bytes.\n Useful when the address has no actual bytes defined, or you want to use\n your own bytes instead of what is in the program at the address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to disassemble","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"bytes to use instead of those currently defined in program","type_short":"byte[]"}],"throws":[{"type_long":"ghidra.program.model.lang.InsufficientBytesException","comment":"","type_short":"InsufficientBytesException"},{"type_long":"ghidra.program.model.lang.UnknownInstructionException","comment":"","type_short":"UnknownInstructionException"},{"type_long":"ghidra.program.model.lang.UnknownContextException","comment":"","type_short":"UnknownContextException"}],"return":{"type_long":"ghidra.app.util.PseudoInstruction","comment":"PseudoInstruction.","type_short":"PseudoInstruction"}},{"javadoc":"Disassemble a location in memory with the given set of bytes.\n Useful when the address has no actual bytes defined, or you want to use\n your own bytes instead of what is in the program at the address.\n@param addr address to disassemble\n@param bytes bytes to use instead of those currently defined in program\n@param PseudoDisassemblerContext the disassembler context to use.\n@return PseudoInstruction.\n@throws InsufficientBytesException\n@throws UnknownInstructionException\n@throws UnknownContextException","static":false,"name":"disassemble","comment":"Disassemble a location in memory with the given set of bytes.\n Useful when the address has no actual bytes defined, or you want to use\n your own bytes instead of what is in the program at the address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to disassemble","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"bytes to use instead of those currently defined in program","type_short":"byte[]"},{"type_long":"ghidra.app.util.PseudoDisassemblerContext","name":"disassemblerContext","comment":"","type_short":"PseudoDisassemblerContext"}],"throws":[{"type_long":"ghidra.program.model.lang.InsufficientBytesException","comment":"","type_short":"InsufficientBytesException"},{"type_long":"ghidra.program.model.lang.UnknownInstructionException","comment":"","type_short":"UnknownInstructionException"},{"type_long":"ghidra.program.model.lang.UnknownContextException","comment":"","type_short":"UnknownContextException"}],"return":{"type_long":"ghidra.app.util.PseudoInstruction","comment":"PseudoInstruction.","type_short":"PseudoInstruction"}},{"javadoc":"Apply a dataType to the program at the given address.  The program is\n not affected.  A PseudoData item that acts like a Data item retrieved from\n a program is returned.  This is useful if you have a datatype and you\n want to use it to get values from the program at a given address.\n@param addr location to get a PseudoData item for\n@param dt the data type to be applied\n@return PsuedoData that acts like Data\n@throws InsufficientBytesException\n@throws UnknownContextException","static":false,"name":"applyDataType","comment":"Apply a dataType to the program at the given address.  The program is\n not affected.  A PseudoData item that acts like a Data item retrieved from\n a program is returned.  This is useful if you have a datatype and you\n want to use it to get values from the program at a given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"location to get a PseudoData item for","type_short":"Address"},{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"the data type to be applied","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.app.util.PseudoData","comment":"PsuedoData that acts like Data","type_short":"PseudoData"}},{"javadoc":"Interpret the bytes at a location in memory as an address\n and return the address.  This routine assumes that the bytes\n needed to create the address are the same size as the bytes\n needed to represent the toAddr.  So this is somewhat generic.\n@param toAddr location of the bytes in memory\n@return the address value","static":false,"name":"getIndirectAddr","comment":"Interpret the bytes at a location in memory as an address\n and return the address.  This routine assumes that the bytes\n needed to create the address are the same size as the bytes\n needed to represent the toAddr.  So this is somewhat generic.","params":[{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"location of the bytes in memory","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the address value","type_short":"Address"}},{"javadoc":"Check that this entry point leads to a well behaved subroutine:\n <li>It should return.<\/li>\n <li>Hit no bad instructions.<\/li>\n <li>Have only one entry point.<\/li>\n <li>Not overlap any existing data or instructions.<\/li>\n@param entryPoint entry point to check\n@return true if entry point leads to a well behaved subroutine","static":false,"name":"isValidSubroutine","comment":"Check that this entry point leads to a well behaved subroutine:\n It should return.\n Hit no bad instructions.\n Have only one entry point.\n Not overlap any existing data or instructions.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"entry point to check","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if entry point leads to a well behaved subroutine","type_short":"boolean"}},{"javadoc":"Check that this entry point leads to a well behaved subroutine, allow it\n to fall into existing code.\n <li>It should return.<\/li>\n <li>Hit no bad instructions.<\/li>\n <li>Have only one entry point.<\/li>\n <li>Not overlap any existing data or cause offcut references.<\/li>\n@param entryPoint entry point to check\n@param allowExistingCode true allows this subroutine to flow into existing instructions.\n@return true if entry point leads to a well behaved subroutine","static":false,"name":"isValidSubroutine","comment":"Check that this entry point leads to a well behaved subroutine, allow it\n to fall into existing code.\n It should return.\n Hit no bad instructions.\n Have only one entry point.\n Not overlap any existing data or cause offcut references.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"entry point to check","type_short":"Address"},{"type_long":"boolean","name":"allowExistingCode","comment":"true allows this subroutine to flow into existing instructions.","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"true if entry point leads to a well behaved subroutine","type_short":"boolean"}},{"javadoc":"Check that this entry point leads to a well behaved subroutine, allow it\n to fall into existing code.\n \n <li>Hit no bad instructions.<\/li>\n <li>Have only one entry point.<\/li>\n <li>Not overlap any existing data or cause offcut references.<\/li>\n@param entryPoint entry point to check\n@param allowExistingCode true allows this subroutine to flow into existing instructions.\n@param mustTerminate true if the subroutine must terminate\n@return true if entry point leads to a well behaved subroutine","static":false,"name":"isValidSubroutine","comment":"Check that this entry point leads to a well behaved subroutine, allow it\n to fall into existing code.\n \n Hit no bad instructions.\n Have only one entry point.\n Not overlap any existing data or cause offcut references.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"entry point to check","type_short":"Address"},{"type_long":"boolean","name":"allowExistingCode","comment":"true allows this subroutine to flow into existing instructions.","type_short":"boolean"},{"type_long":"boolean","name":"mustTerminate","comment":"true if the subroutine must terminate","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"true if entry point leads to a well behaved subroutine","type_short":"boolean"}},{"javadoc":"Check that this entry point leads to valid code:\n <li> May have multiple entries into the body of the code.\n <li>The intent is that it be valid code, not nice code.\n <li>Hit no bad instructions.\n <li>It should return.\n <\/li>\n@param entryPoint\n@return true if the entry point leads to valid code","static":false,"name":"isValidCode","comment":"Check that this entry point leads to valid code:\n  May have multiple entries into the body of the code.\n The intent is that it be valid code, not nice code.\n Hit no bad instructions.\n It should return.\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the entry point leads to valid code","type_short":"boolean"}},{"javadoc":"Check that this entry point leads to valid code:\n <li> May have multiple entries into the body of the code.\n <li>The intent is that it be valid code, not nice code.\n <li>Hit no bad instructions.\n <li>It should return.\n <\/li>\n@param entryPoint location to test for valid code\n@param context disassembly context for program\n@return true if the entry point leads to valid code","static":false,"name":"isValidCode","comment":"Check that this entry point leads to valid code:\n  May have multiple entries into the body of the code.\n The intent is that it be valid code, not nice code.\n Hit no bad instructions.\n It should return.\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"location to test for valid code","type_short":"Address"},{"type_long":"ghidra.app.util.PseudoDisassemblerContext","name":"context","comment":"disassembly context for program","type_short":"PseudoDisassemblerContext"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the entry point leads to valid code","type_short":"boolean"}},{"javadoc":"Process a subroutine using the processor function.\n The process function can control what flows are followed and when to stop.\n@param entryPoint start address\n@param processor processor to use\n@return the address set of instructions that were followed","static":false,"name":"followSubFlows","comment":"Process a subroutine using the processor function.\n The process function can control what flows are followed and when to stop.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"start address","type_short":"Address"},{"type_long":"int","name":"maxInstr","comment":"","type_short":"int"},{"type_long":"ghidra.app.util.PseudoFlowProcessor","name":"processor","comment":"processor to use","type_short":"PseudoFlowProcessor"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"the address set of instructions that were followed","type_short":"AddressSet"}},{"javadoc":"Process a subroutine using the processor function.\n The process function can control what flows are followed and when to stop.\n@param entryPoint start address\n@param processor processor to use\n@return the address set of instructions that were followed","static":false,"name":"followSubFlows","comment":"Process a subroutine using the processor function.\n The process function can control what flows are followed and when to stop.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"start address","type_short":"Address"},{"type_long":"ghidra.app.util.PseudoDisassemblerContext","name":"procContext","comment":"","type_short":"PseudoDisassemblerContext"},{"type_long":"int","name":"maxInstr","comment":"","type_short":"int"},{"type_long":"ghidra.app.util.PseudoFlowProcessor","name":"processor","comment":"processor to use","type_short":"PseudoFlowProcessor"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"the address set of instructions that were followed","type_short":"AddressSet"}},{"javadoc":"Gets a new target address from the untried target list if it can find one not already in the\n disassembled address set that is passed in.\n@param body address set of disassembled instructions\n@param untriedTargetList list of untried valid targets\n@return a new target address or null","static":false,"name":"getNextTarget","comment":"Gets a new target address from the untried target list if it can find one not already in the\n disassembled address set that is passed in.","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"body","comment":"address set of disassembled instructions","type_short":"AddressSet"},{"type_long":"java.util.ArrayList<ghidra.program.model.address.Address>","name":"untriedTargetList","comment":"list of untried valid targets","type_short":"ArrayList"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"a new target address or null","type_short":"Address"}},{"javadoc":"Check if there is a valid subroutine starting at the target address.\n It does this by following the flow until a terminator is reached.\n If a bad instruction is hit or it does not flow well, then return\n false.\n@param target - taraget address to disassemble\n@return true if this is a probable subroutine.","static":false,"name":"checkValidSubroutine","comment":"Check if there is a valid subroutine starting at the target address.\n It does this by following the flow until a terminator is reached.\n If a bad instruction is hit or it does not flow well, then return\n false.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"},{"type_long":"boolean","name":"allowExistingInstructions","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a probable subroutine.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"checkValidSubroutine","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"},{"type_long":"boolean","name":"allowExistingInstructions","comment":"","type_short":"boolean"},{"type_long":"boolean","name":"mustTerminate","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"checkValidSubroutine","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"},{"type_long":"ghidra.app.util.PseudoDisassemblerContext","name":"procContext","comment":"","type_short":"PseudoDisassemblerContext"},{"type_long":"boolean","name":"allowExistingInstructions","comment":"","type_short":"boolean"},{"type_long":"boolean","name":"mustTerminate","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"checkNonReturning","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.symbol.FlowType","name":"flowType","comment":"","type_short":"FlowType"},{"type_long":"ghidra.app.util.PseudoInstruction","name":"instr","comment":"","type_short":"PseudoInstruction"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Make sure the instruction really has a return in it.\n@param instr instruction to check","static":false,"name":"isReallyReturn","comment":"Make sure the instruction really has a return in it.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"instruction to check","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"checkPseudoBody","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSet","name":"body","comment":"","type_short":"AddressSet"},{"type_long":"ghidra.program.model.address.AddressSet","name":"starts","comment":"","type_short":"AddressSet"},{"type_long":"boolean","name":"allowExistingInstructions","comment":"","type_short":"boolean"},{"type_long":"boolean","name":"didCallValidSubroutine","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get an address that can be used for disassembly.  Useful for some processors where\n pointers to code have 1 added to them for different modes such as Thumb mode for ARM.\n@param program to get address from\n@param addr to be normallized\/aligned for disassembly\n@return the normalized\/aligned address for disassembly","static":true,"name":"getNormalizedDisassemblyAddress","comment":"Get an address that can be used for disassembly.  Useful for some processors where\n pointers to code have 1 added to them for different modes such as Thumb mode for ARM.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"to get address from","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"to be normallized\/aligned for disassembly","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the normalized\/aligned address for disassembly","type_short":"Address"}},{"javadoc":"@return RegisterValue setting for the context register to disassemble correctly at the given address\n         or null, if no setting is needed.","static":true,"name":"getTargetContextRegisterValueForDisassembly","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.RegisterValue","comment":"RegisterValue setting for the context register to disassemble correctly at the given address\n         or null, if no setting is needed.","type_short":"RegisterValue"}},{"javadoc":"@return true if program has uses the low bit of an address to change Instruction Set mode","static":true,"name":"hasLowBitCodeModeInAddrValues","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"boolean","comment":"true if program has uses the low bit of an address to change Instruction Set mode","type_short":"boolean"}},{"javadoc":"If this processor uses the low bit of an address to change to a new Instruction Set mode\n   Check the low bit and change the instruction state at the address.\n@param program\n@param addr the raw address\n@return the correct address to disassemble at if it needs to be aligned","static":true,"name":"setTargeContextForDisassembly","comment":"If this processor uses the low bit of an address to change to a new Instruction Set mode\n   Check the low bit and change the instruction state at the address.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the raw address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the correct address to disassemble at if it needs to be aligned","type_short":"Address"}},{"javadoc":"In order to check a location to see if it disassembles from an address reference, the\n address is checked for low-bit code switch behavior.  If it does switch, the context\n is changed.\n@param procContext context to change\n@param addr destination address that will be disassembled (possible pseudo disassembled)\n@return the correct disassembly location if the address needed to be adjusted.","static":false,"name":"setTargeContextForDisassembly","comment":"In order to check a location to see if it disassembles from an address reference, the\n address is checked for low-bit code switch behavior.  If it does switch, the context\n is changed.","params":[{"type_long":"ghidra.app.util.PseudoDisassemblerContext","name":"procContext","comment":"context to change","type_short":"PseudoDisassemblerContext"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"destination address that will be disassembled (possible pseudo disassembled)","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the correct disassembly location if the address needed to be adjusted.","type_short":"Address"}}],"name":"PseudoDisassembler","comment":"PseudoDisassembler.java\n \n Useful for disassembling and getting an Instruction or creating Data\n at a location in memory when you don't want the program to be changed.\n \n The Instructions or Data that area created are PseudoInstruction's and\n PseudoData's.  They act like regular instructions in most respects, but\n they don't exist in the program.  No references, symbols, are created or\n will be saved when the program is saved.\n \n You do not need to have an open transaction on the program to use the\n PseudoDisassembler.\n \n The PseudoDisassembler can also be used to check if something is a valid\n subroutine.  The algorithm it uses could definitely use some tuning, but\n it generally works well.","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"LOW_BIT_CODE_MODE_REGISTER_NAME","comment":"","type_short":"String","constant_value":"\"LowBitCodeMode\""},{"type_long":"int","javadoc":"","static":true,"name":"DEFAULT_MAX_INSTRUCTIONS","comment":"","type_short":"int","constant_value":"4000"},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"program","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.ProgramContext","javadoc":"","static":false,"name":"programContext","comment":"","type_short":"ProgramContext","constant_value":null},{"type_long":"ghidra.program.model.lang.Language","javadoc":"","static":false,"name":"language","comment":"","type_short":"Language","constant_value":null},{"type_long":"ghidra.program.model.mem.Memory","javadoc":"","static":false,"name":"memory","comment":"","type_short":"Memory","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"pointerSize","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"MAX_REPEAT_BYTES_LIMIT","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":false,"name":"maxInstructions","comment":"","type_short":"int","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"respectExecuteFlag","comment":"","type_short":"boolean","constant_value":null}]}
