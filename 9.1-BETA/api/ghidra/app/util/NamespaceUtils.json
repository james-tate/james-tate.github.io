{"implements":[],"javadoc":"A class to hold utility methods for working with namespaces.\n <p>\n <a name=\"examples\"><\/a>\n Example string format:\n <ul>\n     <li>global{@link Namespace#NAMESPACE_DELIMITER &lt;delimiter&gt;}child1{@link Namespace#NAMESPACE_DELIMITER &lt;delimiter&gt;}child2\n     <li>child1\n <\/ul>\n <a name=\"assumptions\"><\/a>\n <b>Assumptions for creating namespaces from a path string: <\/b>\n <ul>\n     <li>All elements of a namespace path should be namespace symbols and not other\n         symbol types.\n     <li>If the method takes an address, then the path can contain a function name provided\n         the address is in the body of the function; otherwise\n         the names must all be namespaces other than functions.\n     <li>Absolute paths can optionally start with the global namespace.\n     <li>You can provide a relative path that will start at the given\n         parent namespace (or global if there is no parent provided).\n     <li>You can provide a path that has as its first entry the name of the\n         given parent.  In this case, the first entry will not be created,\n         but rather the provided parent will be used.\n     <li>If you provide a path and a parent, but the first element of the\n         path is the global namespace, then the global namespace will be\n         used as the parent namespace and not the one that was provided.\n     <li>You cannot embed the global namespace in a path, but it can be at\n         the root.\n <\/ul>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the normal namespace path excluding any library name.  Global namespace will be\n returned as empty string, while other namespace paths will be returned with trailing ::\n suffix.\n@param namespace namespace\n@return namespace path excluding any library name","static":true,"name":"getNamespacePathWithoutLibrary","comment":"Get the normal namespace path excluding any library name.  Global namespace will be\n returned as empty string, while other namespace paths will be returned with trailing ::\n suffix.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"namespace","type_short":"Namespace"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"namespace path excluding any library name","type_short":"String"}},{"javadoc":"Get namespace qualified symbol name\n@param namespace namespace object\n@param symbolName name of symbol\n@param excludeLibraryName if true any library name will be excluded from path returned,\n otherwise it will be included\n@return namespace qualified symbol name","static":true,"name":"getNamespaceQualifiedName","comment":"Get namespace qualified symbol name","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"namespace object","type_short":"Namespace"},{"type_long":"java.lang.String","name":"symbolName","comment":"name of symbol","type_short":"String"},{"type_long":"boolean","name":"excludeLibraryName","comment":"if true any library name will be excluded from path returned,\n otherwise it will be included","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"namespace qualified symbol name","type_short":"String"}},{"javadoc":"Provide a standard method for splitting a symbol path into its\n various namespace and symbol name elements.  While the current implementation\n uses a very simplistic approach, this may be improved upon in the future\n to handle various grouping concepts.\n@param path symbol namespace path (path will be trimmed before parse)\n@return order list of namespace names\n@deprecated use SymbolPath instead","static":true,"name":"splitNamespacePath","comment":"Provide a standard method for splitting a symbol path into its\n various namespace and symbol name elements.  While the current implementation\n uses a very simplistic approach, this may be improved upon in the future\n to handle various grouping concepts.","params":[{"type_long":"java.lang.String","name":"path","comment":"symbol namespace path (path will be trimmed before parse)","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"order list of namespace names","type_short":"List"}},{"javadoc":"Get the library associated with the specified namespace\n@param namespace namespace\n@return associated library or null if not associated with a library","static":true,"name":"getLibrary","comment":"Get the library associated with the specified namespace","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"namespace","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Library","comment":"associated library or null if not associated with a library","type_short":"Library"}},{"javadoc":"Returns a list of namespaces that match the given path.  The path can be\n relative to the given root namespace or absolute if the path begins with\n the global namespace name.\n\n <P>Note: this path must only contain Namespace names and no other symbol types.\n@param namespacePath the path to the desired namespace.\n@param rootNamespace the namespace to use as the root for relative paths. If null, the\n \t\t  global namespace will be used.\n@param program the program to search.\n@return a list of namespaces that match the given path.","static":true,"name":"getNamespaces","comment":"Returns a list of namespaces that match the given path.  The path can be\n relative to the given root namespace or absolute if the path begins with\n the global namespace name.\n\n Note: this path must only contain Namespace names and no other symbol types.","params":[{"type_long":"java.lang.String","name":"namespacePath","comment":"the path to the desired namespace.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"rootNamespace","comment":"the namespace to use as the root for relative paths. If null, the\n \t\t  global namespace will be used.","type_short":"Namespace"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","comment":"a list of namespaces that match the given path.","type_short":"List"}},{"javadoc":"","static":true,"name":"doGetNamespaces","comment":"","params":[{"type_long":"java.util.List<java.lang.String>","name":"namespaceNames","comment":"","type_short":"List"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"rootNamespace","comment":"","type_short":"Namespace"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","comment":"","type_short":"List"}},{"javadoc":"Returns a list all namespaces that have the given name in any of the given namespaces.\n@param childName the name of the namespaces to retrieve.\n@param parents a list of all namespaces to search for child namespaces with the given name.\n@param program the program to search.\n@return a list all namespaces that have the given name in any of the given namespaces.","static":true,"name":"getMatchingNamespaces","comment":"Returns a list all namespaces that have the given name in any of the given namespaces.","params":[{"type_long":"java.lang.String","name":"childName","comment":"the name of the namespaces to retrieve.","type_short":"String"},{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","name":"parents","comment":"a list of all namespaces to search for child namespaces with the given name.","type_short":"List"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","comment":"a list all namespaces that have the given name in any of the given namespaces.","type_short":"List"}},{"javadoc":"Returns a list all symbols that have the given name in any of the given\n parent namespaces.\n@param parents a list of all namespaces to search for symbols with the given name.\n@param symbolName the name of the symbols to retrieve.\n@param program the program to search.\n@return a list all symbols that have the given name in any of the given namespaces.","static":true,"name":"searchForAllSymbolsInAnyOfTheseNamespaces","comment":"Returns a list all symbols that have the given name in any of the given\n parent namespaces.","params":[{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","name":"parents","comment":"a list of all namespaces to search for symbols with the given name.","type_short":"List"},{"type_long":"java.lang.String","name":"symbolName","comment":"the name of the symbols to retrieve.","type_short":"String"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"a list all symbols that have the given name in any of the given namespaces.","type_short":"List"}},{"javadoc":"Returns a list of all symbols that match the given path. The path consists of a series\n of namespaces names separated by \"::\" followed by a label or function name.\n@param symbolPath the names of namespaces and symbol separated by \"::\".\n@param program the program to search\n@return the list of symbols that match the given","static":true,"name":"getSymbols","comment":"Returns a list of all symbols that match the given path. The path consists of a series\n of namespaces names separated by \"::\" followed by a label or function name.","params":[{"type_long":"java.lang.String","name":"symbolPath","comment":"the names of namespaces and symbol separated by \"::\".","type_short":"String"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"the list of symbols that match the given","type_short":"List"}},{"javadoc":"Returns a list of Symbol that match the given symbolPath.\n@param symbolPath the symbol path that specifies a series of namespace and symbol names.\n@param program the program to search for symbols with the given path.\n@return a list of Symbol that match the given symbolPath.","static":true,"name":"getSymbols","comment":"Returns a list of Symbol that match the given symbolPath.","params":[{"type_long":"ghidra.app.util.SymbolPath","name":"symbolPath","comment":"the symbol path that specifies a series of namespace and symbol names.","type_short":"SymbolPath"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search for symbols with the given path.","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"a list of Symbol that match the given symbolPath.","type_short":"List"}},{"javadoc":"Returns a list of all namespaces with the given name in the parent namespace.\n@param parent the parent namespace from which to find all namespaces with the given name.\n@param namespaceName the name of the namespaces to retrieve.\n@param program the program to search.\n@return a list of all namespaces that match the given name in\n the given parent namespace.","static":true,"name":"getNamespaces","comment":"Returns a list of all namespaces with the given name in the parent namespace.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"parent","comment":"the parent namespace from which to find all namespaces with the given name.","type_short":"Namespace"},{"type_long":"java.lang.String","name":"namespaceName","comment":"the name of the namespaces to retrieve.","type_short":"String"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","comment":"a list of all namespaces that match the given name in\n the given parent namespace.","type_short":"List"}},{"javadoc":"Returns the first namespace with the given name and that is NOT a function that\n is within the parent namespace. (ie. the first namespace that is not tied to a program\n address)\n@param parent the parent namespace to search\n@param namespaceName the name of the namespace to find\n@param program the program to search.\n@return the first namespace that matches, or null if no match.","static":true,"name":"getFirstNonFunctionNamespace","comment":"Returns the first namespace with the given name and that is NOT a function that\n is within the parent namespace. (ie. the first namespace that is not tied to a program\n address)","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"parent","comment":"the parent namespace to search","type_short":"Namespace"},{"type_long":"java.lang.String","name":"namespaceName","comment":"the name of the namespace to find","type_short":"String"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"the first namespace that matches, or null if no match.","type_short":"Namespace"}},{"javadoc":"Takes a namespace path string and creates a namespace hierarchy to\n match that string.  This method ignores function namespaces so the path\n should not contain any function names.  If you want traverse down through\n functions, then use the version that also takes an address that is used to distinguish\n between multiple functions with the same name.\n <P>\n The root namespace can be a function.\n@param namespacePath The namespace name or path string to be parsed.\n         This value should not include a trailing symbol name, only namespace names.\n@param rootNamespace The parent namespace under which the desired\n         namespace or path resides.  If this value is null, then the\n         global namespace will be used. This namespace can be a function name;\n@param program The current program in which the desired namespace\n         resides.\n@param source the source type of the namespace\n@return The namespace that matches the given path.  This can be either an existing\n         namespace or a newly created one.\n@throws InvalidInputException If a given namespace name is in an\n         invalid format and this method attempts to create that\n         namespace, or if the namespace string contains the global\n         namespace name in a position other than the root.\n@see <a href=\"#assumptions\">assumptions<\/a>","static":true,"name":"createNamespaceHierarchy","comment":"Takes a namespace path string and creates a namespace hierarchy to\n match that string.  This method ignores function namespaces so the path\n should not contain any function names.  If you want traverse down through\n functions, then use the version that also takes an address that is used to distinguish\n between multiple functions with the same name.\n \n The root namespace can be a function.","params":[{"type_long":"java.lang.String","name":"namespacePath","comment":"The namespace name or path string to be parsed.\n         This value should not include a trailing symbol name, only namespace names.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"rootNamespace","comment":"The parent namespace under which the desired\n         namespace or path resides.  If this value is null, then the\n         global namespace will be used. This namespace can be a function name;","type_short":"Namespace"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"The current program in which the desired namespace\n         resides.","type_short":"Program"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source type of the namespace","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"If a given namespace name is in an\n         invalid format and this method attempts to create that\n         namespace, or if the namespace string contains the global\n         namespace name in a position other than the root.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"The namespace that matches the given path.  This can be either an existing\n         namespace or a newly created one.","type_short":"Namespace"}},{"javadoc":"Takes a namespace path string and creates a namespace hierarchy to\n match that string.  This method allows function namespaces in the path\n and uses the given address to resolve functions with duplicate names.  When\n resolving down the namespace path, a function that matches a name will only\n be used if the given address is contained in the body of that function.\n <P>\n The root namespace can be a function.\n@param namespacePath The namespace name or path string to be parsed.\n         This value should not include a trailing symbol name, only namespace names.\n@param rootNamespace The parent namespace under which the desired\n         namespace or path resides.  If this value is null, then the\n         global namespace will be used.\n@param program The current program in which the desired namespace\n         resides.\n@param address the address used to resolve possible functions with duplicate names.\n@param source the source of the namespace\n@return The namespace that matches the given path.  This can be either an existing\n         namespace or a newly created one.\n@throws InvalidInputException If a given namespace name is in an\n         invalid format and this method attempts to create that\n         namespace, or if the namespace string contains the global\n         namespace name in a position other than the root.\n@see <a href=\"#assumptions\">assumptions<\/a>","static":true,"name":"createNamespaceHierarchy","comment":"Takes a namespace path string and creates a namespace hierarchy to\n match that string.  This method allows function namespaces in the path\n and uses the given address to resolve functions with duplicate names.  When\n resolving down the namespace path, a function that matches a name will only\n be used if the given address is contained in the body of that function.\n \n The root namespace can be a function.","params":[{"type_long":"java.lang.String","name":"namespacePath","comment":"The namespace name or path string to be parsed.\n         This value should not include a trailing symbol name, only namespace names.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"rootNamespace","comment":"The parent namespace under which the desired\n         namespace or path resides.  If this value is null, then the\n         global namespace will be used.","type_short":"Namespace"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"The current program in which the desired namespace\n         resides.","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address used to resolve possible functions with duplicate names.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of the namespace","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"If a given namespace name is in an\n         invalid format and this method attempts to create that\n         namespace, or if the namespace string contains the global\n         namespace name in a position other than the root.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"The namespace that matches the given path.  This can be either an existing\n         namespace or a newly created one.","type_short":"Namespace"}},{"javadoc":"Finds the namespace for the given symbolPath.  Since this method\n takes an address, the symbolPath can contain a function name provided the address\n lives in the body of that function.\n@param program the program from which to get the namespace.\n@param symbolPath the path of namespace names including the name of the desired namespace.\n@param address the address used to determine if any function namespaces can be used\n        to resolve the path.  For a function to be used, it must contain this address in it's body.\n@return the namespace represented by the given path, or null if no such namespace exists.","static":true,"name":"getNamespace","comment":"Finds the namespace for the given symbolPath.  Since this method\n takes an address, the symbolPath can contain a function name provided the address\n lives in the body of that function.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program from which to get the namespace.","type_short":"Program"},{"type_long":"ghidra.app.util.SymbolPath","name":"symbolPath","comment":"the path of namespace names including the name of the desired namespace.","type_short":"SymbolPath"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address used to determine if any function namespaces can be used\n        to resolve the path.  For a function to be used, it must contain this address in it's body.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"the namespace represented by the given path, or null if no such namespace exists.","type_short":"Namespace"}},{"javadoc":"","static":true,"name":"getNamespace","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"parent","comment":"","type_short":"Namespace"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"","type_short":"Namespace"}},{"javadoc":"","static":true,"name":"adjustForNullRootNamespace","comment":"","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"parentNamespace","comment":"","type_short":"Namespace"},{"type_long":"java.lang.String","name":"namespacePath","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"","type_short":"Namespace"}},{"javadoc":"","static":true,"name":"validate","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"","type_short":"Namespace"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"validate","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"java.util.List<ghidra.program.model.symbol.Namespace>","name":"parents","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Convert a namespace to a class by copying all namespace children into a newly created class\n and then removing the old namespace.\n@param namespace namespace to be converted\n@return new class namespace\n@throws InvalidInputException if namespace was contained within a function and can not be\n converted to a class","static":true,"name":"convertNamespaceToClass","comment":"Convert a namespace to a class by copying all namespace children into a newly created class\n and then removing the old namespace.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"namespace to be converted","type_short":"Namespace"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if namespace was contained within a function and can not be\n converted to a class","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.listing.GhidraClass","comment":"new class namespace","type_short":"GhidraClass"}}],"name":"NamespaceUtils","comment":"A class to hold utility methods for working with namespaces.\n \n \n Example string format:\n \n     globalNamespace#NAMESPACE_DELIMITERchild1Namespace#NAMESPACE_DELIMITERchild2\n     child1\n \n \n Assumptions for creating namespaces from a path string: \n \n     All elements of a namespace path should be namespace symbols and not other\n         symbol types.\n     If the method takes an address, then the path can contain a function name provided\n         the address is in the body of the function; otherwise\n         the names must all be namespaces other than functions.\n     Absolute paths can optionally start with the global namespace.\n     You can provide a relative path that will start at the given\n         parent namespace (or global if there is no parent provided).\n     You can provide a path that has as its first entry the name of the\n         given parent.  In this case, the first entry will not be created,\n         but rather the provided parent will be used.\n     If you provide a path and a parent, but the first element of the\n         path is the global namespace, then the global namespace will be\n         used as the parent namespace and not the one that was provided.\n     You cannot embed the global namespace in a path, but it can be at\n         the root.\n ","fields":[]}
