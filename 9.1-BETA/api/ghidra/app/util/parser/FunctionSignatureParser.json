{"implements":[],"javadoc":"Class for parsing function signatures. This class attempts to be much more\n flexible than a full parser that requires correct C or C++ syntax. To achieve\n this, it scans the original function signature (if present) for names that\n would cause parse problems (parens, brackets, asterisk, commas, and spaces). \n If it finds any problem names, it looks for those strings in the text to be \n parsed and if it finds them, it replaces them with substitutes that parse \n easily. Then, after parsing, those replacement strings are then restored to \n their original values.\n <P>\n Some examples of valid c++ that would fail due to the current limitations:\n <P>\n void foo(myclass<int, float> x) - fails due to comma in x's data type name\n int operator()(int x) - fails due to parens in function name unsigned int\n bar(float y) - fails due to space in return type name\n <P>\n Note: you can edit signatures that already have these features as long as\n your modifications don't affect the pieces containing parens, commas or\n spaces in their name.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a SignatureParser for a program.  The destDataTypeManager and\/or\n service must be specified.\n@param destDataTypeManager the destination datatype maanger.\n@param service the DataTypeManagerService to use for resolving datatypes that\n                can't be found in the given program. Can be null to utilize\n                program based types only.","static":false,"name":"<init>","comment":"Constructs a SignatureParser for a program.  The destDataTypeManager and\/or\n service must be specified.","params":[{"type_long":"ghidra.program.model.data.DataTypeManager","name":"destDataTypeManager","comment":"the destination datatype maanger.","type_short":"DataTypeManager"},{"type_long":"ghidra.app.services.DataTypeQueryService","name":"service","comment":"the DataTypeManagerService to use for resolving datatypes that\n                can't be found in the given program. Can be null to utilize\n                program based types only.","type_short":"DataTypeQueryService"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Parse the given function signature text into a FunctionDefinitionDataType.\n@param originalSignature the function signature before editing. This may be\n                          null if the user is entering a new signature instead\n                          of editing an existing one.\n@param signatureText the text to be parsed into a function signature.\n@return the FunctionDefinitionDataType resulting from parsing.\n@throws ParseException if the text could not be parsed.\n@throws CancelledException if parse cancelled by user","static":false,"name":"parse","comment":"Parse the given function signature text into a FunctionDefinitionDataType.","params":[{"type_long":"ghidra.program.model.listing.FunctionSignature","name":"originalSignature","comment":"the function signature before editing. This may be\n                          null if the user is entering a new signature instead\n                          of editing an existing one.","type_short":"FunctionSignature"},{"type_long":"java.lang.String","name":"signatureText","comment":"the text to be parsed into a function signature.","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"if the text could not be parsed.","type_short":"ParseException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if parse cancelled by user","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.data.FunctionDefinitionDataType","comment":"the FunctionDefinitionDataType resulting from parsing.","type_short":"FunctionDefinitionDataType"}},{"javadoc":"","static":false,"name":"initDataTypeMap","comment":"","params":[{"type_long":"ghidra.program.model.listing.FunctionSignature","name":"signature","comment":"","type_short":"FunctionSignature"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cacheDataType","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"hasVarArgs","comment":"","params":[{"type_long":"java.lang.String","name":"newSignatureText","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"extractArguments","comment":"","params":[{"type_long":"java.lang.String","name":"newSignatureText","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"","type_short":"ParseException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.data.ParameterDefinition[]","comment":"","type_short":"ghidra.program.model.data.ParameterDefinition[]"}},{"javadoc":"","static":false,"name":"addParameter","comment":"","params":[{"type_long":"java.util.List<ghidra.program.model.data.ParameterDefinition>","name":"parameterList","comment":"","type_short":"List"},{"type_long":"java.lang.String","name":"arg","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"","type_short":"ParseException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cleanUpSignatureText","comment":"","params":[{"type_long":"java.lang.String","name":"text","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.listing.FunctionSignature","name":"signature","comment":"","type_short":"FunctionSignature"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"replaceDataTypeIfNeeded","comment":"","params":[{"type_long":"java.lang.String","name":"text","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"},{"type_long":"java.lang.String","name":"replacementName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"replaceNameIfNeeded","comment":"","params":[{"type_long":"java.lang.String","name":"text","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"replacementName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"extractReturnType","comment":"","params":[{"type_long":"java.lang.String","name":"signatureText","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"","type_short":"ParseException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"","static":false,"name":"resolveDataType","comment":"","params":[{"type_long":"java.lang.String","name":"dataTypeName","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"","static":false,"name":"extractFunctionName","comment":"","params":[{"type_long":"java.lang.String","name":"signatureText","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"","type_short":"ParseException"}],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"resolveName","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.app.util.cparser.C.ParseException","comment":"","type_short":"ParseException"}],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"substitute","comment":"","params":[{"type_long":"java.lang.String","name":"text","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"searchString","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"replacementString","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"canParse","comment":"","params":[{"type_long":"java.lang.String","name":"text","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"FunctionSignatureParser","comment":"Class for parsing function signatures. This class attempts to be much more\n flexible than a full parser that requires correct C or C++ syntax. To achieve\n this, it scans the original function signature (if present) for names that\n would cause parse problems (parens, brackets, asterisk, commas, and spaces). \n If it finds any problem names, it looks for those strings in the text to be \n parsed and if it finds them, it replaces them with substitutes that parse \n easily. Then, after parsing, those replacement strings are then restored to \n their original values.\n \n Some examples of valid c++ that would fail due to the current limitations:\n \n void foo(myclassint, float x) - fails due to comma in x's data type name\n int operator()(int x) - fails due to parens in function name unsigned int\n bar(float y) - fails due to space in return type name\n \n Note: you can edit signatures that already have these features as long as\n your modifications don't affect the pieces containing parens, commas or\n spaces in their name.","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"REPLACEMENT_DT_NAME","comment":"","type_short":"String","constant_value":"\"__REPLACE_DT_NAME__\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"REPLACE_NAME","comment":"","type_short":"String","constant_value":"\"__REPLACE_NAME__\""},{"type_long":"ghidra.util.data.DataTypeParser","javadoc":"","static":false,"name":"dataTypeParser","comment":"","type_short":"DataTypeParser","constant_value":null},{"type_long":"java.util.Map<java.lang.String,ghidra.program.model.data.DataType>","javadoc":"","static":false,"name":"dtMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<java.lang.String,java.lang.String>","javadoc":"","static":false,"name":"nameMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeManager","javadoc":"","static":false,"name":"destDataTypeManager","comment":"","type_short":"DataTypeManager","constant_value":null},{"type_long":"ghidra.app.util.parser.FunctionSignatureParser.ParserDataTypeManagerService","javadoc":"","static":false,"name":"dtmService","comment":"","type_short":"ParserDataTypeManagerService","constant_value":null},{"type_long":"java.util.regex.Pattern","javadoc":"","static":true,"name":"parameterNameCapturePattern","comment":"","type_short":"Pattern","constant_value":null}]}
