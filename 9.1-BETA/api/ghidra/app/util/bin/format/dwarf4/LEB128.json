{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Decode a LEB128 signed number and return it as a java 32 bit int.\n <p>\n If the value of the number can not fit in the int type, an {@link IOException} will\n be thrown.\n@param reader\n@return \n@throws IOException","static":true,"name":"decode32s","comment":"Decode a LEB128 signed number and return it as a java 32 bit int.\n \n If the value of the number can not fit in the int type, an IOException will\n be thrown.","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"","type_short":"BinaryReader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Decode a LEB128 unsigned number and return it as a java 32 bit int.\n <p>\n If the value of the number can not fit in the positive range of the int type,\n an {@link IOException} will be thrown.\n@param reader\n@return \n@throws IOException","static":true,"name":"decode32u","comment":"Decode a LEB128 unsigned number and return it as a java 32 bit int.\n \n If the value of the number can not fit in the positive range of the int type,\n an IOException will be thrown.","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"","type_short":"BinaryReader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Decodes a LEB128 number using a binary reader and stores it in a long.\n <p>\n Large unsigned integers that use 64 bits will be returned in java's native\n 'long' type, which is signed.  It is up to the caller to treat the value as unsigned.\n <p>\n Large integers that use more than 64 bits will cause an IOException to be thrown.\n <p>\n@param reader the binary reader\n@param isSigned true if the value is signed\n@throws IOException if an I\/O error occurs","static":true,"name":"decode","comment":"Decodes a LEB128 number using a binary reader and stores it in a long.\n \n Large unsigned integers that use 64 bits will be returned in java's native\n 'long' type, which is signed.  It is up to the caller to treat the value as unsigned.\n \n Large integers that use more than 64 bits will cause an IOException to be thrown.\n ","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"the binary reader","type_short":"BinaryReader"},{"type_long":"boolean","name":"isSigned","comment":"true if the value is signed","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Decodes a LEB128 number using a byte array and stores it in a long.\n This function cannot read numbers larger than Long.MAX_VALUE.\n@param bytes the bytes representing the LEB128 number\n@param isSigned true if the value is signed\n@throws IOException","static":true,"name":"decode","comment":"Decodes a LEB128 number using a byte array and stores it in a long.\n This function cannot read numbers larger than Long.MAX_VALUE.","params":[{"type_long":"byte[]","name":"bytes","comment":"the bytes representing the LEB128 number","type_short":"byte[]"},{"type_long":"boolean","name":"isSigned","comment":"true if the value is signed","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Decodes a LEB128 number using an offset into a byte array and stores it in a long.\n This function cannot read numbers larger than Long.MAX_VALUE.\n@param bytes the bytes representing the LEB128 number\n@param offset offset into the byte array\n@param isSigned true if the value is signed\n@throws IOException","static":true,"name":"decode","comment":"Decodes a LEB128 number using an offset into a byte array and stores it in a long.\n This function cannot read numbers larger than Long.MAX_VALUE.","params":[{"type_long":"byte[]","name":"bytes","comment":"the bytes representing the LEB128 number","type_short":"byte[]"},{"type_long":"int","name":"offset","comment":"offset into the byte array","type_short":"int"},{"type_long":"boolean","name":"isSigned","comment":"true if the value is signed","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}}],"name":"LEB128","comment":"","fields":[]}
