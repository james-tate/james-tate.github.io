{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Converts a integer value to its corresponding symbolic name from the set of\n \"public static final\" member variables in a class.\n <p>\n This is a bit of a hack and probably originated from pre-java Enum days.\n@param clazz The {@link Class} to search for the matching static value.\n@param value the integer value to search for\n@return the String name of the matching field.","static":true,"name":"toString","comment":"Converts a integer value to its corresponding symbolic name from the set of\n \"public static final\" member variables in a class.\n \n This is a bit of a hack and probably originated from pre-java Enum days.","params":[{"type_long":"java.lang.Class<?>","name":"clazz","comment":"The Class to search for the matching static value.","type_short":"Class"},{"type_long":"int","name":"value","comment":"the integer value to search for","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the String name of the matching field.","type_short":"String"}},{"javadoc":"Returns the field name of a final static variable in class <code>clazz<\/code>\n which holds a specific value.\n <p>\n Can be thought of as an enum numeric value to to name lookup.\n <p>\n@param clazz\n@param value\n@return ","static":true,"name":"toString","comment":"Returns the field name of a final static variable in class clazz\n which holds a specific value.\n \n Can be thought of as an enum numeric value to to name lookup.\n ","params":[{"type_long":"java.lang.Class<?>","name":"clazz","comment":"","type_short":"Class"},{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Searches a Class for a final static variable that has a specific numeric value.\n@param clazz Class to search.\n@param value numeric value to search for\n@return Java reflection {@link Field} that has the specified value or null","static":true,"name":"getStaticFinalFieldWithValue","comment":"Searches a Class for a final static variable that has a specific numeric value.","params":[{"type_long":"java.lang.Class<?>","name":"clazz","comment":"Class to search.","type_short":"Class"},{"type_long":"long","name":"value","comment":"numeric value to search for","type_short":"long"}],"throws":[],"return":{"type_long":"java.lang.reflect.Field","comment":"Java reflection Field that has the specified value or null","type_short":"Field"}},{"javadoc":"Returns a string that describes what kind of object is specified by the {@link DIEAggregate}.\n <p>\n Used to create a name for anonymous types.\n@param diea {@link DIEAggregate}\n@return String describing the type of the DIEA.","static":true,"name":"getContainerTypeName","comment":"Returns a string that describes what kind of object is specified by the DIEAggregate.\n \n Used to create a name for anonymous types.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"DIEAggregate","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"String describing the type of the DIEA.","type_short":"String"}},{"javadoc":"Returns the {@link SymbolType} that corresponds to the specified {@link DIEAggregate}.\n <p>\n The mapping between DIE type and SymbolType is not exact.  There is no matching\n SymbolType for a DWARF static variable, so \"LOCAL_VAR\" is used currently.\n <p>\n This mainly is used in constructing a NamespacePath, and the only critical usage\n there is Namespace vs. Class vs. everything else.\n@param diea {@link DIEAggregate} to query\n@return {@link SymbolType}","static":true,"name":"getSymbolTypeFromDIE","comment":"Returns the SymbolType that corresponds to the specified DIEAggregate.\n \n The mapping between DIE type and SymbolType is not exact.  There is no matching\n SymbolType for a DWARF static variable, so \"LOCAL_VAR\" is used currently.\n \n This mainly is used in constructing a NamespacePath, and the only critical usage\n there is Namespace vs. Class vs. everything else.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"DIEAggregate to query","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolType","comment":"SymbolType","type_short":"SymbolType"}},{"javadoc":"A lightweight attempt to get nesting (ie. namespaces and such) information\n from gnu mangled name strings.\n <p>\n For example, \"_ZN19class1_inline_funcs3fooEv\" ->\n [19 chars]'class1_inline_funcs', [3 chars]'foo'\n <p>\n@param s\n@return ","static":true,"name":"parseMangledNestings","comment":"A lightweight attempt to get nesting (ie. namespaces and such) information\n from gnu mangled name strings.\n \n For example, \"_ZN19class1_inline_funcs3fooEv\" -\n [19 chars]'class1_inline_funcs', [3 chars]'foo'\n ","params":[{"type_long":"java.lang.String","name":"s","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"","type_short":"List"}},{"javadoc":"Try to find gnu mangled name nesting info in a DIE's children's linkage strings.\n <p>\n@param die\n@return a list of string of nesting names, ending with what should be the DIE parameter's\n name.","static":true,"name":"findLinkageNameInChildren","comment":"Try to find gnu mangled name nesting info in a DIE's children's linkage strings.\n ","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DebugInfoEntry","name":"die","comment":"","type_short":"DebugInfoEntry"}],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"a list of string of nesting names, ending with what should be the DIE parameter's\n name.","type_short":"List"}},{"javadoc":"Determines if a name is a C++ style templated name.  If so, returns just\n the base portion of the name.\n The name must have a start and end angle bracket: '&lt;' and '&gt;'.\n <p>\n operator&lt;() and operator&lt;&lt;() are handled so their angle brackets\n don't trigger the template start\/end angle bracket incorrectly.\n <p>\n@param name symbol name with C++ template portions\n@return base portion of the symbol name without template portion","static":true,"name":"getTemplateBaseName","comment":"Determines if a name is a C++ style templated name.  If so, returns just\n the base portion of the name.\n The name must have a start and end angle bracket: '' and ''.\n \n operator() and operator() are handled so their angle brackets\n don't trigger the template start\/end angle bracket incorrectly.\n ","params":[{"type_long":"java.lang.String","name":"name","comment":"symbol name with C++ template portions","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"base portion of the symbol name without template portion","type_short":"String"}},{"javadoc":"Creates a name for anon types based on their position in their parent's childList.\n <p>\n@param die\n@return ","static":true,"name":"getAnonNameForMeFromParentContext","comment":"Creates a name for anon types based on their position in their parent's childList.\n ","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Creates a name for anon types based on the names of sibling entries that are using the anon type.\n <p>\n Example: \"anon_struct_for_field1_field2\"\n <p>\n Falls back to {@link #getAnonNameForMeFromParentContext(DebugInfoEntry)} if no siblings found.\n@param die\n@return ","static":true,"name":"getAnonNameForMeFromParentContext2","comment":"Creates a name for anon types based on the names of sibling entries that are using the anon type.\n \n Example: \"anon_struct_for_field1_field2\"\n \n Falls back to #getAnonNameForMeFromParentContext(DebugInfoEntry) if no siblings found.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Create a name for a lexical block, with \"_\" separated numbers indicating nesting\n information of the lexical block.\n@param diea {@link DIEAggregate} pointing to a lexical block entry.\n@return string, ie. \"lexical_block_1_2_3\"","static":true,"name":"getLexicalBlockName","comment":"Create a name for a lexical block, with \"_\" separated numbers indicating nesting\n information of the lexical block.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"DIEAggregate pointing to a lexical block entry.","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"string, ie. \"lexical_block_1_2_3\"","type_short":"String"}},{"javadoc":"","static":true,"name":"getLexicalBlockNameWorker","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DebugInfoEntry","name":"die","comment":"","type_short":"DebugInfoEntry"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns the ordinal position of this {@link DebugInfoEntry} in it's parent.\n@param die {@link DebugInfoEntry}\n@return int index of ourself in our parent, or -1 if not found in parent.","static":true,"name":"getMyPositionInParent","comment":"Returns the ordinal position of this DebugInfoEntry in it's parent.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DebugInfoEntry","name":"die","comment":"DebugInfoEntry","type_short":"DebugInfoEntry"}],"throws":[],"return":{"type_long":"int","comment":"int index of ourself in our parent, or -1 if not found in parent.","type_short":"int"}},{"javadoc":"Append a string to a {@link DataType}'s description.\n@param dt {@link DataType}\n@param description string to append, if null or empty nothing happens.\n@param sep characters to place after previous description to separate it from the\n new portion.","static":true,"name":"appendDescription","comment":"Append a string to a DataType's description.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"DataType","type_short":"DataType"},{"type_long":"java.lang.String","name":"description","comment":"string to append, if null or empty nothing happens.","type_short":"String"},{"type_long":"java.lang.String","name":"sep","comment":"characters to place after previous description to separate it from the\n new portion.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Append a string to a description of a field in a structure.\n@param dtc the {@link DataTypeComponent field} in a struct\n@param description string to append, if null or empty nothing happens.\n@param sep characters to place after previous description to separate it from the\n new portion.","static":true,"name":"appendDescription","comment":"Append a string to a description of a field in a structure.","params":[{"type_long":"ghidra.program.model.data.DataTypeComponent","name":"dtc","comment":"the DataTypeComponent in a struct","type_short":"DataTypeComponent"},{"type_long":"java.lang.String","name":"description","comment":"string to append, if null or empty nothing happens.","type_short":"String"},{"type_long":"java.lang.String","name":"sep","comment":"characters to place after previous description to separate it from the\n new portion.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Read an offset value who's size depends on the DWARF format: 32 vs 64.\n <p>\n@param reader BinaryReader pointing to the value to read\n@param dwarfFormat - See {@link DWARFCompilationUnit#DWARF_32} and {@link DWARFCompilationUnit#DWARF_64}.\n@return the offset value\n@throws IOException if an I\/O error occurs or bad dwarfFormat value","static":true,"name":"readOffsetByDWARFformat","comment":"Read an offset value who's size depends on the DWARF format: 32 vs 64.\n ","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"BinaryReader pointing to the value to read","type_short":"BinaryReader"},{"type_long":"int","name":"dwarfFormat","comment":"- See DWARFCompilationUnit#DWARF_32 and DWARFCompilationUnit#DWARF_64.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs or bad dwarfFormat value","type_short":"IOException"}],"return":{"type_long":"long","comment":"the offset value","type_short":"long"}},{"javadoc":"Read a variable-sized unsigned integer and return it as a java signed long.\n <p>\n@param reader {@link BinaryReader} to read the data from\n@param pointerSize number of bytes the value is stored in, must be 1, 2, 4, or 8.\n@return unsigned long integer value.\n@throws IOException if error","static":true,"name":"readVarSizedULong","comment":"Read a variable-sized unsigned integer and return it as a java signed long.\n ","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"BinaryReader to read the data from","type_short":"BinaryReader"},{"type_long":"int","name":"pointerSize","comment":"number of bytes the value is stored in, must be 1, 2, 4, or 8.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"}],"return":{"type_long":"long","comment":"unsigned long integer value.","type_short":"long"}},{"javadoc":"Read a variable-sized unsigned integer and return it as a java signed int.\n <p>\n Unsigned 32 bit int values larger than java's signed Integer.MAX_VALUE are not\n supported and will throw an IOException.\n@param reader {@link BinaryReader} to read the data from\n@param size number of bytes the integer value is stored in, must be 1, 2 or 4.\n@return unsigned integer value.\n@throws IOException if error","static":true,"name":"readVarSizedUInt","comment":"Read a variable-sized unsigned integer and return it as a java signed int.\n \n Unsigned 32 bit int values larger than java's signed Integer.MAX_VALUE are not\n supported and will throw an IOException.","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"BinaryReader to read the data from","type_short":"BinaryReader"},{"type_long":"int","name":"size","comment":"number of bytes the integer value is stored in, must be 1, 2 or 4.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"}],"return":{"type_long":"int","comment":"unsigned integer value.","type_short":"int"}},{"javadoc":"Read the value of an address.\n@param reader BinaryReader pointing to the value to read\n@param pointerSize the size of a pointer\n@return the address value\n@throws IOException if an I\/O error occurs\n@throws IllegalArgumentException if an unknown pointer size is given","static":true,"name":"readAddress","comment":"Read the value of an address.","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"BinaryReader pointing to the value to read","type_short":"BinaryReader"},{"type_long":"byte","name":"pointerSize","comment":"the size of a pointer","type_short":"byte"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs","type_short":"IOException"}],"return":{"type_long":"java.lang.Number","comment":"the address value","type_short":"Number"}},{"javadoc":"Reads a variable-sized unsigned 'address' value from a {@link BinaryReader} and\n returns it as a 64 bit java long.\n <p>\n The valid pointerSizes are 1, 2, 4, and 8.\n <p>\n@param reader {@link BinaryReader} to read the data from\n@param pointerSize number of bytes the value is stored in, must be 1, 2, 4, or 8.\n@return unsigned long value.\n@throws IOException if error","static":true,"name":"readAddressAsLong","comment":"Reads a variable-sized unsigned 'address' value from a BinaryReader and\n returns it as a 64 bit java long.\n \n The valid pointerSizes are 1, 2, 4, and 8.\n ","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"BinaryReader to read the data from","type_short":"BinaryReader"},{"type_long":"byte","name":"pointerSize","comment":"number of bytes the value is stored in, must be 1, 2, 4, or 8.","type_short":"byte"}],"throws":[{"type_long":"java.io.IOException","comment":"if error","type_short":"IOException"}],"return":{"type_long":"long","comment":"unsigned long value.","type_short":"long"}},{"javadoc":"","static":true,"name":"isThisParam","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"paramDIEA","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the {@link DIEAggregate} of a typedef that points to the specified datatype.\n <p>\n Returns null if there is no typedef pointing to the specified DIEA or if there are\n multiple.\n@param diea {@link DIEAggregate} of a data type that might be the target of typedefs.\n@return {@link DIEAggregate} of the singular typedef that points to the arg, otherwise\n null if none or multiple found.","static":true,"name":"getReferringTypedef","comment":"Returns the DIEAggregate of a typedef that points to the specified datatype.\n \n Returns null if there is no typedef pointing to the specified DIEA or if there are\n multiple.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"DIEAggregate of a data type that might be the target of typedefs.","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","comment":"DIEAggregate of the singular typedef that points to the arg, otherwise\n null if none or multiple found.","type_short":"DIEAggregate"}}],"name":"DWARFUtil","comment":"","fields":[{"type_long":"java.util.regex.Pattern","javadoc":"","static":true,"name":"MANGLED_NESTING_REGEX","comment":"","type_short":"Pattern","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"OPERATOR_LT_STR","comment":"","type_short":"String","constant_value":"\"operator<\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"OPERATOR_LSHIFT_STR","comment":"","type_short":"String","constant_value":"\"operator<<\""}]}
