{"implements":["ghidra.app.util.bin.StructConverter","ghidra.app.util.bin.format.Writeable"],"javadoc":"A class to represent the Executable and Linking Format (ELF)\n header and specification.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a new ELF header using the specified byte provider.\n@param provider the byte provider to supply the bytes\n@throws ElfException if the underlying bytes in the byte provider \n do not constitute a valid ELF.","static":true,"name":"createElfHeader","comment":"Constructs a new ELF header using the specified byte provider.","params":[{"type_long":"generic.continues.GenericFactory","name":"factory","comment":"","type_short":"GenericFactory"},{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"the byte provider to supply the bytes","type_short":"ByteProvider"}],"throws":[{"type_long":"ghidra.app.util.bin.format.elf.ElfException","comment":"if the underlying bytes in the byte provider \n do not constitute a valid ELF.","type_short":"ElfException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","comment":"","type_short":"ElfHeader"}},{"javadoc":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","static":false,"name":"<init>","comment":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the binary reader.\n@return the binary reader","static":false,"name":"getReader","comment":"Returns the binary reader.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.BinaryReader","comment":"the binary reader","type_short":"BinaryReader"}},{"javadoc":"","static":false,"name":"initElfHeader","comment":"","params":[{"type_long":"generic.continues.GenericFactory","name":"factory","comment":"","type_short":"GenericFactory"},{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"","type_short":"ByteProvider"}],"throws":[{"type_long":"ghidra.app.util.bin.format.elf.ElfException","comment":"","type_short":"ElfException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"initElfLoadAdapter","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parse","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the installed extension provider.  If the parse method has not yet been \n invoked, the default adapter will be returned.\n@return ELF load adapter","static":false,"name":"getLoadAdapter","comment":"Get the installed extension provider.  If the parse method has not yet been \n invoked, the default adapter will be returned.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.extend.ElfLoadAdapter","comment":"ELF load adapter","type_short":"ElfLoadAdapter"}},{"javadoc":"Adjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  Standard GNU\/Linux pre-linked \n shared libraries have adjusted header entries and this method should have no effect.\n@param address\n@return address with appropriate pre-link adjustment added","static":false,"name":"adjustAddressForPrelink","comment":"Adjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  Standard GNU\/Linux pre-linked \n shared libraries have adjusted header entries and this method should have no effect.","params":[{"type_long":"long","name":"address","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"long","comment":"address with appropriate pre-link adjustment added","type_short":"long"}},{"javadoc":"Unadjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  This may be needed when updating\n a header address field which requires pre-link adjustment.\n@param address\n@return address with appropriate pre-link adjustment subtracted","static":false,"name":"unadjustAddressForPrelink","comment":"Unadjust address offset for certain pre-linked binaries which do not adjust certain\n header fields (e.g., dynamic table address entries).  This may be needed when updating\n a header address field which requires pre-link adjustment.","params":[{"type_long":"long","name":"address","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"long","comment":"address with appropriate pre-link adjustment subtracted","type_short":"long"}},{"javadoc":"","static":false,"name":"getProgramHeaderTypeMap","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfProgramHeaderType>","comment":"","type_short":"HashMap"}},{"javadoc":"","static":false,"name":"getSectionHeaderTypeMap","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfSectionHeaderType>","comment":"","type_short":"HashMap"}},{"javadoc":"","static":false,"name":"getProgramHeaderType","comment":"","params":[{"type_long":"int","name":"type","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeaderType","comment":"","type_short":"ElfProgramHeaderType"}},{"javadoc":"","static":false,"name":"getSectionHeaderType","comment":"","params":[{"type_long":"int","name":"type","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeaderType","comment":"","type_short":"ElfSectionHeaderType"}},{"javadoc":"","static":false,"name":"getDynamicTypeMap","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfDynamicType>","comment":"","type_short":"HashMap"}},{"javadoc":"","static":false,"name":"getDynamicType","comment":"","params":[{"type_long":"int","name":"type","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfDynamicType","comment":"","type_short":"ElfDynamicType"}},{"javadoc":"","static":false,"name":"getTypeSuffix","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"parseGNU_d","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseGNU_r","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseRelocationTables","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseSectionBasedRelocationTable","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"","type_short":"ElfSectionHeader"},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.elf.ElfRelocationTable>","name":"relocationTableList","comment":"","type_short":"ArrayList"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseJMPRelocTable","comment":"","params":[{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.elf.ElfRelocationTable>","name":"relocationTableList","comment":"","type_short":"ArrayList"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseDynamicRelocTable","comment":"","params":[{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.elf.ElfRelocationTable>","name":"relocationTableList","comment":"","type_short":"ArrayList"},{"type_long":"ghidra.app.util.bin.format.elf.ElfDynamicType","name":"relocTableAddrType","comment":"","type_short":"ElfDynamicType"},{"type_long":"ghidra.app.util.bin.format.elf.ElfDynamicType","name":"relocEntrySizeType","comment":"","type_short":"ElfDynamicType"},{"type_long":"ghidra.app.util.bin.format.elf.ElfDynamicType","name":"relocTableSizeType","comment":"","type_short":"ElfDynamicType"},{"type_long":"boolean","name":"addendTypeReloc","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get linked section\n@param sectionIndex\n@param expectedTypes list of expectedTypes (may be omitted to accept any type)\n@return section or null if not found","static":false,"name":"getLinkedSection","comment":"Get linked section","params":[{"type_long":"int","name":"sectionIndex","comment":"","type_short":"int"},{"type_long":"int[]","name":"expectedTypes","comment":"list of expectedTypes (may be omitted to accept any type)","type_short":"int[]"}],"throws":[{"type_long":"ghidra.util.exception.NotFoundException","comment":"","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"section or null if not found","type_short":"ElfSectionHeader"}},{"javadoc":"","static":false,"name":"parseDynamicLibraryNames","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseDynamicTable","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseStringTables","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseDynamicStringTable","comment":"","params":[{"type_long":"long","name":"dynamicStringTableAddr","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfStringTable","comment":"","type_short":"ElfStringTable"}},{"javadoc":"","static":false,"name":"parseSymbolTables","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseDynamicSymbolTable","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbolTable","comment":"","type_short":"ElfSymbolTable"}},{"javadoc":"Walk DT_GNU_HASH table to determine dynamic symbol count\n@param DT_GNU_HASH table file offset\n@return dynamic symbol count\n@throws IOException file read error","static":false,"name":"deriveGnuHashDynamicSymbolCount","comment":"Walk DT_GNU_HASH table to determine dynamic symbol count","params":[{"type_long":"long","name":"gnuHashTableOffset","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"file read error","type_short":"IOException"}],"return":{"type_long":"int","comment":"dynamic symbol count","type_short":"int"}},{"javadoc":"","static":false,"name":"parseSectionHeaders","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"parseProgramHeaders","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if this ELF was created for a big endian processor.\n@return true if this ELF was created for a big endian processor","static":false,"name":"isBigEndian","comment":"Returns true if this ELF was created for a big endian processor.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this ELF was created for a big endian processor","type_short":"boolean"}},{"javadoc":"Returns true if this ELF was created for a little endian processor.\n@return true if this ELF was created for a little endian processor","static":false,"name":"isLittleEndian","comment":"Returns true if this ELF was created for a little endian processor.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this ELF was created for a little endian processor","type_short":"boolean"}},{"javadoc":"Returns true if this ELF was created for a 32-bit processor.\n@return true if this ELF was created for a 32-bit processor","static":false,"name":"is32Bit","comment":"Returns true if this ELF was created for a 32-bit processor.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this ELF was created for a 32-bit processor","type_short":"boolean"}},{"javadoc":"Returns true if this ELF was created for a 64-bit processor.\n@return true if this ELF was created for a 64-bit processor","static":false,"name":"is64Bit","comment":"Returns true if this ELF was created for a 64-bit processor.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this ELF was created for a 64-bit processor","type_short":"boolean"}},{"javadoc":"Inspect the Elf image and determine the default image base prior \n to the {@link #parse()} method being invoked (i.e., only the main Elf\n header structure has been parsed).\n The image base is the virtual address of the PT_LOAD program header\n with the smallest address or 0 if no program headers exist.  By default,\n the image base address should be treated as a addressable unit offset.\n@return preferred image base","static":false,"name":"findImageBase","comment":"Inspect the Elf image and determine the default image base prior \n to the #parse() method being invoked (i.e., only the main Elf\n header structure has been parsed).\n The image base is the virtual address of the PT_LOAD program header\n with the smallest address or 0 if no program headers exist.  By default,\n the image base address should be treated as a addressable unit offset.","params":[],"throws":[],"return":{"type_long":"long","comment":"preferred image base","type_short":"long"}},{"javadoc":"Returns the image base of this ELF. \n The image base is the virtual address of the first PT_LOAD\n program header or 0 if no program headers. By default,\n the image base address should be treated as a addressable unit offset.s\n@return the image base of this ELF","static":false,"name":"getImageBase","comment":"Returns the image base of this ELF. \n The image base is the virtual address of the first PT_LOAD\n program header or 0 if no program headers. By default,\n the image base address should be treated as a addressable unit offset.s","params":[],"throws":[],"return":{"type_long":"long","comment":"the image base of this ELF","type_short":"long"}},{"javadoc":"Determine if the image has been pre-linked.\n NOTE: Currently has very limited support.  Certain pre-link\n cases can not be detected until after a full parse has been \n performed.\n@return true if image has been pre-linked","static":false,"name":"isPreLinked","comment":"Determine if the image has been pre-linked.\n NOTE: Currently has very limited support.  Certain pre-link\n cases can not be detected until after a full parse has been \n performed.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if image has been pre-linked","type_short":"boolean"}},{"javadoc":"Some elfs can get pre-linked to an OS.\n     At the very end a \"PRE \" string is appended with the image base load address\n     set.  Try there if none of the images told us where to load.\n@return -1 - if the imagebase is not a pre-link image base.","static":false,"name":"getPreLinkImageBase","comment":"Some elfs can get pre-linked to an OS.\n     At the very end a \"PRE \" string is appended with the image base load address\n     set.  Try there if none of the images told us where to load.","params":[],"throws":[],"return":{"type_long":"long","comment":"-1 - if the imagebase is not a pre-link image base.","type_short":"long"}},{"javadoc":"","static":false,"name":"isSectionLoaded","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"determineHeaderEndianess","comment":"","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"","type_short":"ByteProvider"}],"throws":[{"type_long":"ghidra.app.util.bin.format.elf.ElfException","comment":"","type_short":"ElfException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This member holds the ELF header's size in bytes.\n@return the ELF header's size in bytes","static":false,"name":"e_ehsize","comment":"This member holds the ELF header's size in bytes.","params":[],"throws":[],"return":{"type_long":"short","comment":"the ELF header's size in bytes","type_short":"short"}},{"javadoc":"This member gives the virtual address to which the system first transfers control, thus\n starting the process. If the file has no associated entry point, this member holds zero.\n@return the virtual address to which the system first transfers control","static":false,"name":"e_entry","comment":"This member gives the virtual address to which the system first transfers control, thus\n starting the process. If the file has no associated entry point, this member holds zero.","params":[],"throws":[],"return":{"type_long":"long","comment":"the virtual address to which the system first transfers control","type_short":"long"}},{"javadoc":"This member holds processor-specific flags associated with the file. Flag names take\n the form EF_machine_flag.\n@return the processor-specific flags associated with the file\n@see ElfConstants for flag definitions","static":false,"name":"e_flags","comment":"This member holds processor-specific flags associated with the file. Flag names take\n the form EF_machine_flag.","params":[],"throws":[],"return":{"type_long":"int","comment":"the processor-specific flags associated with the file","type_short":"int"}},{"javadoc":"This member's value specifies the required architecture for an individual file.\n@return the required architecture for an individual file\n@see ElfConstants for machine definitions","static":false,"name":"e_machine","comment":"This member's value specifies the required architecture for an individual file.","params":[],"throws":[],"return":{"type_long":"short","comment":"the required architecture for an individual file","type_short":"short"}},{"javadoc":"This member holds the size in bytes of one entry in the file's program header table;\n all entries are the same size.\n@return the size in bytes of one program header table entry","static":false,"name":"e_phentsize","comment":"This member holds the size in bytes of one entry in the file's program header table;\n all entries are the same size.","params":[],"throws":[],"return":{"type_long":"short","comment":"the size in bytes of one program header table entry","type_short":"short"}},{"javadoc":"This member holds the number of entries in the program header table. Thus the product\n of e_phentsize and e_phnum gives the table's size in bytes. If a file has no program\n header table, e_phnum holds the value zero.\n@return the number of entries in the program header table","static":false,"name":"e_phnum","comment":"This member holds the number of entries in the program header table. Thus the product\n of e_phentsize and e_phnum gives the table's size in bytes. If a file has no program\n header table, e_phnum holds the value zero.","params":[],"throws":[],"return":{"type_long":"short","comment":"the number of entries in the program header table","type_short":"short"}},{"javadoc":"This member holds the program header table's file offset in bytes. If the file has no\n program header table, this member holds zero.\n@return the program header table's file offset in bytes","static":false,"name":"e_phoff","comment":"This member holds the program header table's file offset in bytes. If the file has no\n program header table, this member holds zero.","params":[],"throws":[],"return":{"type_long":"long","comment":"the program header table's file offset in bytes","type_short":"long"}},{"javadoc":"This member holds the section header's size in bytes. A section header is one entry in\n the section header table; all entries are the same size.\n@return the section header's size in bytes","static":false,"name":"e_shentsize","comment":"This member holds the section header's size in bytes. A section header is one entry in\n the section header table; all entries are the same size.","params":[],"throws":[],"return":{"type_long":"short","comment":"the section header's size in bytes","type_short":"short"}},{"javadoc":"This member holds the number of entries in the section header table. Thus the product\n of e_shentsize and e_shnum gives the section header table's size in bytes. If a file\n has no section header table, e_shnum holds the value zero.\n@return the number of entries in the section header table","static":false,"name":"e_shnum","comment":"This member holds the number of entries in the section header table. Thus the product\n of e_shentsize and e_shnum gives the section header table's size in bytes. If a file\n has no section header table, e_shnum holds the value zero.","params":[],"throws":[],"return":{"type_long":"short","comment":"the number of entries in the section header table","type_short":"short"}},{"javadoc":"This member holds the section header table's file offset in bytes. If the file has no section\n header table, this member holds zero.\n@return the section header table's file offset in bytes","static":false,"name":"e_shoff","comment":"This member holds the section header table's file offset in bytes. If the file has no section\n header table, this member holds zero.","params":[],"throws":[],"return":{"type_long":"long","comment":"the section header table's file offset in bytes","type_short":"long"}},{"javadoc":"This member holds the section header table index of the entry associated with the section\n name string table. If the file has no section name string table, this member holds\n the value SHN_UNDEF.\n@return the section header table index of the entry associated with the section name string table","static":false,"name":"e_shstrndx","comment":"This member holds the section header table index of the entry associated with the section\n name string table. If the file has no section name string table, this member holds\n the value SHN_UNDEF.","params":[],"throws":[],"return":{"type_long":"short","comment":"the section header table index of the entry associated with the section name string table","type_short":"short"}},{"javadoc":"This member identifies the object file type; executable, shared object, etc.\n@return the object file type","static":false,"name":"e_type","comment":"This member identifies the object file type; executable, shared object, etc.","params":[],"throws":[],"return":{"type_long":"short","comment":"the object file type","type_short":"short"}},{"javadoc":"Returns true if this is a relocatable file.\n <br>\n e_type == NewElfHeaderConstants.ET_REL\n@return true if this is a relocatable file","static":false,"name":"isRelocatable","comment":"Returns true if this is a relocatable file.\n \n e_type == NewElfHeaderConstants.ET_REL","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a relocatable file","type_short":"boolean"}},{"javadoc":"Returns true if this is a shared object file.\n <br>\n e_type == NewElfHeaderConstants.ET_DYN\n@return true if this is a shared object file","static":false,"name":"isSharedObject","comment":"Returns true if this is a shared object file.\n \n e_type == NewElfHeaderConstants.ET_DYN","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a shared object file","type_short":"boolean"}},{"javadoc":"Returns true if this is an executable file.\n <br>\n e_type == NewElfHeaderConstants.ET_EXEC\n@return true if this is a executable file","static":false,"name":"isExecutable","comment":"Returns true if this is an executable file.\n \n e_type == NewElfHeaderConstants.ET_EXEC","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a executable file","type_short":"boolean"}},{"javadoc":"This member identifies the object file version,\n where \"EV_NONE == Invalid Version\" and \"EV_CURRENT == Current Version\"\n The value 1 signifies the original file format; extensions will \n create new versions with higher numbers. \n The value of EV_CURRENT, though given as 1 above, will change as\n necessary to reflect the current version number.\n@return the object file version","static":false,"name":"e_version","comment":"This member identifies the object file version,\n where \"EV_NONE == Invalid Version\" and \"EV_CURRENT == Current Version\"\n The value 1 signifies the original file format; extensions will \n create new versions with higher numbers. \n The value of EV_CURRENT, though given as 1 above, will change as\n necessary to reflect the current version number.","params":[],"throws":[],"return":{"type_long":"int","comment":"the object file version","type_short":"int"}},{"javadoc":"Returns the section headers as defined in this ELF file.\n@return the section headers as defined in this ELF file","static":false,"name":"getSections","comment":"Returns the section headers as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader[]","comment":"the section headers as defined in this ELF file","type_short":"ghidra.app.util.bin.format.elf.ElfSectionHeader[]"}},{"javadoc":"Returns the section headers with the specified type.\n The array could be zero-length, but will not be null.\n@param type\n@return the section headers with the specified type\n@see ElfSectionHeader","static":false,"name":"getSections","comment":"Returns the section headers with the specified type.\n The array could be zero-length, but will not be null.","params":[{"type_long":"int","name":"type","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader[]","comment":"the section headers with the specified type","type_short":"ghidra.app.util.bin.format.elf.ElfSectionHeader[]"}},{"javadoc":"Returns the section header with the specified name, or null\n if no section exists with that name.\n@param name the name of the requested section\n@return the section header with the specified name","static":false,"name":"getSection","comment":"Returns the section header with the specified name, or null\n if no section exists with that name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the requested section","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"the section header with the specified name","type_short":"ElfSectionHeader"}},{"javadoc":"Returns the section header at the specified address,\n or null if no section exists at that address.\n@param address the address of the requested section\n@return the section header with the specified address","static":false,"name":"getSectionAt","comment":"Returns the section header at the specified address,\n or null if no section exists at that address.","params":[{"type_long":"long","name":"address","comment":"the address of the requested section","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"the section header with the specified address","type_short":"ElfSectionHeader"}},{"javadoc":"Returns the section header that loads\/contains the specified address,\n or null if no section contains the address.\n@param address the address of the requested section\n@return the section header that contains the address","static":false,"name":"getSectionLoadHeaderContaining","comment":"Returns the section header that loads\/contains the specified address,\n or null if no section contains the address.","params":[{"type_long":"long","name":"address","comment":"the address of the requested section","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"the section header that contains the address","type_short":"ElfSectionHeader"}},{"javadoc":"Returns the section header which fully contains the specified file offset range.\n@param fileOffset file offset\n@param fileRangeLength length of file range in bytes\n@return section or null if not found","static":false,"name":"getSectionHeaderContainingFileRange","comment":"Returns the section header which fully contains the specified file offset range.","params":[{"type_long":"long","name":"fileOffset","comment":"file offset","type_short":"long"},{"type_long":"long","name":"fileRangeLength","comment":"length of file range in bytes","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"section or null if not found","type_short":"ElfSectionHeader"}},{"javadoc":"Returns the index of the specified section.\n The index is the order in which the section was\n defined in the section header table.\n@param section the section header\n@return the index of the specified section header","static":false,"name":"getSectionIndex","comment":"Returns the index of the specified section.\n The index is the order in which the section was\n defined in the section header table.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"the section header","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"int","comment":"the index of the specified section header","type_short":"int"}},{"javadoc":"Returns the program headers as defined in this ELF file.\n@return the program headers as defined in this ELF file","static":false,"name":"getProgramHeaders","comment":"Returns the program headers as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader[]","comment":"the program headers as defined in this ELF file","type_short":"ghidra.app.util.bin.format.elf.ElfProgramHeader[]"}},{"javadoc":"Returns the program headers with the specified type.\n The array could be zero-length, but will not be null.\n@param type\n@return the program headers with the specified type\n@see ElfProgramHeader","static":false,"name":"getProgramHeaders","comment":"Returns the program headers with the specified type.\n The array could be zero-length, but will not be null.","params":[{"type_long":"int","name":"type","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader[]","comment":"the program headers with the specified type","type_short":"ghidra.app.util.bin.format.elf.ElfProgramHeader[]"}},{"javadoc":"Returns the dynamic table defined by program header of type PT_DYNAMIC or the .dynamic program section.\n Or, null if one does not exist.\n@return the dynamic table","static":false,"name":"getDynamicTable","comment":"Returns the dynamic table defined by program header of type PT_DYNAMIC or the .dynamic program section.\n Or, null if one does not exist.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfDynamicTable","comment":"the dynamic table","type_short":"ElfDynamicTable"}},{"javadoc":"Returns the program header with type of PT_PHDR.\n Or, null if one does not exist.\n@return the program header with type of PT_PHDR","static":false,"name":"getProgramHeaderProgramHeader","comment":"Returns the program header with type of PT_PHDR.\n Or, null if one does not exist.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","comment":"the program header with type of PT_PHDR","type_short":"ElfProgramHeader"}},{"javadoc":"Returns the program header at the specified address,\n or null if no program header exists at that address.\n@param virtualAddr the address of the requested program header\n@return the program header with the specified address","static":false,"name":"getProgramHeaderAt","comment":"Returns the program header at the specified address,\n or null if no program header exists at that address.","params":[{"type_long":"long","name":"virtualAddr","comment":"the address of the requested program header","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","comment":"the program header with the specified address","type_short":"ElfProgramHeader"}},{"javadoc":"Returns the PT_LOAD program header which loads a range containing \n the specified address, or null if not found.\n@param virtualAddr the address of the requested program header\n@return the program header with the specified address","static":false,"name":"getProgramLoadHeaderContaining","comment":"Returns the PT_LOAD program header which loads a range containing \n the specified address, or null if not found.","params":[{"type_long":"long","name":"virtualAddr","comment":"the address of the requested program header","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","comment":"the program header with the specified address","type_short":"ElfProgramHeader"}},{"javadoc":"Returns the PT_LOAD program header which loads a range containing \n the specified file offset, or null if not found.\n@param offset the file offset to be loaded\n@return the program header with the specified file offset","static":false,"name":"getProgramLoadHeaderContainingFileOffset","comment":"Returns the PT_LOAD program header which loads a range containing \n the specified file offset, or null if not found.","params":[{"type_long":"long","name":"offset","comment":"the file offset to be loaded","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","comment":"the program header with the specified file offset","type_short":"ElfProgramHeader"}},{"javadoc":"Returns array of dynamic library names defined by DT_NEEDED\n@return array of dynamic library names","static":false,"name":"getDynamicLibraryNames","comment":"Returns array of dynamic library names defined by DT_NEEDED","params":[],"throws":[],"return":{"type_long":"java.lang.String[]","comment":"array of dynamic library names","type_short":"java.lang.String[]"}},{"javadoc":"Returns the dynamic string table as defined in this ELF file.\n@return the dynamic string table as defined in this ELF file","static":false,"name":"getDynamicStringTable","comment":"Returns the dynamic string table as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfStringTable","comment":"the dynamic string table as defined in this ELF file","type_short":"ElfStringTable"}},{"javadoc":"Returns the string tables as defined in this ELF file.\n@return the string tables as defined in this ELF file","static":false,"name":"getStringTables","comment":"Returns the string tables as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfStringTable[]","comment":"the string tables as defined in this ELF file","type_short":"ghidra.app.util.bin.format.elf.ElfStringTable[]"}},{"javadoc":"Returns the string table associated to the specified section header.\n Or, null if one does not exist.\n@return the string table associated to the specified section header","static":false,"name":"getStringTable","comment":"Returns the string table associated to the specified section header.\n Or, null if one does not exist.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfStringTable","comment":"the string table associated to the specified section header","type_short":"ElfStringTable"}},{"javadoc":"Returns the dynamic symbol table as defined in this ELF file.\n@return the dynamic symbol table as defined in this ELF file","static":false,"name":"getDynamicSymbolTable","comment":"Returns the dynamic symbol table as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbolTable","comment":"the dynamic symbol table as defined in this ELF file","type_short":"ElfSymbolTable"}},{"javadoc":"Returns the symbol tables as defined in this ELF file.\n@return the symbol tables as defined in this ELF file","static":false,"name":"getSymbolTables","comment":"Returns the symbol tables as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbolTable[]","comment":"the symbol tables as defined in this ELF file","type_short":"ghidra.app.util.bin.format.elf.ElfSymbolTable[]"}},{"javadoc":"Returns the symbol table associated to the specified section header.\n Or, null if one does not exist.\n@return the symbol table associated to the specified section header","static":false,"name":"getSymbolTable","comment":"Returns the symbol table associated to the specified section header.\n Or, null if one does not exist.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"symbolTableSection","comment":"","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbolTable","comment":"the symbol table associated to the specified section header","type_short":"ElfSymbolTable"}},{"javadoc":"Returns the relocation tables as defined in this ELF file.\n@return the relocation tables as defined in this ELF file","static":false,"name":"getRelocationTables","comment":"Returns the relocation tables as defined in this ELF file.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfRelocationTable[]","comment":"the relocation tables as defined in this ELF file","type_short":"ghidra.app.util.bin.format.elf.ElfRelocationTable[]"}},{"javadoc":"Returns the relocation table associated to the specified section header.\n Or, null if one does not exist.\n@return the relocation table associated to the specified section header","static":false,"name":"getRelocationTable","comment":"Returns the relocation table associated to the specified section header.\n Or, null if one does not exist.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"relocSection","comment":"","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfRelocationTable","comment":"the relocation table associated to the specified section header","type_short":"ElfRelocationTable"}},{"javadoc":"Returns a string name of the processor specified in this ELF header.\n For example, if \"e_machine==EM_386\", then it returns \"80386\".\n@return a string name of the processor specified in this ELF header","static":false,"name":"getMachineName","comment":"Returns a string name of the processor specified in this ELF header.\n For example, if \"e_machine==EM_386\", then it returns \"80386\".","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"a string name of the processor specified in this ELF header","type_short":"String"}},{"javadoc":"Returns a string representation of the numeric flags field.\n@return elf flags field value","static":false,"name":"getFlags","comment":"Returns a string representation of the numeric flags field.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"elf flags field value","type_short":"String"}},{"javadoc":"@see ghidra.app.util.bin.StructConverter#toDataType()","static":false,"name":"toDataType","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"Get the Elf header structure component ordinal \n corresponding to the e_entry element\n@return e_entry component ordinal","static":false,"name":"getEntryComponentOrdinal","comment":"Get the Elf header structure component ordinal \n corresponding to the e_entry element","params":[],"throws":[],"return":{"type_long":"int","comment":"e_entry component ordinal","type_short":"int"}},{"javadoc":"Get the Elf header structure component ordinal \n corresponding to the e_phoff element\n@return e_phoff component ordinal","static":false,"name":"getPhoffComponentOrdinal","comment":"Get the Elf header structure component ordinal \n corresponding to the e_phoff element","params":[],"throws":[],"return":{"type_long":"int","comment":"e_phoff component ordinal","type_short":"int"}},{"javadoc":"Get the Elf header structure component ordinal \n corresponding to the e_shoff element\n@return e_shoff component ordinal","static":false,"name":"getShoffComponentOrdinal","comment":"Get the Elf header structure component ordinal \n corresponding to the e_shoff element","params":[],"throws":[],"return":{"type_long":"int","comment":"e_shoff component ordinal","type_short":"int"}},{"javadoc":"","static":false,"name":"addSection","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"newSection","comment":"","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a new section using the specified memory block.\n The memory block is used to setting the address and size.\n As well as, setting the data.\n@param block the memory block\n@param sh_name the byte index into the string table where the name begins\n@return the newly created section\n@throws MemoryAccessException if any of the requested memory block bytes are uninitialized.","static":false,"name":"addSection","comment":"Adds a new section using the specified memory block.\n The memory block is used to setting the address and size.\n As well as, setting the data.","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"the memory block","type_short":"MemoryBlock"},{"type_long":"int","name":"sh_name","comment":"the byte index into the string table where the name begins","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if any of the requested memory block bytes are uninitialized.","type_short":"MemoryAccessException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"the newly created section","type_short":"ElfSectionHeader"}},{"javadoc":"Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.\n@param name the actual name of the new section\n@param sh_name the byte index into the string table where the name begins\n@return the newly created section","static":false,"name":"addSection","comment":"Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.","params":[{"type_long":"java.lang.String","name":"name","comment":"the actual name of the new section","type_short":"String"},{"type_long":"int","name":"sh_name","comment":"the byte index into the string table where the name begins","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"the newly created section","type_short":"ElfSectionHeader"}},{"javadoc":"Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.\n@param name the actual name of the new section\n@param sh_name the byte index into the string table where the name begins\n@param type the type of the new section\n@return the newly created section","static":false,"name":"addSection","comment":"Adds a new section the specifed name and name index.\n The type of the section will be SHT_PROGBITS.","params":[{"type_long":"java.lang.String","name":"name","comment":"the actual name of the new section","type_short":"String"},{"type_long":"int","name":"sh_name","comment":"the byte index into the string table where the name begins","type_short":"int"},{"type_long":"int","name":"type","comment":"the type of the new section","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"the newly created section","type_short":"ElfSectionHeader"}},{"javadoc":"Appends the new program header to the end of the existing\n program header table.\n@param ph the new program header","static":false,"name":"addProgramHeader","comment":"Appends the new program header to the end of the existing\n program header table.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"ph","comment":"the new program header","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.app.util.bin.format.Writeable#write(java.io.RandomAccessFile, ghidra.util.DataConverter)","static":false,"name":"write","comment":"","params":[{"type_long":"java.io.RandomAccessFile","name":"raf","comment":"","type_short":"RandomAccessFile"},{"type_long":"ghidra.util.DataConverter","name":"dc","comment":"","type_short":"DataConverter"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the section header offset.\n@param offset the new section header offset","static":false,"name":"setSectionHeaderOffset","comment":"Sets the section header offset.","params":[{"type_long":"long","name":"offset","comment":"the new section header offset","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the program header offset.\n@param offset the new program header offset","static":false,"name":"setProgramHeaderOffset","comment":"Sets the program header offset.","params":[{"type_long":"long","name":"offset","comment":"the new program header offset","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"ElfHeader","comment":"A class to represent the Executable and Linking Format (ELF)\n header and specification.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"MAX_HEADERS_TO_CHECK_FOR_IMAGEBASE","comment":"","type_short":"int","constant_value":"20"},{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfProgramHeaderType>","javadoc":"","static":false,"name":"programHeaderTypeMap","comment":"","type_short":"HashMap","constant_value":null},{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfSectionHeaderType>","javadoc":"","static":false,"name":"sectionHeaderTypeMap","comment":"","type_short":"HashMap","constant_value":null},{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfDynamicType>","javadoc":"","static":false,"name":"dynamicTypeMap","comment":"","type_short":"HashMap","constant_value":null},{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","javadoc":"","static":false,"name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.extend.ElfLoadAdapter","javadoc":"","static":false,"name":"elfLoadAdapter","comment":"","type_short":"ElfLoadAdapter","constant_value":null},{"type_long":"byte","javadoc":"","static":false,"name":"e_ident_magic_num","comment":"","type_short":"byte","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"e_ident_magic_str","comment":"","type_short":"String","constant_value":null},{"type_long":"byte","javadoc":"","static":false,"name":"e_ident_class","comment":"","type_short":"byte","constant_value":null},{"type_long":"byte","javadoc":"","static":false,"name":"e_ident_data","comment":"","type_short":"byte","constant_value":null},{"type_long":"byte","javadoc":"","static":false,"name":"e_ident_version","comment":"","type_short":"byte","constant_value":null},{"type_long":"byte[]","javadoc":"","static":false,"name":"e_ident_pad","comment":"","type_short":"byte[]","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_type","comment":"","type_short":"short","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_machine","comment":"","type_short":"short","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"e_version","comment":"","type_short":"int","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"e_entry","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"e_phoff","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"e_shoff","comment":"","type_short":"long","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"e_flags","comment":"","type_short":"int","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_ehsize","comment":"","type_short":"short","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_phentsize","comment":"","type_short":"short","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_phnum","comment":"","type_short":"short","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_shentsize","comment":"","type_short":"short","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_shnum","comment":"","type_short":"short","constant_value":null},{"type_long":"short","javadoc":"","static":false,"name":"e_shstrndx","comment":"","type_short":"short","constant_value":null},{"type_long":"ghidra.program.model.data.Structure","javadoc":"","static":false,"name":"headerStructure","comment":"","type_short":"Structure","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"parsed","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"parsedSectionHeaders","comment":"","type_short":"boolean","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader[]","javadoc":"","static":false,"name":"sectionHeaders","comment":"","type_short":"ghidra.app.util.bin.format.elf.ElfSectionHeader[]","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader[]","javadoc":"","static":false,"name":"programHeaders","comment":"","type_short":"ghidra.app.util.bin.format.elf.ElfProgramHeader[]","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfStringTable[]","javadoc":"","static":false,"name":"stringTables","comment":"","type_short":"ghidra.app.util.bin.format.elf.ElfStringTable[]","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbolTable[]","javadoc":"","static":false,"name":"symbolTables","comment":"","type_short":"ghidra.app.util.bin.format.elf.ElfSymbolTable[]","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfRelocationTable[]","javadoc":"","static":false,"name":"relocationTables","comment":"","type_short":"ghidra.app.util.bin.format.elf.ElfRelocationTable[]","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfDynamicTable","javadoc":"","static":false,"name":"dynamicTable","comment":"","type_short":"ElfDynamicTable","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfStringTable","javadoc":"","static":false,"name":"dynamicStringTable","comment":"","type_short":"ElfStringTable","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbolTable","javadoc":"","static":false,"name":"dynamicSymbolTable","comment":"","type_short":"ElfSymbolTable","constant_value":null},{"type_long":"java.lang.String[]","javadoc":"","static":false,"name":"dynamicLibraryNames","comment":"","type_short":"java.lang.String[]","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"hasLittleEndianHeaders","comment":"","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"INITIAL_READ_LEN","comment":"","type_short":"int","constant_value":null},{"type_long":"java.lang.Long","javadoc":"","static":false,"name":"elfImageBase","comment":"","type_short":"Long","constant_value":null},{"type_long":"java.lang.Long","javadoc":"","static":false,"name":"preLinkImageBase","comment":"","type_short":"Long","constant_value":null}]}
