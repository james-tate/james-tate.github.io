{"implements":["ghidra.app.util.bin.ByteArrayConverter","ghidra.app.util.bin.StructConverter"],"javadoc":"A class to represent the Elf32_Rel and Elf64_Rel data structure.\n <br>\n <pre>\n typedef uint32_t Elf32_Addr;\n typedef uint64_t Elf64_Addr;\n typedef uint32_t Elf32_Word;\n typedef uint64_t Elf64_Xword;\n \n REL entry:\n \n typedef struct {\n     Elf32_Addr   r_offset;\n     Elf32_Word   r_info;\n } Elf32_Rel;\n \n typedef struct {\n     Elf64_Addr   r_offset;\n     Elf64_Xword  r_info;\n } Elf64_Rel;\n \n RELA entry with addend:\n \n  * typedef struct {\n     Elf32_Addr    r_offset;\n     Elf32_Word    r_info;\n     Elf32_Sword   r_addend;\n } Elf32_Rela;\n \n typedef struct {\n     Elf64_Addr    r_offset;   \/\/Address\n     Elf64_Xword   r_info;     \/\/Relocation type and symbol index\n     Elf64_Sxword  r_addend;   \/\/Addend \n } Elf64_Rela;\n\n <\/pre>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"GenericFactory construction and initialization method for a ELF relocation entry\n@param reader binary reader positioned at start of relocation entry.\n@param elfHeader ELF header\n@param relocationIndex index of entry in relocation table\n@param withAddend true if if RELA entry with addend, else false\n@return ELF relocation object\n@throws IOException","static":true,"name":"createElfRelocation","comment":"GenericFactory construction and initialization method for a ELF relocation entry","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"binary reader positioned at start of relocation entry.","type_short":"FactoryBundledWithBinaryReader"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"elfHeader","comment":"ELF header","type_short":"ElfHeader"},{"type_long":"int","name":"relocationIndex","comment":"index of entry in relocation table","type_short":"int"},{"type_long":"boolean","name":"withAddend","comment":"true if if RELA entry with addend, else false","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfRelocation","comment":"ELF relocation object","type_short":"ElfRelocation"}},{"javadoc":"GenericFactory construction and initialization method for a ELF representative \n relocation entry (entry data will be 0)\n@param factory instantiation factory.\n@param elfHeader ELF header\n@param relocationIndex index of entry in relocation table\n@param withAddend true if if RELA entry with addend, else false\n@return ELF relocation object","static":true,"name":"createElfRelocation","comment":"GenericFactory construction and initialization method for a ELF representative \n relocation entry (entry data will be 0)","params":[{"type_long":"generic.continues.GenericFactory","name":"factory","comment":"instantiation factory.","type_short":"GenericFactory"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"elfHeader","comment":"ELF header","type_short":"ElfHeader"},{"type_long":"int","name":"relocationIndex","comment":"index of entry in relocation table","type_short":"int"},{"type_long":"boolean","name":"withAddend","comment":"true if if RELA entry with addend, else false","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfRelocation","comment":"ELF relocation object","type_short":"ElfRelocation"}},{"javadoc":"","static":true,"name":"getElfRelocationClass","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"elfHeader","comment":"","type_short":"ElfHeader"}],"throws":[],"return":{"type_long":"java.lang.Class<? extends ghidra.app.util.bin.format.elf.ElfRelocation>","comment":"","type_short":"Class"}},{"javadoc":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.\n@see ElfRelocation#createElfRelocation","static":false,"name":"<init>","comment":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Initialize ELF relocation entry using data from the binary reader's current position.\n@param reader binary reader positioned to the relocation entry data.  If null, \n a representative instance will be generated with all fields set to 0.\n@param elfHeader ELF header\n@param relocationTableIndex index of relocation within relocation table\n@param withAddend true if if RELA entry with addend, else false\n@throws IOException","static":false,"name":"initElfRelocation","comment":"Initialize ELF relocation entry using data from the binary reader's current position.","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"binary reader positioned to the relocation entry data.  If null, \n a representative instance will be generated with all fields set to 0.","type_short":"FactoryBundledWithBinaryReader"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"elfHeader","comment":"ELF header","type_short":"ElfHeader"},{"type_long":"int","name":"relocationTableIndex","comment":"index of relocation within relocation table","type_short":"int"},{"type_long":"boolean","name":"withAddend","comment":"true if if RELA entry with addend, else false","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"readEntryData","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return index of relocation within its corresponding relocation table","static":false,"name":"getRelocationIndex","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"index of relocation within its corresponding relocation table","type_short":"int"}},{"javadoc":"@return true if processing a 32-bit header, else 64-bit","static":false,"name":"is32Bit","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if processing a 32-bit header, else 64-bit","type_short":"boolean"}},{"javadoc":"This member gives the location at which to apply the relocation action. \n \n For a relocatable file, the value is the byte offset from the \n beginning of the section to the storage unit affected by the relocation. \n \n For an executable file or a shared object, the value is the virtual address of\n the storage unit affected by the relocation.\n@return the location at which to apply the relocation","static":false,"name":"getOffset","comment":"This member gives the location at which to apply the relocation action. \n \n For a relocatable file, the value is the byte offset from the \n beginning of the section to the storage unit affected by the relocation. \n \n For an executable file or a shared object, the value is the virtual address of\n the storage unit affected by the relocation.","params":[],"throws":[],"return":{"type_long":"long","comment":"the location at which to apply the relocation","type_short":"long"}},{"javadoc":"Sets the relocation offset to the new specified value.\n@param offset the new offset value","static":false,"name":"setOffset","comment":"Sets the relocation offset to the new specified value.","params":[{"type_long":"int","name":"offset","comment":"the new offset value","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the relocation offset to the new specified value.\n@param offset the new offset value","static":false,"name":"setOffset","comment":"Sets the relocation offset to the new specified value.","params":[{"type_long":"long","name":"offset","comment":"the new offset value","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the symbol index where the relocation must be made.\n@return the symbol index","static":false,"name":"getSymbolIndex","comment":"Returns the symbol index where the relocation must be made.","params":[],"throws":[],"return":{"type_long":"int","comment":"the symbol index","type_short":"int"}},{"javadoc":"The type of relocation to apply.\n NOTE: Relocation types are processor-specific.\n@return type of relocation to apply","static":false,"name":"getType","comment":"The type of relocation to apply.\n NOTE: Relocation types are processor-specific.","params":[],"throws":[],"return":{"type_long":"int","comment":"type of relocation to apply","type_short":"int"}},{"javadoc":"Returns the r_info relocation entry field value\n@return r_info value","static":false,"name":"getRelocationInfo","comment":"Returns the r_info relocation entry field value","params":[],"throws":[],"return":{"type_long":"long","comment":"r_info value","type_short":"long"}},{"javadoc":"This member specifies a constant addend used to compute \n the value to be stored into the relocatable field.  This\n value will be 0 for REL entries which do not supply an addend.\n@return a constant addend","static":false,"name":"getAddend","comment":"This member specifies a constant addend used to compute \n the value to be stored into the relocatable field.  This\n value will be 0 for REL entries which do not supply an addend.","params":[],"throws":[],"return":{"type_long":"long","comment":"a constant addend","type_short":"long"}},{"javadoc":"Returns true if this is a RELA entry with addend\n@return true if this is a RELA entry with addend","static":false,"name":"hasAddend","comment":"Returns true if this is a RELA entry with addend","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a RELA entry with addend","type_short":"boolean"}},{"javadoc":"","static":false,"name":"toDataType","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"@see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)","static":false,"name":"toBytes","comment":"","params":[{"type_long":"ghidra.util.DataConverter","name":"dc","comment":"","type_short":"DataConverter"}],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"sizeof","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}}],"name":"ElfRelocation","comment":"A class to represent the Elf32_Rel and Elf64_Rel data structure.\n \n \n typedef uint32_t Elf32_Addr;\n typedef uint64_t Elf64_Addr;\n typedef uint32_t Elf32_Word;\n typedef uint64_t Elf64_Xword;\n \n REL entry:\n \n typedef struct {\n     Elf32_Addr   r_offset;\n     Elf32_Word   r_info;\n } Elf32_Rel;\n \n typedef struct {\n     Elf64_Addr   r_offset;\n     Elf64_Xword  r_info;\n } Elf64_Rel;\n \n RELA entry with addend:\n \n  * typedef struct {\n     Elf32_Addr    r_offset;\n     Elf32_Word    r_info;\n     Elf32_Sword   r_addend;\n } Elf32_Rela;\n \n typedef struct {\n     Elf64_Addr    r_offset;   \/\/Address\n     Elf64_Xword   r_info;     \/\/Relocation type and symbol index\n     Elf64_Sxword  r_addend;   \/\/Addend \n } Elf64_Rela;\n\n ","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"R_OFFSET_COMMENT","comment":"","type_short":"String","constant_value":"\"location to apply the relocation action\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"R_INFO_COMMENT","comment":"","type_short":"String","constant_value":"\"the symbol table index and the type of relocation\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"R_ADDEND_COMMENT","comment":"","type_short":"String","constant_value":"\"a constant addend used to compute the relocatable field value\""},{"type_long":"long","javadoc":"","static":false,"name":"r_offset","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"r_info","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"r_addend","comment":"","type_short":"long","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"hasAddend","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"is32bit","comment":"","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"relocationIndex","comment":"","type_short":"int","constant_value":null}]}
