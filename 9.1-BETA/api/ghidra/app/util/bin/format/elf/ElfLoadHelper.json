{"implements":[],"javadoc":"<code>ElfLoadHelper<\/code> exposes loader methods useful to ElfExtension \n implementations.","static":false,"methods":[{"javadoc":"Get program object\n@return program object","static":false,"name":"getProgram","comment":"Get program object","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"program object","type_short":"Program"}},{"javadoc":"Get ELF Header object\n@return ELF Header object","static":false,"name":"getElfHeader","comment":"Get ELF Header object","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","comment":"ELF Header object","type_short":"ElfHeader"}},{"javadoc":"Get the message log\n@return message log","static":false,"name":"getLog","comment":"Get the message log","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.importer.MessageLog","comment":"message log","type_short":"MessageLog"}},{"javadoc":"Output loader log message\n@param msg text message","static":false,"name":"log","comment":"Output loader log message","params":[{"type_long":"java.lang.String","name":"msg","comment":"text message","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Output loader log message.\n@param t exception\/throwable error","static":false,"name":"log","comment":"Output loader log message.","params":[{"type_long":"java.lang.Throwable","name":"t","comment":"exception\/throwable error","type_short":"Throwable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Mark this location as code in the CodeMap.\n The analyzers will pick this up and disassemble the code.\n@param address","static":false,"name":"markAsCode","comment":"Mark this location as code in the CodeMap.\n The analyzers will pick this up and disassemble the code.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Create a one-byte function, so that when the code is analyzed,\n it will be disassembled, and the function created with the correct body.\n@param name name of function or null for default (or label already applied)\n@param address address of function\n@param isEntry mark function as entry point if true\n@param log\n@return new or existing function.","static":false,"name":"createOneByteFunction","comment":"Create a one-byte function, so that when the code is analyzed,\n it will be disassembled, and the function created with the correct body.","params":[{"type_long":"java.lang.String","name":"name","comment":"name of function or null for default (or label already applied)","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"address of function","type_short":"Address"},{"type_long":"boolean","name":"isEntry","comment":"mark function as entry point if true","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"new or existing function.","type_short":"Function"}},{"javadoc":"Create an external function within the UNKNOWN space and a corresponding thunk at \n the internalFunctionAddr.  If the functionAddr and\/or indirectPointerAddr has a symbol with <name>\n it will be removed so as not to replicate the external function name.\n@param name external function name\n@param functionAddr location of thunk function (memory address only)\n@param indirectPointerAddr if not null a pointer to functionAddr will be written (size of pointer\n based 32 or 64 bits based upon ELF size).  Memory must exist and will be converted to initialized\n if needed.\n@return thunk function or null if failure occurred","static":false,"name":"createExternalFunctionLinkage","comment":"Create an external function within the UNKNOWN space and a corresponding thunk at \n the internalFunctionAddr.  If the functionAddr and\/or indirectPointerAddr has a symbol with \n it will be removed so as not to replicate the external function name.","params":[{"type_long":"java.lang.String","name":"name","comment":"external function name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"functionAddr","comment":"location of thunk function (memory address only)","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"indirectPointerAddr","comment":"if not null a pointer to functionAddr will be written (size of pointer\n based 32 or 64 bits based upon ELF size).  Memory must exist and will be converted to initialized\n if needed.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"thunk function or null if failure occurred","type_short":"Function"}},{"javadoc":"Create an undefined data item to reserve the location as data, without specifying the type\n@param address location of undefined data to create\n@param length size of the undefined data item","static":false,"name":"createUndefinedData","comment":"Create an undefined data item to reserve the location as data, without specifying the type","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"location of undefined data to create","type_short":"Address"},{"type_long":"int","name":"length","comment":"size of the undefined data item","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"","type_short":"Data"}},{"javadoc":"Create a data item using the specified data type\n@param address location of undefined data to create\n@param dt data type\n@return data or null if not successful","static":false,"name":"createData","comment":"Create a data item using the specified data type","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"location of undefined data to create","type_short":"Address"},{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"data type","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"data or null if not successful","type_short":"Data"}},{"javadoc":"Add specified elfSymbol to the loader symbol map after its program address has been assigned\n@param elfSymbol elf symbol\n@param address program address (may be null if not applicable)","static":false,"name":"setElfSymbolAddress","comment":"Add specified elfSymbol to the loader symbol map after its program address has been assigned","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbol","name":"elfSymbol","comment":"elf symbol","type_short":"ElfSymbol"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"program address (may be null if not applicable)","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the memory address of a previously resolved symbol\n@param elfSymbol elf symbol\n@return memory address or null if unknown","static":false,"name":"getElfSymbolAddress","comment":"Get the memory address of a previously resolved symbol","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbol","name":"elfSymbol","comment":"elf symbol","type_short":"ElfSymbol"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"memory address or null if unknown","type_short":"Address"}},{"javadoc":"Create the specified label symbol within the program.\n@param addr program address\n@param name symbol\/label name\n@param isPrimary true if is symbol should be made primary (certain name patterns excluded)\n@param pinAbsolute true if address is absolute and should not change\n@param namespace symbol namespace (should generally be null for global namespace)\n@return program symbol\n@throws InvalidInputException","static":false,"name":"createSymbol","comment":"Create the specified label symbol within the program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"program address","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"symbol\/label name","type_short":"String"},{"type_long":"boolean","name":"isPrimary","comment":"true if is symbol should be made primary (certain name patterns excluded)","type_short":"boolean"},{"type_long":"boolean","name":"pinAbsolute","comment":"true if address is absolute and should not change","type_short":"boolean"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"symbol namespace (should generally be null for global namespace)","type_short":"Namespace"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"program symbol","type_short":"Symbol"}},{"javadoc":"Find the program address at which a specified offset within a section or segment was loaded\/resolved.\n@param section a segment or section header which was loaded to memory\n@param byteOffsetWithinSection offset within section\n@return resolved load address or null if not loaded","static":false,"name":"findLoadAddress","comment":"Find the program address at which a specified offset within a section or segment was loaded\/resolved.","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"section","comment":"a segment or section header which was loaded to memory","type_short":"MemoryLoadable"},{"type_long":"long","name":"byteOffsetWithinSection","comment":"offset within section","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"resolved load address or null if not loaded","type_short":"Address"}},{"javadoc":"Get the program address for an addressableWordOffset within the default address space.  \n This method is responsible for applying any program image base change imposed during \n the import (see {@link #getImageBaseWordOffset(Program, ElfHeader)}.\n@param addressableWordOffset absolute word offset.  The offset should already include\n default image base and pre-link adjustment (see {@link ElfHeader#adjustAddressForPrelink(long)}).\n@return memory address in default code space","static":false,"name":"getDefaultAddress","comment":"Get the program address for an addressableWordOffset within the default address space.  \n This method is responsible for applying any program image base change imposed during \n the import (see #getImageBaseWordOffset(Program, ElfHeader).","params":[{"type_long":"long","name":"addressableWordOffset","comment":"absolute word offset.  The offset should already include\n default image base and pre-link adjustment (see ElfHeader#adjustAddressForPrelink(long)).","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"memory address in default code space","type_short":"Address"}},{"javadoc":"Get the program image base offset adjustment.  The value returned reflects the\n actual program image base minus the default image base (see {@link ElfHeader#getImageBase()}.\n This will generally be zero (0), unless the program image base differs from the\n default.  It may be neccessary to add this value to any pre-linked address values\n such as those contained with the dynamic table. (Applies to default address space only)\n@return image base adjustment value","static":false,"name":"getImageBaseWordAdjustmentOffset","comment":"Get the program image base offset adjustment.  The value returned reflects the\n actual program image base minus the default image base (see ElfHeader#getImageBase().\n This will generally be zero (0), unless the program image base differs from the\n default.  It may be neccessary to add this value to any pre-linked address values\n such as those contained with the dynamic table. (Applies to default address space only)","params":[],"throws":[],"return":{"type_long":"long","comment":"image base adjustment value","type_short":"long"}},{"javadoc":"Returns the appropriate .got (Global Offset Table) section address using the\n DT_PLTGOT value defined in the .dynamic section.\n If the dynamic value is not defined, the symbol offset for _GLOBAL_OFFSET_TABLE_\n will be used, otherwise null will be returned.\n@return the .got section address offset","static":false,"name":"getGOTValue","comment":"Returns the appropriate .got (Global Offset Table) section address using the\n DT_PLTGOT value defined in the .dynamic section.\n If the dynamic value is not defined, the symbol offset for _GLOBAL_OFFSET_TABLE_\n will be used, otherwise null will be returned.","params":[],"throws":[],"return":{"type_long":"java.lang.Long","comment":"the .got section address offset","type_short":"Long"}},{"javadoc":"<p>Get a free aligned address range within the program's memory block structure to facilitate \n dynamic memory block allocation requirements to support relocation processing (e.g., fake EXTERNAL memory block,\n generated GOT for object modules, etc.).  The range returned for the EXTERNAL memory block may be very large\n but only that portion used should be committed the program's memory map.  The EXTERNAL memory block\n must be committed to the memory map prior to any subsequent invocations of this method<\/p>\n <p>\n NOTES: Additional support may be required for spaces with odd word sizes,\n small 16-bit default memory space, or when shared memory regions exist.\n <\/p>\n@param alignment required byte alignment of allocated range\n@param size size of requested allocation (size <= 0 reserved for EXTERNAL block)\n@param purpose brief descriptive purpose of range.\n@return address range or null if no unallocated range found","static":false,"name":"allocateLinkageBlock","comment":"Get a free aligned address range within the program's memory block structure to facilitate \n dynamic memory block allocation requirements to support relocation processing (e.g., fake EXTERNAL memory block,\n generated GOT for object modules, etc.).  The range returned for the EXTERNAL memory block may be very large\n but only that portion used should be committed the program's memory map.  The EXTERNAL memory block\n must be committed to the memory map prior to any subsequent invocations of this method\n \n NOTES: Additional support may be required for spaces with odd word sizes,\n small 16-bit default memory space, or when shared memory regions exist.\n ","params":[{"type_long":"int","name":"alignment","comment":"required byte alignment of allocated range","type_short":"int"},{"type_long":"int","name":"size","comment":"size of requested allocation (size = 0 reserved for EXTERNAL block)","type_short":"int"},{"type_long":"java.lang.String","name":"purpose","comment":"brief descriptive purpose of range.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressRange","comment":"address range or null if no unallocated range found","type_short":"AddressRange"}}],"name":"ElfLoadHelper","comment":"ElfLoadHelper exposes loader methods useful to ElfExtension \n implementations.","fields":[]}
