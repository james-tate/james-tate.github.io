{"implements":["ghidra.app.util.bin.StructConverter","ghidra.app.util.bin.format.Writeable","ghidra.app.util.bin.format.MemoryLoadable"],"javadoc":"A class to represent the Elf32_Shdr data structure.\n <br>\n <pre>\n typedef  int32_t  Elf32_Sword;\n typedef uint32_t  Elf32_Word;\n typedef uint32_t  Elf32_Addr;\n \n typedef struct {\n     Elf32_Word    sh_name;       \/\/Section name (string tbl index)\n     Elf32_Word    sh_type;       \/\/Section type\n     Elf32_Word    sh_flags;      \/\/Section flags\n     Elf32_Addr    sh_addr;       \/\/Section virtual addr at execution\n     Elf32_Off     sh_offset;     \/\/Section file offset\n     Elf32_Word    sh_size;       \/\/Section size in bytes\n     Elf32_Word    sh_link;       \/\/Link to another section\n     Elf32_Word    sh_info;       \/\/Additional section information\n     Elf32_Word    sh_addralign;  \/\/Section alignment\n     Elf32_Word    sh_entsize;    \/\/Entry size if section holds table *\n } Elf32_Shdr;\n \n typedef  uint32_t  Elf64_Word;\n typedef  uint64_t  Elf64_Xword;\n typedef  uint64_t  Elf64_Addr;\n typedef  uint64_t  Elf64_Off;\n \n typedef struct {\n     Elf64_Word    sh_name;       \/\/Section name (string tbl index)\n     Elf64_Word    sh_type;       \/\/Section type\n     Elf64_Xword   sh_flags;      \/\/Section flags\n     Elf64_Addr    sh_addr;       \/\/Section virtual addr at execution\n     Elf64_Off     sh_offset;     \/\/Section file offset\n     Elf64_Xword   sh_size;       \/\/Section size in bytes\n     Elf64_Word    sh_link;       \/\/Link to another section\n     Elf64_Word    sh_info;       \/\/Additional section information\n     Elf64_Xword   sh_addralign;  \/\/Section alignment\n     Elf64_Xword   sh_entsize;    \/\/Entry size if section holds table *\n } Elf64_Shdr;\n <\/pre>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":true,"name":"createElfSectionHeader","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","comment":"","type_short":"ElfSectionHeader"}},{"javadoc":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","static":false,"name":"<init>","comment":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"initElfSectionHeader","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"},{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"","type_short":"MemoryBlock"},{"type_long":"int","name":"sh_name","comment":"","type_short":"int"},{"type_long":"long","name":"imageBase","comment":"","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"int","name":"sh_name","comment":"","type_short":"int"},{"type_long":"int","name":"type","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return ElfHeader associated with this section\n@return ElfHeader","static":false,"name":"getElfHeader","comment":"Return ElfHeader associated with this section","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","comment":"ElfHeader","type_short":"ElfHeader"}},{"javadoc":"@see ghidra.app.util.bin.format.Writeable#write(java.io.RandomAccessFile, ghidra.util.DataConverter)","static":false,"name":"write","comment":"","params":[{"type_long":"java.io.RandomAccessFile","name":"raf","comment":"","type_short":"RandomAccessFile"},{"type_long":"ghidra.util.DataConverter","name":"dc","comment":"","type_short":"DataConverter"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"If the section will appear in the memory image of a process, this \n member gives the address at which the section's first byte \n should reside. Otherwise, the member contains 0.\n@return the address of the section in memory","static":false,"name":"getAddress","comment":"If the section will appear in the memory image of a process, this \n member gives the address at which the section's first byte \n should reside. Otherwise, the member contains 0.","params":[],"throws":[],"return":{"type_long":"long","comment":"the address of the section in memory","type_short":"long"}},{"javadoc":"Some sections have address alignment constraints. For example, if a section holds a\n doubleword, the system must ensure doubleword alignment for the entire section.\n That is, the value of sh_addr must be congruent to 0, modulo the value of\n sh_addralign. Currently, only 0 and positive integral powers of two are allowed.\n Values 0 and 1 mean the section has no alignment constraints.\n@return the section address alignment constraints","static":false,"name":"getAddressAlignment","comment":"Some sections have address alignment constraints. For example, if a section holds a\n doubleword, the system must ensure doubleword alignment for the entire section.\n That is, the value of sh_addr must be congruent to 0, modulo the value of\n sh_addralign. Currently, only 0 and positive integral powers of two are allowed.\n Values 0 and 1 mean the section has no alignment constraints.","params":[],"throws":[],"return":{"type_long":"long","comment":"the section address alignment constraints","type_short":"long"}},{"javadoc":"Some sections hold a table of fixed-size entries, such as a symbol table. For such a section,\n this member gives the size in bytes of each entry. The member contains 0 if the\n section does not hold a table of fixed-size entries.\n@return the section entry size","static":false,"name":"getEntrySize","comment":"Some sections hold a table of fixed-size entries, such as a symbol table. For such a section,\n this member gives the size in bytes of each entry. The member contains 0 if the\n section does not hold a table of fixed-size entries.","params":[],"throws":[],"return":{"type_long":"long","comment":"the section entry size","type_short":"long"}},{"javadoc":"Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions\n appear aove.\n@return the section flags","static":false,"name":"getFlags","comment":"Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions\n appear aove.","params":[],"throws":[],"return":{"type_long":"long","comment":"the section flags","type_short":"long"}},{"javadoc":"Returns true if this section is writable.\n@return true if this section is writable.","static":false,"name":"isWritable","comment":"Returns true if this section is writable.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this section is writable.","type_short":"boolean"}},{"javadoc":"Returns true if this section is executable.\n@return true if this section is executable.","static":false,"name":"isExecutable","comment":"Returns true if this section is executable.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this section is executable.","type_short":"boolean"}},{"javadoc":"Returns true if this section is allocated (e.g., SHF_ALLOC is set)\n@return true if this section is allocated.","static":false,"name":"isAlloc","comment":"Returns true if this section is allocated (e.g., SHF_ALLOC is set)","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this section is allocated.","type_short":"boolean"}},{"javadoc":"This member holds extra information, whose interpretation \n depends on the section type.\n  \n If sh_type is SHT_REL or SHT_RELA, then sh_info holds \n the section header index of the\n section to which the relocation applies.\n \n If sh_type is SHT_SYMTAB or SHT_DYNSYM, then sh_info\n holds one greater than the symbol table index of the last\n local symbol (binding STB_LOCAL).\n@return the section header info","static":false,"name":"getInfo","comment":"This member holds extra information, whose interpretation \n depends on the section type.\n  \n If sh_type is SHT_REL or SHT_RELA, then sh_info holds \n the section header index of the\n section to which the relocation applies.\n \n If sh_type is SHT_SYMTAB or SHT_DYNSYM, then sh_info\n holds one greater than the symbol table index of the last\n local symbol (binding STB_LOCAL).","params":[],"throws":[],"return":{"type_long":"int","comment":"the section header info","type_short":"int"}},{"javadoc":"This member holds extra information, whose interpretation \n depends on the section type.\n \n If sh_type is SHT_SYMTAB, SHT_DYNSYM, or SHT_DYNAMIC, \n then sh_link holds the section header table index of\n its associated string table.\n \n If sh_type is SHT_REL, SHT_RELA, or SHT_HASH\n sh_link holds the section header index of the \n associated symbol table.\n@return the section header link","static":false,"name":"getLink","comment":"This member holds extra information, whose interpretation \n depends on the section type.\n \n If sh_type is SHT_SYMTAB, SHT_DYNSYM, or SHT_DYNAMIC, \n then sh_link holds the section header table index of\n its associated string table.\n \n If sh_type is SHT_REL, SHT_RELA, or SHT_HASH\n sh_link holds the section header index of the \n associated symbol table.","params":[],"throws":[],"return":{"type_long":"int","comment":"the section header link","type_short":"int"}},{"javadoc":"An index into the section header string table section, \n giving the location of a null-terminated string which is the name of this section.\n@return the index of the section name","static":false,"name":"getName","comment":"An index into the section header string table section, \n giving the location of a null-terminated string which is the name of this section.","params":[],"throws":[],"return":{"type_long":"int","comment":"the index of the section name","type_short":"int"}},{"javadoc":"","static":false,"name":"updateName","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the actual string name for this section. The section only\n stores an byte index into the string table where\n the name string is located.\n@return the actual string name for this section","static":false,"name":"getNameAsString","comment":"Returns the actual string name for this section. The section only\n stores an byte index into the string table where\n the name string is located.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the actual string name for this section","type_short":"String"}},{"javadoc":"@see java.lang.Object#toString()","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"The byte offset from the beginning of the file to the first\n byte in the section.\n One section type, SHT_NOBITS described below, occupies no\n space in the file, and its sh_offset member locates the conceptual placement in the\n file.\n@return byte offset from the beginning of the file to the first byte in the section","static":false,"name":"getOffset","comment":"The byte offset from the beginning of the file to the first\n byte in the section.\n One section type, SHT_NOBITS described below, occupies no\n space in the file, and its sh_offset member locates the conceptual placement in the\n file.","params":[],"throws":[],"return":{"type_long":"long","comment":"byte offset from the beginning of the file to the first byte in the section","type_short":"long"}},{"javadoc":"Sets the section's size.\n@param size the new size of the section","static":false,"name":"setSize","comment":"Sets the section's size.","params":[{"type_long":"long","name":"size","comment":"the new size of the section","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This member gives the section's size in bytes. Unless the section type is\n SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type\n SHT_NOBITS may have a non-zero size, but it occupies no space in the file.\n@return the section's size in bytes","static":false,"name":"getSize","comment":"This member gives the section's size in bytes. Unless the section type is\n SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type\n SHT_NOBITS may have a non-zero size, but it occupies no space in the file.","params":[],"throws":[],"return":{"type_long":"long","comment":"the section's size in bytes","type_short":"long"}},{"javadoc":"Get the adjusted size of the section in bytes (i.e., memory block) which relates to this section header; it may be zero\n if no block should be created.  The returned value reflects any adjustment the ElfExtension may require\n based upon the specific processor\/language implementation which may require filtering of file bytes\n as read into memory.\n@return the number of bytes in the resulting memory block","static":false,"name":"getAdjustedSize","comment":"Get the adjusted size of the section in bytes (i.e., memory block) which relates to this section header; it may be zero\n if no block should be created.  The returned value reflects any adjustment the ElfExtension may require\n based upon the specific processor\/language implementation which may require filtering of file bytes\n as read into memory.","params":[],"throws":[],"return":{"type_long":"long","comment":"the number of bytes in the resulting memory block","type_short":"long"}},{"javadoc":"This member categorizes the section's contents and semantics.\n@return the section's contents and semantics","static":false,"name":"getType","comment":"This member categorizes the section's contents and semantics.","params":[],"throws":[],"return":{"type_long":"int","comment":"the section's contents and semantics","type_short":"int"}},{"javadoc":"Get header type as string.  ElfSectionHeaderType name will be returned\n if know, otherwise a numeric name of the form \"SHT_0x12345678\" will be returned.\n@return header type as string","static":false,"name":"getTypeAsString","comment":"Get header type as string.  ElfSectionHeaderType name will be returned\n if know, otherwise a numeric name of the form \"SHT_0x12345678\" will be returned.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"header type as string","type_short":"String"}},{"javadoc":"Returns the actual data bytes from the file for this section\n@return the actual data bytes from the file for this section\n@throws IOException if an I\/O error occurs while reading the file","static":false,"name":"getData","comment":"Returns the actual data bytes from the file for this section","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs while reading the file","type_short":"IOException"}],"return":{"type_long":"byte[]","comment":"the actual data bytes from the file for this section","type_short":"byte[]"}},{"javadoc":"Returns an input stream starting at offset into\n the byte provider.\n NOTE: Do not use this method if you have called setData().\n@return the input stream\n@throws IOException if an I\/O error occurs","static":false,"name":"getDataStream","comment":"Returns an input stream starting at offset into\n the byte provider.\n NOTE: Do not use this method if you have called setData().","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs","type_short":"IOException"}],"return":{"type_long":"java.io.InputStream","comment":"the input stream","type_short":"InputStream"}},{"javadoc":"Returns the binary reader.\n@return the binary reader","static":false,"name":"getReader","comment":"Returns the binary reader.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.BinaryReader","comment":"the binary reader","type_short":"BinaryReader"}},{"javadoc":"Sets the actual data bytes for this section.\n If the data is larger than the previous data, then \n the offset is set to -1 and the section will\n need to be relocated.\n@param data the new data byte for this section","static":false,"name":"setData","comment":"Sets the actual data bytes for this section.\n If the data is larger than the previous data, then \n the offset is set to -1 and the section will\n need to be relocated.","params":[{"type_long":"byte[]","name":"data","comment":"the new data byte for this section","type_short":"byte[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if the data bytes have changed for this section.\n@return true if the data bytes have changed for this section","static":false,"name":"isBytesChanged","comment":"Returns true if the data bytes have changed for this section.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if the data bytes have changed for this section","type_short":"boolean"}},{"javadoc":"Returns true if this section has been modified.\n A modified section requires that a new program header\n get created.\n@return true if this section has been modified","static":false,"name":"isModified","comment":"Returns true if this section has been modified.\n A modified section requires that a new program header\n get created.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this section has been modified","type_short":"boolean"}},{"javadoc":"Sets the offset of this section. The offset is the actual byte\n offset into the file.\n@param offset the file byte offset\n@throws IOException if an I\/O occurs","static":false,"name":"setOffset","comment":"Sets the offset of this section. The offset is the actual byte\n offset into the file.","params":[{"type_long":"long","name":"offset","comment":"the file byte offset","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the start address of this section.\n@param addr the new start address of this section","static":false,"name":"setAddress","comment":"Sets the start address of this section.","params":[{"type_long":"long","name":"addr","comment":"the new start address of this section","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the name of this section (may get changed due to conflict)\n@param name","static":false,"name":"setName","comment":"Sets the name of this section (may get changed due to conflict)","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.app.util.bin.StructConverter#toDataType()","static":false,"name":"toDataType","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"","static":false,"name":"getTypeDataType","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"","static":false,"name":"checkSize","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"obj","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"ElfSectionHeader","comment":"A class to represent the Elf32_Shdr data structure.\n \n \n typedef  int32_t  Elf32_Sword;\n typedef uint32_t  Elf32_Word;\n typedef uint32_t  Elf32_Addr;\n \n typedef struct {\n     Elf32_Word    sh_name;       \/\/Section name (string tbl index)\n     Elf32_Word    sh_type;       \/\/Section type\n     Elf32_Word    sh_flags;      \/\/Section flags\n     Elf32_Addr    sh_addr;       \/\/Section virtual addr at execution\n     Elf32_Off     sh_offset;     \/\/Section file offset\n     Elf32_Word    sh_size;       \/\/Section size in bytes\n     Elf32_Word    sh_link;       \/\/Link to another section\n     Elf32_Word    sh_info;       \/\/Additional section information\n     Elf32_Word    sh_addralign;  \/\/Section alignment\n     Elf32_Word    sh_entsize;    \/\/Entry size if section holds table *\n } Elf32_Shdr;\n \n typedef  uint32_t  Elf64_Word;\n typedef  uint64_t  Elf64_Xword;\n typedef  uint64_t  Elf64_Addr;\n typedef  uint64_t  Elf64_Off;\n \n typedef struct {\n     Elf64_Word    sh_name;       \/\/Section name (string tbl index)\n     Elf64_Word    sh_type;       \/\/Section type\n     Elf64_Xword   sh_flags;      \/\/Section flags\n     Elf64_Addr    sh_addr;       \/\/Section virtual addr at execution\n     Elf64_Off     sh_offset;     \/\/Section file offset\n     Elf64_Xword   sh_size;       \/\/Section size in bytes\n     Elf64_Word    sh_link;       \/\/Link to another section\n     Elf64_Word    sh_info;       \/\/Additional section information\n     Elf64_Xword   sh_addralign;  \/\/Section alignment\n     Elf64_Xword   sh_entsize;    \/\/Entry size if section holds table *\n } Elf64_Shdr;\n ","fields":[{"type_long":"int","javadoc":"","static":false,"name":"sh_name","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"sh_type","comment":"","type_short":"int","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"sh_flags","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"sh_addr","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"sh_offset","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"sh_size","comment":"","type_short":"long","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"sh_link","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"sh_info","comment":"","type_short":"int","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"sh_addralign","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"sh_entsize","comment":"","type_short":"long","constant_value":null},{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","javadoc":"","static":false,"name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader","constant_value":null},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","javadoc":"","static":false,"name":"header","comment":"","type_short":"ElfHeader","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"name","comment":"","type_short":"String","constant_value":null},{"type_long":"byte[]","javadoc":"","static":false,"name":"data","comment":"","type_short":"byte[]","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"modified","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"bytesChanged","comment":"","type_short":"boolean","constant_value":null}]}
