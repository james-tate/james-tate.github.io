{"implements":[],"javadoc":"","static":false,"extends":"ghidra.app.util.bin.format.omf.OmfRecord","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"","type_short":"BinaryReader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is usually the original source filename\n@return the name","static":false,"name":"getName","comment":"This is usually the original source filename","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name","type_short":"String"}},{"javadoc":"The name of the object module (within a library)\n@return the name","static":false,"name":"getLibraryModuleName","comment":"The name of the object module (within a library)","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name","type_short":"String"}},{"javadoc":"@return the string identifying the architecture this object was compiled for","static":false,"name":"getMachineName","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the string identifying the architecture this object was compiled for","type_short":"String"}},{"javadoc":"If the OMF file contains a \"translator\" record, this is usually a string\n indicating the compiler which produced the file.\n@return the translator for this file","static":false,"name":"getTranslator","comment":"If the OMF file contains a \"translator\" record, this is usually a string\n indicating the compiler which produced the file.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the translator for this file","type_short":"String"}},{"javadoc":"@return true if the file describes the load image for a little endian architecture","static":false,"name":"isLittleEndian","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if the file describes the load image for a little endian architecture","type_short":"boolean"}},{"javadoc":"@return the list of segments in this file","static":false,"name":"getSegments","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSegmentHeader>","comment":"the list of segments in this file","type_short":"ArrayList"}},{"javadoc":"@return the list of segments which are Borland extensions","static":false,"name":"getExtraSegments","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSegmentHeader>","comment":"the list of segments which are Borland extensions","type_short":"ArrayList"}},{"javadoc":"@return the list of group records for this file","static":false,"name":"getGroups","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfGroupRecord>","comment":"the list of group records for this file","type_short":"ArrayList"}},{"javadoc":"@return the list of symbols that are external to this file","static":false,"name":"getExternalSymbols","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfExternalSymbol>","comment":"the list of symbols that are external to this file","type_short":"ArrayList"}},{"javadoc":"@return the list of symbols exported by this file","static":false,"name":"getPublicSymbols","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSymbolRecord>","comment":"the list of symbols exported by this file","type_short":"ArrayList"}},{"javadoc":"@return the list of relocation records for this file","static":false,"name":"getFixups","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfFixupRecord>","comment":"the list of relocation records for this file","type_short":"ArrayList"}},{"javadoc":"Sort the explicit data-blocks for each segment into address order.","static":false,"name":"sortSegmentDataBlocks","comment":"Sort the explicit data-blocks for each segment into address order.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add a freshly parsed LEDATA record to its correct segment\n@param datablock is the LEDATA record\n@throws OmfException for a malformed segment index","static":false,"name":"addEnumeratedBlock","comment":"Add a freshly parsed LEDATA record to its correct segment","params":[{"type_long":"ghidra.app.util.bin.format.omf.OmfEnumeratedData","name":"datablock","comment":"is the LEDATA record","type_short":"OmfEnumeratedData"}],"throws":[{"type_long":"ghidra.app.util.bin.format.omf.OmfException","comment":"for a malformed segment index","type_short":"OmfException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Given an index, retrieve the specific segment it refers to. This\n incorporates the special Borland segments, where the index has \n the bit 0x4000 set.\n@param index identifies the segment\n@return the corresponding OmfSegmentHeader\n@throws OmfException if the index is malformed","static":false,"name":"resolveSegment","comment":"Given an index, retrieve the specific segment it refers to. This\n incorporates the special Borland segments, where the index has \n the bit 0x4000 set.","params":[{"type_long":"int","name":"index","comment":"identifies the segment","type_short":"int"}],"throws":[{"type_long":"ghidra.app.util.bin.format.omf.OmfException","comment":"if the index is malformed","type_short":"OmfException"}],"return":{"type_long":"ghidra.app.util.bin.format.omf.OmfSegmentHeader","comment":"the corresponding OmfSegmentHeader","type_short":"OmfSegmentHeader"}},{"javadoc":"Resolve special names associated with each segment: segment, class, overlay names\n and group: group name\n For each segment, the read\/write\/execute permissions are also determined\n@throws OmfException if any name indices are malformed","static":false,"name":"resolveNames","comment":"Resolve special names associated with each segment: segment, class, overlay names\n and group: group name\n For each segment, the read\/write\/execute permissions are also determined","params":[],"throws":[{"type_long":"ghidra.app.util.bin.format.omf.OmfException","comment":"if any name indices are malformed","type_short":"OmfException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Given an index, either find an existing Borland segment, or create a new one.\n Borland compilers can introduce special segments with a separate indexing\n scheme. These need to be stored in a separate list, while the loader needs\n to look up segments by index.\n@param index is the segment index\n@param datatype is the type of (new) segment\n@return the corresponding OmfSegmentHeader","static":false,"name":"createOrFindBorlandSegment","comment":"Given an index, either find an existing Borland segment, or create a new one.\n Borland compilers can introduce special segments with a separate indexing\n scheme. These need to be stored in a separate list, while the loader needs\n to look up segments by index.","params":[{"type_long":"int","name":"index","comment":"is the segment index","type_short":"int"},{"type_long":"int","name":"datatype","comment":"is the type of (new) segment","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.omf.OmfSegmentHeader","comment":"the corresponding OmfSegmentHeader","type_short":"OmfSegmentHeader"}},{"javadoc":"","static":false,"name":"evaluateComdef","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.omf.OmfComdefRecord","name":"comdef","comment":"","type_short":"OmfComdefRecord"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Scan the object file, for the main header and comment records. Other records are parsed but not saved\n@param reader is the byte stream\n@param monitor is checked for cancellation\n@param initialCommentsOnly is true if we only want to scan the header and the initial comments,\n@return the header record\n@throws IOException for problems reading program data\n@throws OmfException for malformed records","static":true,"name":"scan","comment":"Scan the object file, for the main header and comment records. Other records are parsed but not saved","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"is the byte stream","type_short":"BinaryReader"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"is checked for cancellation","type_short":"TaskMonitor"},{"type_long":"boolean","name":"initialCommentsOnly","comment":"is true if we only want to scan the header and the initial comments,","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"for problems reading program data","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.omf.OmfException","comment":"for malformed records","type_short":"OmfException"}],"return":{"type_long":"ghidra.app.util.bin.format.omf.OmfFileHeader","comment":"the header record","type_short":"OmfFileHeader"}},{"javadoc":"Parse the entire object file\n@param reader is the byte stream\n@param monitor is checked for cancel button\n@return the header record as root of object\n@throws IOException for problems reading data\n@throws OmfException for malformed records","static":true,"name":"parse","comment":"Parse the entire object file","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"is the byte stream","type_short":"BinaryReader"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"is checked for cancel button","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"for problems reading data","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.omf.OmfException","comment":"for malformed records","type_short":"OmfException"}],"return":{"type_long":"ghidra.app.util.bin.format.omf.OmfFileHeader","comment":"the header record as root of object","type_short":"OmfFileHeader"}},{"javadoc":"Assign a load image address to each segment. Follow OMF rules for grouping and ordering\n the segments in memory.\n@param startAddress is the base memory address for the load image\n@param segments is the list of segments\n@param groups is the list of specific segments that are grouped together in memory\n@throws OmfException for malformed index\/alignment\/combining fields","static":true,"name":"doLinking","comment":"Assign a load image address to each segment. Follow OMF rules for grouping and ordering\n the segments in memory.","params":[{"type_long":"long","name":"startAddress","comment":"is the base memory address for the load image","type_short":"long"},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSegmentHeader>","name":"segments","comment":"is the list of segments","type_short":"ArrayList"},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfGroupRecord>","name":"groups","comment":"is the list of specific segments that are grouped together in memory","type_short":"ArrayList"}],"throws":[{"type_long":"ghidra.app.util.bin.format.omf.OmfException","comment":"for malformed index\/alignment\/combining fields","type_short":"OmfException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Check that the file has the specific OMF magic number\n@param reader accesses the bytes of the file\n@return true if the magic number matches\n@throws IOException for problems reading bytes","static":true,"name":"checkMagicNumber","comment":"Check that the file has the specific OMF magic number","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"accesses the bytes of the file","type_short":"BinaryReader"}],"throws":[{"type_long":"java.io.IOException","comment":"for problems reading bytes","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if the magic number matches","type_short":"boolean"}},{"javadoc":"Create a reader for a specific OMF file\n@param provider is the underlying ByteProvider\n@return the new reader","static":true,"name":"createReader","comment":"Create a reader for a specific OMF file","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"is the underlying ByteProvider","type_short":"ByteProvider"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.BinaryReader","comment":"the new reader","type_short":"BinaryReader"}}],"name":"OmfFileHeader","comment":"","fields":[{"type_long":"java.lang.String","javadoc":"","static":false,"name":"objectName","comment":"","type_short":"String","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"libModuleName","comment":"","type_short":"String","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"translator","comment":"","type_short":"String","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"isLittleEndian","comment":"","type_short":"boolean","constant_value":null},{"type_long":"java.util.ArrayList<java.lang.String>","javadoc":"","static":false,"name":"nameList","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSegmentHeader>","javadoc":"","static":false,"name":"segments","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfGroupRecord>","javadoc":"","static":false,"name":"groups","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfExternalSymbol>","javadoc":"","static":false,"name":"externsymbols","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSymbolRecord>","javadoc":"","static":false,"name":"symbols","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfFixupRecord>","javadoc":"","static":false,"name":"fixup","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.util.bin.format.omf.OmfSegmentHeader>","javadoc":"","static":false,"name":"extraSeg","comment":"","type_short":"ArrayList","constant_value":null}]}
