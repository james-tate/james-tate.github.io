{"implements":[],"javadoc":"This class is analogous to GhidraScript, except that is only meant to be used with\n the HeadlessAnalyzer.  That is, if a user writes a script that extends HeadlessScript,\n it should only be run in the Headless environment.","static":false,"extends":"ghidra.app.script.GhidraScript","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setRunningInnerScript","comment":"","params":[{"type_long":"boolean","name":"b","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the current headless instance -- doing so gives the user the ability to manipulate \n headless analyzer-specific parameters.\n <p>\n This method is declared with no access modifier to only allow package-level (no subclass) \n access. This method is meant to only be used by the HeadlessAnalyzer class.\n@param ha HeadlessAnalyzer instance","static":false,"name":"setHeadlessInstance","comment":"Sets the current headless instance -- doing so gives the user the ability to manipulate \n headless analyzer-specific parameters.\n \n This method is declared with no access modifier to only allow package-level (no subclass) \n access. This method is meant to only be used by the HeadlessAnalyzer class.","params":[{"type_long":"ghidra.app.util.headless.HeadlessAnalyzer","name":"ha","comment":"HeadlessAnalyzer instance","type_short":"HeadlessAnalyzer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the \"beginning-of-script\" continuation status.\n <p>\n This method is declare with no access modifier to only allow package-level (no\n subclass) access. This method is meant to only be used by the HeadlessAnalyzer class.\n@param option initial continuation option for this script","static":false,"name":"setInitialContinuationOption","comment":"Sets the \"beginning-of-script\" continuation status.\n \n This method is declare with no access modifier to only allow package-level (no\n subclass) access. This method is meant to only be used by the HeadlessAnalyzer class.","params":[{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","name":"option","comment":"initial continuation option for this script","type_short":"HeadlessContinuationOption"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the final resolved continuation option (after script processing is done).\n <p>\n The continuation option specifies whether to continue or abort follow-on processing,\n and whether to delete or keep the current program.\n <p>\n This method is declared with no access modifier to only allow package-level (no\n subclass) access. This method is meant to only be used by the HeadlessAnalyzer class.\n@return the script's final HeadlessContinuationOption","static":false,"name":"getContinuationOption","comment":"Returns the final resolved continuation option (after script processing is done).\n \n The continuation option specifies whether to continue or abort follow-on processing,\n and whether to delete or keep the current program.\n \n This method is declared with no access modifier to only allow package-level (no\n subclass) access. This method is meant to only be used by the HeadlessAnalyzer class.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","comment":"the script's final HeadlessContinuationOption","type_short":"HeadlessContinuationOption"}},{"javadoc":"Checks to see if this script is running in headless mode (it should be!).\n <p>\n This method should be called at the beginning of every public method in HeadlessScript\n that accesses HeadlessAnalyzer methods (for instance, 'headless.isAnalysisEnabled()').\n The call to this method can not be placed in the constructor, because 'setHeadlessInstance', \n which connects the script with the current headless instance, is not called until after the \n call to the constructor.\n@throws ImproperUseException if not in headless mode or headless instance not set","static":false,"name":"checkHeadlessStatus","comment":"Checks to see if this script is running in headless mode (it should be!).\n \n This method should be called at the beginning of every public method in HeadlessScript\n that accesses HeadlessAnalyzer methods (for instance, 'headless.isAnalysisEnabled()').\n The call to this method can not be placed in the constructor, because 'setHeadlessInstance', \n which connects the script with the current headless instance, is not called until after the \n call to the constructor.","params":[],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Stores a key\/value pair in the HeadlessAnalyzer instance for later use.\n <p>\n This method, along with the 'getStoredHeadlessValue' method, is useful for debugging and \n testing the Headless Analyzer (when the user has directly instantiated the HeadlessAnalyzer\n instead of running it from analyzeHeadless.sh or analyzeHeadless.bat). This method is\n intended to allow a HeadlessScript to store variables that reflect the current state of \n processing (at the time the script is being run). Storing variables in the HeadlessAnalyzer\n instance may be the only way to access the state of processing during cases when the user \n is forced to run in -readOnly mode, or if there is a value that is only accessible at the \n scripts stage.\n@param key storage key in String form\n@param value value to store\n@throws ImproperUseException if not in headless mode or headless instance not set\n@see #getStoredHeadlessValue(String)\n@see #headlessStorageContainsKey(String)","static":false,"name":"storeHeadlessValue","comment":"Stores a key\/value pair in the HeadlessAnalyzer instance for later use.\n \n This method, along with the 'getStoredHeadlessValue' method, is useful for debugging and \n testing the Headless Analyzer (when the user has directly instantiated the HeadlessAnalyzer\n instead of running it from analyzeHeadless.sh or analyzeHeadless.bat). This method is\n intended to allow a HeadlessScript to store variables that reflect the current state of \n processing (at the time the script is being run). Storing variables in the HeadlessAnalyzer\n instance may be the only way to access the state of processing during cases when the user \n is forced to run in -readOnly mode, or if there is a value that is only accessible at the \n scripts stage.","params":[{"type_long":"java.lang.String","name":"key","comment":"storage key in String form","type_short":"String"},{"type_long":"java.lang.Object","name":"value","comment":"value to store","type_short":"Object"}],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get stored value by key from the HeadlessAnalyzer instance.\n <p>\n This method, along with the 'storedHeadlessValue' method, is useful for debugging and \n testing the Headless Analyzer (when the user has directly instantiated the HeadlessAnalyzer\n instead of running it from analyzeHeadless.sh or analyzeHeadless.bat). This method is\n intended to allow a HeadlessScript to store variables that reflect the current state of \n processing (at the time the script is being run). Storing variables in the HeadlessAnalyzer\n instance may be the only way to access the state of processing during cases when the user \n is forced to run in -readOnly mode, or if there is a value that is only accessible at the \n scripts stage.\n@param key key to retrieve the desired stored value\n@return stored Object, or null if none exists for that key\n@throws ImproperUseException if not in headless mode or headless instance not set\n@see #storeHeadlessValue(String, Object)\n@see #headlessStorageContainsKey(String)","static":false,"name":"getStoredHeadlessValue","comment":"Get stored value by key from the HeadlessAnalyzer instance.\n \n This method, along with the 'storedHeadlessValue' method, is useful for debugging and \n testing the Headless Analyzer (when the user has directly instantiated the HeadlessAnalyzer\n instead of running it from analyzeHeadless.sh or analyzeHeadless.bat). This method is\n intended to allow a HeadlessScript to store variables that reflect the current state of \n processing (at the time the script is being run). Storing variables in the HeadlessAnalyzer\n instance may be the only way to access the state of processing during cases when the user \n is forced to run in -readOnly mode, or if there is a value that is only accessible at the \n scripts stage.","params":[{"type_long":"java.lang.String","name":"key","comment":"key to retrieve the desired stored value","type_short":"String"}],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"java.lang.Object","comment":"stored Object, or null if none exists for that key","type_short":"Object"}},{"javadoc":"Returns whether the specified key was stored in the HeadlessAnalyzer instance.\n@param key value of key to check for in Headless Analyzer instance\n@return true if the specified key exists\n@throws ImproperUseException if not in headless mode or headless instance not set\n@see #storeHeadlessValue(String, Object)\n@see #getStoredHeadlessValue(String)","static":false,"name":"headlessStorageContainsKey","comment":"Returns whether the specified key was stored in the HeadlessAnalyzer instance.","params":[{"type_long":"java.lang.String","name":"key","comment":"value of key to check for in Headless Analyzer instance","type_short":"String"}],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"boolean","comment":"true if the specified key exists","type_short":"boolean"}},{"javadoc":"Sets the continuation option for this script\n <p>\n The continuation option specifies whether to continue or abort follow-on processing,\n and whether to delete or keep the current program.\n@param option HeadlessContinuationOption set by this script\n@see #getHeadlessContinuationOption()","static":false,"name":"setHeadlessContinuationOption","comment":"Sets the continuation option for this script\n \n The continuation option specifies whether to continue or abort follow-on processing,\n and whether to delete or keep the current program.","params":[{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","name":"option","comment":"HeadlessContinuationOption set by this script","type_short":"HeadlessContinuationOption"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the continuation option for the current script (if one has not been set in this\n script, the option defaults to CONTINUE).\n <p>\n The continuation option specifies whether to continue or abort follow-on processing,\n and whether to delete or keep the current program.\n@return the current HeadlessContinuationOption\n@see #setHeadlessContinuationOption(HeadlessContinuationOption)","static":false,"name":"getHeadlessContinuationOption","comment":"Returns the continuation option for the current script (if one has not been set in this\n script, the option defaults to CONTINUE).\n \n The continuation option specifies whether to continue or abort follow-on processing,\n and whether to delete or keep the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","comment":"the current HeadlessContinuationOption","type_short":"HeadlessContinuationOption"}},{"javadoc":"Enables or disables analysis according to the passed-in boolean value.\n <p>\n A script that calls this method should run as a 'preScript', since preScripts\n execute before analysis would typically run. Running the script as a 'postScript'\n is ineffective, since the stage at which analysis would have happened has already \n passed.\n <p>\n This change will persist throughout the current HeadlessAnalyzer session, unless\n changed again (in other words, once analysis is enabled via script for one program,\n it will also be enabled for future programs in the current session, unless changed).\n@param b true to enable analysis, false to disable analysis\n@throws ImproperUseException if not in headless mode or headless instance not set\n@see #isHeadlessAnalysisEnabled()","static":false,"name":"enableHeadlessAnalysis","comment":"Enables or disables analysis according to the passed-in boolean value.\n \n A script that calls this method should run as a 'preScript', since preScripts\n execute before analysis would typically run. Running the script as a 'postScript'\n is ineffective, since the stage at which analysis would have happened has already \n passed.\n \n This change will persist throughout the current HeadlessAnalyzer session, unless\n changed again (in other words, once analysis is enabled via script for one program,\n it will also be enabled for future programs in the current session, unless changed).","params":[{"type_long":"boolean","name":"b","comment":"true to enable analysis, false to disable analysis","type_short":"boolean"}],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns whether analysis is currently enabled or disabled in the HeadlessAnalyzer.\n@return whether analysis has been enabled or not\n@throws ImproperUseException if not in headless mode or headless instance not set\n@see #enableHeadlessAnalysis(boolean)","static":false,"name":"isHeadlessAnalysisEnabled","comment":"Returns whether analysis is currently enabled or disabled in the HeadlessAnalyzer.","params":[],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"boolean","comment":"whether analysis has been enabled or not","type_short":"boolean"}},{"javadoc":"Returns whether the headless analyzer is currently set to -import mode or not (if not,\n it is in -process mode). The use of -import mode implies that binaries are actively being\n imported into the project (with optional scripts\/analysis). The use of -process mode implies\n that existing project files are being processed (using scripts and\/or analysis).\n@return whether we are in -import mode or not\n@throws ImproperUseException if not in headless mode or headless instance not set","static":false,"name":"isImporting","comment":"Returns whether the headless analyzer is currently set to -import mode or not (if not,\n it is in -process mode). The use of -import mode implies that binaries are actively being\n imported into the project (with optional scripts\/analysis). The use of -process mode implies\n that existing project files are being processed (using scripts and\/or analysis).","params":[],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"boolean","comment":"whether we are in -import mode or not","type_short":"boolean"}},{"javadoc":"Changes the path <i>in the Ghidra project<\/i> where imported files are saved. \n The passed-in path is assumed to be relative to the project root. For example,\n if the directory structure for the Ghidra project looks like this:\n \n <pre>\n \t\tMyGhidraProject:\n \t\t  \/dir1\n \t\t    \/innerDir1\n \t\t    \/innerDir2\n <\/pre>\n \n Then the following usage would ensure that any files imported after this call would\n be saved in the <tt>MyGhidraProject:\/dir1\/innerDir2<\/tt> folder.\n <pre>\n \t\tsetHeadlessImportDirectory(\"dir1\/innerDir2\");\n <\/pre>\n In contrast, the following usages would add new folders to the Ghidra project and save\n the imported files into the newly-created path:\n <pre>\n \t\tsetHeadlessImportDirectory(\"innerDir2\/my\/folder\");\n <\/pre>\n changes the directory structure to:\n <pre>\n \t\tMyGhidraProject:\n \t\t  \/dir1\n \t\t    \/innerDir1\n \t\t    \/innerDir2\n \t\t      \/my\n \t\t        \/folder\n <\/pre>\n and:\n <pre>\n \t\tsetHeadlessImportDirectory(\"newDir\/saveHere\");\n <\/pre>\n changes the directory structure to:\n <pre>\n \t\tMyGhidraProject:\n \t\t  \/dir1\n \t\t    \/innerDir1\n \t\t\t\/innerDir2\n\t\t  \/newDir\n \t\t    \/saveHere\n <\/pre>\n As in the examples above, if the desired folder does not already exist, it is created.\n <p>\n A change in the import save folder will persist throughout the current HeadlessAnalyzer \n session, unless changed again (in other words, once the import directory has been changed, \n it will remain the 'save' directory for import files in the current session, unless changed).\n <p>\n To revert back to the default import location (that which was specified via command line),\n pass the null object as the argument to this method, as below:\n <pre>\n \t\tsetHeadlessImportDirectory(null);\t\/\/ Sets import save directory to default\n <\/pre>\n If a file with the same name already exists in the desired location, it will only be \n overwritten if \"-overwrite\" is true.\n <p>\n This method is only applicable when using the HeadlessAnalyzer <tt>-import<\/tt> mode and \n is ineffective in <tt>-process<\/tt> mode.\n@param importDir the absolute path (relative to root) where inputs will be saved\n@throws ImproperUseException if not in headless mode or headless instance not set\n@throws IOException if there are issues creating the folder\n@throws InvalidNameException if folder name is invalid","static":false,"name":"setHeadlessImportDirectory","comment":"Changes the path in the Ghidra project where imported files are saved. \n The passed-in path is assumed to be relative to the project root. For example,\n if the directory structure for the Ghidra project looks like this:\n \n \n \t\tMyGhidraProject:\n \t\t  \/dir1\n \t\t    \/innerDir1\n \t\t    \/innerDir2\n \n \n Then the following usage would ensure that any files imported after this call would\n be saved in the MyGhidraProject:\/dir1\/innerDir2 folder.\n \n \t\tsetHeadlessImportDirectory(\"dir1\/innerDir2\");\n \n In contrast, the following usages would add new folders to the Ghidra project and save\n the imported files into the newly-created path:\n \n \t\tsetHeadlessImportDirectory(\"innerDir2\/my\/folder\");\n \n changes the directory structure to:\n \n \t\tMyGhidraProject:\n \t\t  \/dir1\n \t\t    \/innerDir1\n \t\t    \/innerDir2\n \t\t      \/my\n \t\t        \/folder\n \n and:\n \n \t\tsetHeadlessImportDirectory(\"newDir\/saveHere\");\n \n changes the directory structure to:\n \n \t\tMyGhidraProject:\n \t\t  \/dir1\n \t\t    \/innerDir1\n \t\t\t\/innerDir2\n\t\t  \/newDir\n \t\t    \/saveHere\n \n As in the examples above, if the desired folder does not already exist, it is created.\n \n A change in the import save folder will persist throughout the current HeadlessAnalyzer \n session, unless changed again (in other words, once the import directory has been changed, \n it will remain the 'save' directory for import files in the current session, unless changed).\n \n To revert back to the default import location (that which was specified via command line),\n pass the null object as the argument to this method, as below:\n \n \t\tsetHeadlessImportDirectory(null);\t\/\/ Sets import save directory to default\n \n If a file with the same name already exists in the desired location, it will only be \n overwritten if \"-overwrite\" is true.\n \n This method is only applicable when using the HeadlessAnalyzer -import mode and \n is ineffective in -process mode.","params":[{"type_long":"java.lang.String","name":"importDir","comment":"the absolute path (relative to root) where inputs will be saved","type_short":"String"}],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"},{"type_long":"java.io.IOException","comment":"if there are issues creating the folder","type_short":"IOException"},{"type_long":"ghidra.util.InvalidNameException","comment":"if folder name is invalid","type_short":"InvalidNameException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns whether analysis for the current program has timed out.\n <p>\n Analysis will time out only in the case where:\n <ol>\n \t\t<li>the users has set an analysis timeout period using the <tt>-analysisTimeoutPerFile<\/tt>\n \tparameter<\/li>\n \t\t<li>analysis is enabled and has completed<\/li>\n \t\t<li>the current script is being run as a postScript (since postScripts run after\n analysis)<\/li>\n <\/ol>\n@return whether analysis timeout occurred\n@throws ImproperUseException if not in headless mode or headless instance not set","static":false,"name":"analysisTimeoutOccurred","comment":"Returns whether analysis for the current program has timed out.\n \n Analysis will time out only in the case where:\n \n \t\tthe users has set an analysis timeout period using the -analysisTimeoutPerFile\n \tparameter\n \t\tanalysis is enabled and has completed\n \t\tthe current script is being run as a postScript (since postScripts run after\n analysis)\n ","params":[],"throws":[{"type_long":"ghidra.app.script.ImproperUseException","comment":"if not in headless mode or headless instance not set","type_short":"ImproperUseException"}],"return":{"type_long":"boolean","comment":"whether analysis timeout occurred","type_short":"boolean"}},{"javadoc":"","static":false,"name":"runScript","comment":"","params":[{"type_long":"java.lang.String","name":"scriptName","comment":"","type_short":"String"},{"type_long":"java.lang.String[]","name":"scriptArguments","comment":"","type_short":"java.lang.String[]"},{"type_long":"ghidra.app.script.GhidraState","name":"scriptState","comment":"","type_short":"GhidraState"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cleanup","comment":"","params":[{"type_long":"boolean","name":"success","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"resolveContinuationOption","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Resolve continuation options according to the table in 'analyzeHeadlessREADME.html'.\n (See \"Multiple Scripts\" section).\n@param opt continuation option to combine with current continuation option","static":false,"name":"resolveContinuationOptionWith","comment":"Resolve continuation options according to the table in 'analyzeHeadlessREADME.html'.\n (See \"Multiple Scripts\" section).","params":[{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","name":"opt","comment":"continuation option to combine with current continuation option","type_short":"HeadlessContinuationOption"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"HeadlessScript","comment":"This class is analogous to GhidraScript, except that is only meant to be used with\n the HeadlessAnalyzer.  That is, if a user writes a script that extends HeadlessScript,\n it should only be run in the Headless environment.","fields":[{"type_long":"ghidra.app.util.headless.HeadlessAnalyzer","javadoc":"","static":false,"name":"headless","comment":"","type_short":"HeadlessAnalyzer","constant_value":null},{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","javadoc":"","static":false,"name":"currentOption","comment":"","type_short":"HeadlessContinuationOption","constant_value":null},{"type_long":"ghidra.app.util.headless.HeadlessScript.HeadlessContinuationOption","javadoc":"","static":false,"name":"scriptSetOption","comment":"","type_short":"HeadlessContinuationOption","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"runningInnerScript","comment":"","type_short":"boolean","constant_value":null}]}
