{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Decompile the given functions using multiple decompilers\n@param callback the callback to be called for each that is processed\n@param program the program\n@param addresses the addresses restricting which functions to decompile\n@param monitor the task monitor\n@return the list of client results\n@throws InterruptedException if interrupted\n@throws Exception if any other exception occurs","static":true,"name":"decompileFunctions","comment":"Decompile the given functions using multiple decompilers","params":[{"type_long":"generic.concurrent.QCallback<ghidra.program.model.listing.Function,R>","name":"callback","comment":"the callback to be called for each that is processed","type_short":"QCallback"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program","type_short":"Program"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"addresses","comment":"the addresses restricting which functions to decompile","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if interrupted","type_short":"InterruptedException"},{"type_long":"java.lang.Exception","comment":"if any other exception occurs","type_short":"Exception"}],"return":{"type_long":"java.util.List<R>","comment":"the list of client results","type_short":"List"}},{"javadoc":"Decompile the given functions using multiple decompilers\n@param callback the callback to be called for each that is processed\n@param program the program\n@param functions the functions to decompile\n@param monitor the task monitor\n@return the list of client results\n@throws InterruptedException if interrupted\n@throws Exception if any other exception occurs","static":true,"name":"decompileFunctions","comment":"Decompile the given functions using multiple decompilers","params":[{"type_long":"generic.concurrent.QCallback<ghidra.program.model.listing.Function,R>","name":"callback","comment":"the callback to be called for each that is processed","type_short":"QCallback"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program","type_short":"Program"},{"type_long":"java.util.Collection<ghidra.program.model.listing.Function>","name":"functions","comment":"the functions to decompile","type_short":"Collection"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if interrupted","type_short":"InterruptedException"},{"type_long":"java.lang.Exception","comment":"if any other exception occurs","type_short":"Exception"}],"return":{"type_long":"java.util.List<R>","comment":"the list of client results","type_short":"List"}},{"javadoc":"","static":true,"name":"decompileFunctions","comment":"","params":[{"type_long":"generic.concurrent.QCallback<ghidra.program.model.listing.Function,R>","name":"callback","comment":"","type_short":"QCallback"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"java.util.Iterator<ghidra.program.model.listing.Function>","name":"functions","comment":"","type_short":"Iterator"},{"type_long":"int","name":"count","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.InterruptedException","comment":"","type_short":"InterruptedException"},{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"java.util.List<R>","comment":"","type_short":"List"}},{"javadoc":"Creates an object that can be used to perform decompilation of a limited number of \n functions at a time, as opposed to working over an entire range of functions at once.\n {@link #decompileFunctions(QCallback, Program, AddressSetView, TaskMonitor)} will create\n and tear down concurrent data structures on each use, making repeated calls less efficient.\n You would use this method when you wish to perform periodic work as results are returned \n <b>and when using the callback mechanism is not sufficient<\/b> such as when ordering of\n results is required.\n@param callback the callback required to perform work.\n@param monitor the monitor used to report progress and to cancel\n@return the parallel decompiler used for decompiling.","static":true,"name":"createChunkingParallelDecopmiler","comment":"Creates an object that can be used to perform decompilation of a limited number of \n functions at a time, as opposed to working over an entire range of functions at once.\n #decompileFunctions(QCallback, Program, AddressSetView, TaskMonitor) will create\n and tear down concurrent data structures on each use, making repeated calls less efficient.\n You would use this method when you wish to perform periodic work as results are returned \n and when using the callback mechanism is not sufficient such as when ordering of\n results is required.","params":[{"type_long":"generic.concurrent.QCallback<ghidra.program.model.listing.Function,R>","name":"callback","comment":"the callback required to perform work.","type_short":"QCallback"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the monitor used to report progress and to cancel","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.app.decompiler.parallel.ChunkingParallelDecompiler<R>","comment":"the parallel decompiler used for decompiling.","type_short":"ChunkingParallelDecompiler"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"ParallelDecompiler","comment":"","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"THREAD_POOL_NAME","comment":"","type_short":"String","constant_value":"\"Parallel Decompiler\""}]}
