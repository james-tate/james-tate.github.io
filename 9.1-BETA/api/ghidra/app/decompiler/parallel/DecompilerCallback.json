{"implements":["generic.concurrent.QCallback"],"javadoc":"An implementation of {@link QCallback} that performs the management of the \n {@link DecompInterface} instances using a Pool.\n \n <P>Clients will get a chance to configure each newly created decompiler via the passed-in\n {@link DecompileConfigurer}.\n \n <P>Clients must implement {@link #process(DecompileResults, TaskMonitor)}, which will be\n called for each function that is decompiled.\n@param <R> the return type","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.app.decompiler.parallel.DecompileConfigurer","name":"configurer","comment":"","type_short":"DecompileConfigurer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This is called when a function is decompiled.\n@param results the decompiled results\n@param monitor the task monitor\n@return the client result\n@throws Exception if there is any issue processing the given results","static":false,"name":"process","comment":"This is called when a function is decompiled.","params":[{"type_long":"ghidra.app.decompiler.DecompileResults","name":"results","comment":"the decompiled results","type_short":"DecompileResults"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.Exception","comment":"if there is any issue processing the given results","type_short":"Exception"}],"return":{"type_long":"R","comment":"the client result","type_short":"R"}},{"javadoc":"","static":false,"name":"process","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"f","comment":"","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"R","comment":"","type_short":"R"}},{"javadoc":"Sets the timeout for each decompile\n@param timeoutSecs the timeout in seconds","static":false,"name":"setTimeout","comment":"Sets the timeout for each decompile","params":[{"type_long":"int","name":"timeoutSecs","comment":"the timeout in seconds","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Call this when all work is done so that the pooled decompilers can be disposed","static":false,"name":"dispose","comment":"Call this when all work is done so that the pooled decompilers can be disposed","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"DecompilerCallback","comment":"An implementation of QCallback that performs the management of the \n DecompInterface instances using a Pool.\n \n Clients will get a chance to configure each newly created decompiler via the passed-in\n DecompileConfigurer.\n \n Clients must implement #process(DecompileResults, TaskMonitor), which will be\n called for each function that is decompiled.","fields":[{"type_long":"generic.cache.CachingPool<ghidra.app.decompiler.DecompInterface>","javadoc":"","static":false,"name":"pool","comment":"","type_short":"CachingPool","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"timeout","comment":"","type_short":"int","constant_value":null}]}
