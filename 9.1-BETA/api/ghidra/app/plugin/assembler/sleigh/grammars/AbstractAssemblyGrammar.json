{"implements":["java.lang.Iterable"],"javadoc":"Defines a context-free grammar, usually for the purpose of parsing mnemonic assembly instructions\n \n As in classic computer science, a CFG consists of productions of non-terminals and terminals.\n The left-hand side of the a production must be a single non-terminal, but the right-hand side\n may be any string of symbols. To avoid overloading the term \"String,\" here we call it a\n \"Sentential.\"\n \n To define a grammar, simply construct an appropriate subclass (probably {@link AssemblyGrammar})\n and call {@link #addProduction(AbstractAssemblyProduction)} or\n {@link #addProduction(AssemblyNonTerminal, AssemblySentential). The grammar object will collect\n the non-terminals and terminals.\n \n By default, the start symbol is taken from the left-hand side of the first production added to\n the grammar.\n@param <NT> the type of non-terminals\n@param <T> the type of terminals\n@param <P> the type of productions, which must have the same types of (non-)terminals.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Because a subclass may have a different type of production, it must provide a mechanism for\n constructing an appropriate production given just the LHS and RHS.\n@param lhs the left-hand side of the production\n@param rhs the right-hand side of the production\n@return the constructed production","static":false,"name":"newProduction","comment":"Because a subclass may have a different type of production, it must provide a mechanism for\n constructing an appropriate production given just the LHS and RHS.","params":[{"type_long":"NT","name":"lhs","comment":"the left-hand side of the production","type_short":"NT"},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential<NT>","name":"rhs","comment":"the right-hand side of the production","type_short":"AssemblySentential"}],"throws":[],"return":{"type_long":"P","comment":"the constructed production","type_short":"P"}},{"javadoc":"Add a production to the grammar\n@param lhs the left-hand side\n@param rhs the right-hand side","static":false,"name":"addProduction","comment":"Add a production to the grammar","params":[{"type_long":"NT","name":"lhs","comment":"the left-hand side","type_short":"NT"},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential<NT>","name":"rhs","comment":"the right-hand side","type_short":"AssemblySentential"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add a production to the grammar\n@param prod the production","static":false,"name":"addProduction","comment":"Add a production to the grammar","params":[{"type_long":"P","name":"prod","comment":"the production","type_short":"P"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Check if the given production is purely recursive, i.e., of the form I => I\n@param prod the production to check\n@return true iff the production is purely recursive","static":false,"name":"isPureRecursive","comment":"Check if the given production is purely recursive, i.e., of the form I = I","params":[{"type_long":"P","name":"prod","comment":"the production to check","type_short":"P"}],"throws":[],"return":{"type_long":"boolean","comment":"true iff the production is purely recursive","type_short":"boolean"}},{"javadoc":"Change the start symbol for the grammar\n@param nt the new start symbol","static":false,"name":"setStart","comment":"Change the start symbol for the grammar","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblyNonTerminal","name":"nt","comment":"the new start symbol","type_short":"AssemblyNonTerminal"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Change the start symbol for the grammar\n@param startName the name of the new start symbol","static":false,"name":"setStartName","comment":"Change the start symbol for the grammar","params":[{"type_long":"java.lang.String","name":"startName","comment":"the name of the new start symbol","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the start symbol for the grammar\n@return the start symbol","static":false,"name":"getStart","comment":"Get the start symbol for the grammar","params":[],"throws":[],"return":{"type_long":"NT","comment":"the start symbol","type_short":"NT"}},{"javadoc":"Get the name of the start symbol for the grammar\n@return the name of the start symbol","static":false,"name":"getStartName","comment":"Get the name of the start symbol for the grammar","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name of the start symbol","type_short":"String"}},{"javadoc":"Get the named non-terminal\n@param name the name of the desired non-terminal\n@return the non-terminal, or null if it is not in this grammar","static":false,"name":"getNonTerminal","comment":"Get the named non-terminal","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the desired non-terminal","type_short":"String"}],"throws":[],"return":{"type_long":"NT","comment":"the non-terminal, or null if it is not in this grammar","type_short":"NT"}},{"javadoc":"Get the named terminal\n@param name the name of the desired terminal\n@return the terminal, or null if it is not in this grammar","static":false,"name":"getTerminal","comment":"Get the named terminal","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the desired terminal","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal","comment":"the terminal, or null if it is not in this grammar","type_short":"AssemblyTerminal"}},{"javadoc":"Add all the productions of a given grammar to this one\n@param that the grammar whose productions to add","static":false,"name":"combine","comment":"Add all the productions of a given grammar to this one","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AbstractAssemblyGrammar<NT,P>","name":"that","comment":"the grammar whose productions to add","type_short":"AbstractAssemblyGrammar"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Print the productions of this grammar to the given stream\n@param out the stream","static":false,"name":"print","comment":"Print the productions of this grammar to the given stream","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"the stream","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Check that the grammar is consistent\n \n The grammar is consistent if every non-terminal appearing in the grammar, also appears as\n the left-hand side of some production. If not, such non-terminals are said to be undefined.\n@throws AssemblyGrammarException the grammar is inconsistent, i.e., contains undefined\n                                  non-terminals.","static":false,"name":"verify","comment":"Check that the grammar is consistent\n \n The grammar is consistent if every non-terminal appearing in the grammar, also appears as\n the left-hand side of some production. If not, such non-terminals are said to be undefined.","params":[],"throws":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammarException","comment":"the grammar is inconsistent, i.e., contains undefined\n                                  non-terminals.","type_short":"AssemblyGrammarException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Traverse the productions","static":false,"name":"iterator","comment":"Traverse the productions","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<P>","comment":"","type_short":"Iterator"}},{"javadoc":"Get the non-terminals\n@return ","static":false,"name":"nonTerminals","comment":"Get the non-terminals","params":[],"throws":[],"return":{"type_long":"java.util.Collection<NT>","comment":"","type_short":"Collection"}},{"javadoc":"Get the terminals\n@return ","static":false,"name":"terminals","comment":"Get the terminals","params":[],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal>","comment":"","type_short":"Collection"}},{"javadoc":"Get all productions where the left-hand side non-terminal has the given name\n@param name the name of the non-terminal\n@return all productions \"defining\" the named non-terminal","static":false,"name":"productionsOf","comment":"Get all productions where the left-hand side non-terminal has the given name","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the non-terminal","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.Collection<P>","comment":"all productions \"defining\" the named non-terminal","type_short":"Collection"}},{"javadoc":"Get all productions where the left-hand side is the given non-terminal\n@param nt the non-terminal whose defining productions to find\n@return all productions \"defining\" the given non-terminal","static":false,"name":"productionsOf","comment":"Get all productions where the left-hand side is the given non-terminal","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblyNonTerminal","name":"nt","comment":"the non-terminal whose defining productions to find","type_short":"AssemblyNonTerminal"}],"throws":[],"return":{"type_long":"java.util.Collection<P>","comment":"all productions \"defining\" the given non-terminal","type_short":"Collection"}},{"javadoc":"Check if the grammar contains any symbol with the given name\n@param name the name to find\n@return true iff a terminal or non-terminal has the given name","static":false,"name":"contains","comment":"Check if the grammar contains any symbol with the given name","params":[{"type_long":"java.lang.String","name":"name","comment":"the name to find","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true iff a terminal or non-terminal has the given name","type_short":"boolean"}}],"name":"AbstractAssemblyGrammar","comment":"Defines a context-free grammar, usually for the purpose of parsing mnemonic assembly instructions\n \n As in classic computer science, a CFG consists of productions of non-terminals and terminals.\n The left-hand side of the a production must be a single non-terminal, but the right-hand side\n may be any string of symbols. To avoid overloading the term \"String,\" here we call it a\n \"Sentential.\"\n \n To define a grammar, simply construct an appropriate subclass (probably AssemblyGrammar)\n and call #addProduction(AbstractAssemblyProduction) or\n  The grammar object will collect\n the non-terminals and terminals.\n \n By default, the start symbol is taken from the left-hand side of the first production added to\n the grammar.","fields":[{"type_long":"org.apache.commons.collections4.MultiValuedMap<java.lang.String,P>","javadoc":"","static":false,"name":"productions","comment":"","type_short":"MultiValuedMap","constant_value":null},{"type_long":"java.util.List<P>","javadoc":"","static":false,"name":"prodList","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.Map<java.lang.String,NT>","javadoc":"","static":false,"name":"nonterminals","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<java.lang.String,ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal>","javadoc":"","static":false,"name":"terminals","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<java.lang.String,ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol>","javadoc":"","static":false,"name":"symbols","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"startName","comment":"","type_short":"String","constant_value":null}]}
