{"implements":[],"javadoc":"The workhorse of semantic resolution for the assembler\n \n This class takes a parse tree and some additional information (start address, context, etc.) and\n attempts to determine possible encodings using the semantics associated with each branch of the\n given parse tree. Details of this process are described in {@link SleighAssemblerBuilder}.\n@see SleighAssemblerBuilder","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a resolver for the given parse tree\n@param lang\n@param instStart the byte offset where the instruction will start\n@param tree the parse tree\n@param context the context expected at {@code instStart}\n@param ctxGraph the context transition graph used to resolve purely-recursive productions","static":false,"name":"<init>","comment":"Construct a resolver for the given parse tree","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","name":"lang","comment":"","type_short":"SleighLanguage"},{"type_long":"long","name":"instStart","comment":"the byte offset where the instruction will start","type_short":"long"},{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","name":"tree","comment":"the parse tree","type_short":"AssemblyParseBranch"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"context","comment":"the context expected at ","type_short":"AssemblyPatternBlock"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph","name":"ctxGraph","comment":"the context transition graph used to resolve purely-recursive productions","type_short":"AssemblyContextGraph"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Resolve the tree for the given parameters\n@return a set of resolutions (encodings and errors)","static":false,"name":"resolve","comment":"Resolve the tree for the given parameters","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"a set of resolutions (encodings and errors)","type_short":"AssemblyResolutionResults"}},{"javadoc":"Resolve a branch of the parse tree\n@param branch the branch\n@return the intermediate results","static":false,"name":"resolveBranch","comment":"Resolve a branch of the parse tree","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","name":"branch","comment":"the branch","type_short":"AssemblyParseBranch"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the intermediate results","type_short":"AssemblyResolutionResults"}},{"javadoc":"Apply constructors as indicated by a path returned by the context resolution graph\n \n Please note: The path given will be emptied during processing.\n@param path the path to apply\n@param branch the branch corresponding to the production whose LHS has a purely-recursive\n            definition.\n@param rec the purely-recursive production\n@param child the intermediate result to apply the constructors to\n@return the results","static":false,"name":"applyRecursionPath","comment":"Apply constructors as indicated by a path returned by the context resolution graph\n \n Please note: The path given will be emptied during processing.","params":[{"type_long":"java.util.Deque<ghidra.app.plugin.assembler.sleigh.sem.AssemblyConstructorSemantic>","name":"path","comment":"the path to apply","type_short":"Deque"},{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","name":"branch","comment":"the branch corresponding to the production whose LHS has a purely-recursive\n            definition.","type_short":"AssemblyParseBranch"},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction","name":"rec","comment":"the purely-recursive production","type_short":"AssemblyProduction"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"child","comment":"the intermediate result to apply the constructors to","type_short":"AssemblyResolvedConstructor"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the results","type_short":"AssemblyResolutionResults"}},{"javadoc":"Resolve a branch where the production's LHS has a purely-recursive definition\n@param branch the branch\n@param rec the purely-recursive definition\n@return the results","static":false,"name":"resolveBranchRecursive","comment":"Resolve a branch where the production's LHS has a purely-recursive definition","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","name":"branch","comment":"the branch","type_short":"AssemblyParseBranch"},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction","name":"rec","comment":"the purely-recursive definition","type_short":"AssemblyProduction"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the results","type_short":"AssemblyResolutionResults"}},{"javadoc":"Resolve the given branch, having selected a particular combination of subconstructor results\n@param prod the production\n@param substs the braches and tokens corrresponding to the symbols of the production's RHS\n@param sel the selected subconstructor results\n@param semantics the collection of possible constructors for this production\n@return the results","static":false,"name":"resolveSelectedChildren","comment":"Resolve the given branch, having selected a particular combination of subconstructor results","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction","name":"prod","comment":"the production","type_short":"AssemblyProduction"},{"type_long":"java.util.List<ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseTreeNode>","name":"substs","comment":"the braches and tokens corrresponding to the symbols of the production's RHS","type_short":"List"},{"type_long":"com.google.common.collect.ImmutableList<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","name":"sel","comment":"the selected subconstructor results","type_short":"ImmutableList"},{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.sem.AssemblyConstructorSemantic>","name":"semantics","comment":"the collection of possible constructors for this production","type_short":"Collection"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the results","type_short":"AssemblyResolutionResults"}},{"javadoc":"","static":false,"name":"tryResolveBackfills","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","name":"results","comment":"","type_short":"AssemblyResolutionResults"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"","type_short":"AssemblyResolutionResults"}},{"javadoc":"Resolve a branch without considering any purely-recursive productions\n \n This method is used either when the LHS has no purely-recursive definition, or before\n considering the purely-recursive definition when it is present.\n@param branch the branch\n@return the results","static":false,"name":"resolveBranchNonRecursive","comment":"Resolve a branch without considering any purely-recursive productions\n \n This method is used either when the LHS has no purely-recursive definition, or before\n considering the purely-recursive definition when it is present.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","name":"branch","comment":"the branch","type_short":"AssemblyParseBranch"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the results","type_short":"AssemblyResolutionResults"}},{"javadoc":"Compute the offset of an operand encoded in the instruction block\n@param opsym the operand symbol\n@param cons the constructor containing the operand\n@param res the selected subconstructor encodings\n@return the offset (right shift) to apply to the encoded operand","static":true,"name":"computeOffset","comment":"Compute the offset of an operand encoded in the instruction block","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.OperandSymbol","name":"opsym","comment":"the operand symbol","type_short":"OperandSymbol"},{"type_long":"ghidra.app.plugin.processors.sleigh.Constructor","name":"cons","comment":"the constructor containing the operand","type_short":"Constructor"},{"type_long":"java.util.Map<java.lang.Integer,java.lang.Object>","name":"res","comment":"the selected subconstructor encodings","type_short":"Map"}],"throws":[],"return":{"type_long":"int","comment":"the offset (right shift) to apply to the encoded operand","type_short":"int"}},{"javadoc":"Attempt to solve an expression\n@param exp the expression to solve\n@param goal the desired value of the expression\n@param vals any defined symbols\n@param res the selected subconstructor encodings\n@param cur the resolved constructor so far\n@param description a description of the result\n@return the encoded solution, or a backfill record","static":true,"name":"solveOrBackfill","comment":"Attempt to solve an expression","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.expression.PatternExpression","name":"exp","comment":"the expression to solve","type_short":"PatternExpression"},{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","name":"goal","comment":"the desired value of the expression","type_short":"MaskedLong"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"vals","comment":"any defined symbols","type_short":"Map"},{"type_long":"java.util.Map<java.lang.Integer,java.lang.Object>","name":"res","comment":"the selected subconstructor encodings","type_short":"Map"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"cur","comment":"the resolved constructor so far","type_short":"AssemblyResolvedConstructor"},{"type_long":"java.lang.String","name":"description","comment":"a description of the result","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","comment":"the encoded solution, or a backfill record","type_short":"AssemblyResolution"}},{"javadoc":"Attempt to solve an expression\n \n Converts the given goal to a fully-defined {@link MaskedLong} and then solves as before.\n@see #solveOrBackfill(PatternExpression, MaskedLong, Map, Map, AssemblyResolvedConstructor,\n      String)","static":true,"name":"solveOrBackfill","comment":"Attempt to solve an expression\n \n Converts the given goal to a fully-defined MaskedLong and then solves as before.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.expression.PatternExpression","name":"exp","comment":"","type_short":"PatternExpression"},{"type_long":"long","name":"goal","comment":"","type_short":"long"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"vals","comment":"","type_short":"Map"},{"type_long":"java.util.Map<java.lang.Integer,java.lang.Object>","name":"res","comment":"","type_short":"Map"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"cur","comment":"","type_short":"AssemblyResolvedConstructor"},{"type_long":"java.lang.String","name":"description","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","comment":"","type_short":"AssemblyResolution"}},{"javadoc":"Attempt to solve an expression\n \n Converts the given goal and bits count to a {@link MaskedLong} and then solves as before. As\n a special case, if {@code bits == 0}, the goal is considered fully-defined (as if\n {@code bits == 64}).\n@see #solveOrBackfill(PatternExpression, MaskedLong, Map, Map, AssemblyResolvedConstructor,\n      String)","static":true,"name":"solveOrBackfill","comment":"Attempt to solve an expression\n \n Converts the given goal and bits count to a MaskedLong and then solves as before. As\n a special case, if , the goal is considered fully-defined (as if\n ).","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.expression.PatternExpression","name":"exp","comment":"","type_short":"PatternExpression"},{"type_long":"long","name":"goal","comment":"","type_short":"long"},{"type_long":"int","name":"bits","comment":"","type_short":"int"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"vals","comment":"","type_short":"Map"},{"type_long":"java.util.Map<java.lang.Integer,java.lang.Object>","name":"res","comment":"","type_short":"Map"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"cur","comment":"","type_short":"AssemblyResolvedConstructor"},{"type_long":"java.lang.String","name":"description","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","comment":"","type_short":"AssemblyResolution"}}],"name":"AssemblyTreeResolver","comment":"The workhorse of semantic resolution for the assembler\n \n This class takes a parse tree and some additional information (start address, context, etc.) and\n attempts to determine possible encodings using the semantics associated with each branch of the\n given parse tree. Details of this process are described in SleighAssemblerBuilder.","fields":[{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.RecursiveDescentSolver","javadoc":"","static":true,"name":"solver","comment":"","type_short":"RecursiveDescentSolver","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.util.DbgTimer","javadoc":"","static":true,"name":"dbg","comment":"","type_short":"DbgTimer","constant_value":null},{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","javadoc":"","static":false,"name":"lang","comment":"","type_short":"SleighLanguage","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"instStart","comment":"","type_short":"long","constant_value":null},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","javadoc":"","static":false,"name":"vals","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch","javadoc":"","static":false,"name":"tree","comment":"","type_short":"AssemblyParseBranch","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","javadoc":"","static":false,"name":"grammar","comment":"","type_short":"AssemblyGrammar","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","javadoc":"","static":false,"name":"context","comment":"","type_short":"AssemblyPatternBlock","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph","javadoc":"","static":false,"name":"ctxGraph","comment":"","type_short":"AssemblyContextGraph","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"INST_START","comment":"","type_short":"String","constant_value":"\"inst_start\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"INST_NEXT","comment":"","type_short":"String","constant_value":"\"inst_next\""}]}
