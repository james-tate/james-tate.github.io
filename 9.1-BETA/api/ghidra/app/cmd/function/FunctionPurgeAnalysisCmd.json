{"implements":[],"javadoc":"Command for analyzing the Stack; the command is run in the background.","static":false,"extends":"ghidra.framework.cmd.BackgroundCommand","methods":[{"javadoc":"Constructs a new command for analyzing the Stack.\n@param entries and address set indicating the entry points of functions that have \n stacks to be analyzed.","static":false,"name":"<init>","comment":"Constructs a new command for analyzing the Stack.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"entries","comment":"and address set indicating the entry points of functions that have \n stacks to be analyzed.","type_short":"AddressSetView"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.framework.cmd.BackgroundCommand#applyTo(ghidra.framework.model.DomainObject, ghidra.util.task.TaskMonitor)","static":false,"name":"applyTo","comment":"","params":[{"type_long":"ghidra.framework.model.DomainObject","name":"obj","comment":"","type_short":"DomainObject"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"For x86 16-bit find the models stdcallnear, stdcallfar, cdeclnear, and cdeclfar so they can\n be applied at the same time function purge is set.","static":false,"name":"setupNearFarModels","comment":"For x86 16-bit find the models stdcallnear, stdcallfar, cdeclnear, and cdeclfar so they can\n be applied at the same time function purge is set.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Analyze a function to build a stack frame based on stack references.\n@param function function to be analyzed\n@param monitor the task monitor that is checked to see if the command has\n been cancelled.\n@throws CancelledException if the user canceled this command","static":false,"name":"analyzeFunction","comment":"Analyze a function to build a stack frame based on stack references.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"function to be analyzed","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor that is checked to see if the command has\n been cancelled.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user canceled this command","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setPrototypeModel","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Instruction","name":"purgeInstruction","comment":"","type_short":"Instruction"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"locatePurgeInstruction","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"func","comment":"","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"","type_short":"Instruction"}},{"javadoc":"Given a terminating instruction, discover the purge value encoded in it\n@param instr is the terminating instruction\n@return the purge value (or -1 if a value can't be found)","static":false,"name":"getPurgeValue","comment":"Given a terminating instruction, discover the purge value encoded in it","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"is the terminating instruction","type_short":"Instruction"}],"throws":[],"return":{"type_long":"int","comment":"the purge value (or -1 if a value can't be found)","type_short":"int"}},{"javadoc":"Find a terminating instruction in the given set of addresses with a purge encoded in it.\n This routine prefers a RET instruction, but if none is available, it will use a\n terminating CALL.\n@param body is the set of addresses to look through\n@return a terminating instruction or null","static":false,"name":"findPurgeInstruction","comment":"Find a terminating instruction in the given set of addresses with a purge encoded in it.\n This routine prefers a RET instruction, but if none is available, it will use a\n terminating CALL.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"is the set of addresses to look through","type_short":"AddressSetView"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"a terminating instruction or null","type_short":"Instruction"}}],"name":"FunctionPurgeAnalysisCmd","comment":"Command for analyzing the Stack; the command is run in the background.","fields":[{"type_long":"ghidra.program.model.address.AddressSetView","javadoc":"","static":false,"name":"entryPoints","comment":"","type_short":"AddressSetView","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"program","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.lang.PrototypeModel[]","javadoc":"","static":false,"name":"nearFarModels","comment":"","type_short":"ghidra.program.model.lang.PrototypeModel[]","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"STDCALL_FAR","comment":"","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"CDECL_FAR","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"STDCALL_NEAR","comment":"","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"","static":true,"name":"CDECL_NEAR","comment":"","type_short":"int","constant_value":"3"}]}
