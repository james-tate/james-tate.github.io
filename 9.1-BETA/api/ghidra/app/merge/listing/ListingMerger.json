{"implements":[],"javadoc":"<code>ListingMerger<\/code> is an interface implemented by an individual \n listing merge manager. It defines methods that the overall ListingMergeManager\n can call on the individual listing merge managers.","static":false,"methods":[{"javadoc":"Performs the automatic merge for all changes in my Checked Out program version.\n It also determines the conflicts requiring manual resolution.\n@param monitor task monitor for informing the user of progress.\n@param progressMin minimum progress value, between 0 & 100, for this auto merge. \n The merge manager's progress should be updated from progressMin to progressMax \n as the autoMerge occurs.\n@param progressMax maximum progress value, between 0 & 100, for this auto merge.\n@throws ProgramConflictException if the programs for different versions are not compatible.\n@throws MemoryAccessException if memory can't be accessed to get\/set byte values.\n@throws CancelledException if the user cancels the merge.","static":false,"name":"autoMerge","comment":"Performs the automatic merge for all changes in my Checked Out program version.\n It also determines the conflicts requiring manual resolution.","params":[{"type_long":"int","name":"progressMin","comment":"minimum progress value, between 0  100, for this auto merge. \n The merge manager's progress should be updated from progressMin to progressMax \n as the autoMerge occurs.","type_short":"int"},{"type_long":"int","name":"progressMax","comment":"maximum progress value, between 0  100, for this auto merge.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor for informing the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.util.ProgramConflictException","comment":"if the programs for different versions are not compatible.","type_short":"ProgramConflictException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory can't be accessed to get\/set byte values.","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the merge.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Method called when the Apply button is pressed on the GUI conflict resolution window.\n@return true if apply succeeded.","static":false,"name":"apply","comment":"Method called when the Apply button is pressed on the GUI conflict resolution window.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if apply succeeded.","type_short":"boolean"}},{"javadoc":"Method called when the Cancel button is pressed on the GUI conflict resolution window.","static":false,"name":"cancel","comment":"Method called when the Cancel button is pressed on the GUI conflict resolution window.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a string indicating the type of listing conflict this merger handles.\n <br>For example, Function, Symbol, etc.","static":false,"name":"getConflictType","comment":"Returns a string indicating the type of listing conflict this merger handles.\n For example, Function, Symbol, etc.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Determines the number of conflicts that have currently been resolved on \n the conflict resolution window.\n@return the number of conflicts resolved by the user selecting buttons or checkboxes.","static":false,"name":"getNumConflictsResolved","comment":"Determines the number of conflicts that have currently been resolved on \n the conflict resolution window.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of conflicts resolved by the user selecting buttons or checkboxes.","type_short":"int"}},{"javadoc":"Determines if there is a conflict at the specified address.\n@param addr\n@return true if there is one or more conflicts at the address.","static":false,"name":"hasConflict","comment":"Determines if there is a conflict at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if there is one or more conflicts at the address.","type_short":"boolean"}},{"javadoc":"Determines the number of conflicts at the indicated address.\n@param addr the address\n@return the number of conflicts at the indicated address.","static":false,"name":"getConflictCount","comment":"Determines the number of conflicts at the indicated address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address","type_short":"Address"}],"throws":[],"return":{"type_long":"int","comment":"the number of conflicts at the indicated address.","type_short":"int"}},{"javadoc":"Performs a manual merge of all conflicts at the indicated address for \n the type of conflicts that this merge manager handles.\n@param listingPanel the listing merge panel with the 4 version listings.\n@param addr\n@param conflictOption ASK_USER means interactively resolve conflicts. \n JUnit testing also allows setting this to LATEST, MY, or ORIGINAL to force\n selection of a particular version change.\n@param monitor task monitor for informing the user of progress.\n@throws CancelledException if the user cancels the merge.\n@throws MemoryAccessException if memory can't be accessed to get\/set byte values.","static":false,"name":"mergeConflicts","comment":"Performs a manual merge of all conflicts at the indicated address for \n the type of conflicts that this merge manager handles.","params":[{"type_long":"ghidra.app.merge.tool.ListingMergePanel","name":"listingPanel","comment":"the listing merge panel with the 4 version listings.","type_short":"ListingMergePanel"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"conflictOption","comment":"ASK_USER means interactively resolve conflicts. \n JUnit testing also allows setting this to LATEST, MY, or ORIGINAL to force\n selection of a particular version change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor for informing the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the merge.","type_short":"CancelledException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory can't be accessed to get\/set byte values.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return an address set indicating where there are conflicts to resolve.","static":false,"name":"getConflicts","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"an address set indicating where there are conflicts to resolve.","type_short":"AddressSetView"}}],"name":"ListingMerger","comment":"ListingMerger is an interface implemented by an individual \n listing merge manager. It defines methods that the overall ListingMergeManager\n can call on the individual listing merge managers.","fields":[]}
