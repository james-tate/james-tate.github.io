{"implements":["ghidra.app.merge.MergeResolver","ghidra.app.merge.listing.ListingMergeConstants"],"javadoc":"Class for merging function tag changes. Most tag differences can be easily auto-merged, \n which is to say the result will be the set of all of tags from both program 1 and \n program 2. Conflicts arise when both parties have edited\/deleted the same tag.\n \n The specific cases handled by the class are described below, where:\n \n  - X and Y are tags\n  - X(A) means to take A's version of tag X\n  - ** indicates a conflict\n  - NP means the situation is not possible\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\tEdit X\t\tEdit Y\n \t\t\t\t|\n User B\t\t|\n ---------------------------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\tNP\t\t\tX\t\tNP\t\t\tX,Y(A)\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\tNP\t\tX(A),Y\t\tNP\n \t\t\t\t|\n Delete X\t\t|\tNP\t\tY\t\t\t-\t\t\t-\t\t**\t\t\tY(A)\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\tNP\t\t\t-\t\t\t-\t\tX(A)\t\t**\n \t\t\t\t|\n Edit X\t\t|\tNP\t\tX(B),Y\t\t**\t\t\tX(B)\t**\t\t\tX(B),Y(A)\t\n \t\t\t\t|\n Edit Y\t\t|\tX,Y(B)\tNP\t\t\tY(B)\t\t**\t\tX(A),Y(B)\t**","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructor.\n@param mergeManager the merge manager\n@param resultPgm the program storing the result of the merge\n@param originalPgm the state of the program before any changes\n@param latestPgm the checked in program version\n@param myPgm the checked out program version\n@param latestChanges tag changes in Latest\n@param myChanges tag changes in My","static":false,"name":"<init>","comment":"Constructor.","params":[{"type_long":"ghidra.app.merge.ProgramMultiUserMergeManager","name":"mergeManager","comment":"the merge manager","type_short":"ProgramMultiUserMergeManager"},{"type_long":"ghidra.program.model.listing.Program","name":"resultPgm","comment":"the program storing the result of the merge","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"originalPgm","comment":"the state of the program before any changes","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"latestPgm","comment":"the checked in program version","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"myPgm","comment":"the checked out program version","type_short":"Program"},{"type_long":"ghidra.program.model.listing.ProgramChangeSet","name":"latestChanges","comment":"tag changes in Latest","type_short":"ProgramChangeSet"},{"type_long":"ghidra.program.model.listing.ProgramChangeSet","name":"myChanges","comment":"tag changes in My","type_short":"ProgramChangeSet"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"PUBLIC METHODS","static":false,"name":"getName","comment":"PUBLIC METHODS","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getDescription","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"apply","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cancel","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"merge","comment":"","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getPhases","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String[][]","comment":"","type_short":"java.lang.String[][]"}},{"javadoc":"Displays a conflict resolution panel for each conflict discovered during\n {@link #autoMerge()}.\n@param monitor the task monitor\n@throws CancelledException","static":false,"name":"handleConflicts","comment":"Displays a conflict resolution panel for each conflict discovered during\n #autoMerge().","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges the desired program (based on the provided option) into the Result program.\n@param chosenConflictOption conflict option indicating the program version to use.\n@param monitor the task monitor\n@throws CancelledException","static":false,"name":"merge","comment":"Merges the desired program (based on the provided option) into the Result program.","params":[{"type_long":"int","name":"chosenConflictOption","comment":"conflict option indicating the program version to use.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges the tag being currently resolved into the Result program.\n@param sourceProgram\n@param monitor\n@throws CancelledException\n@throws IOException","static":false,"name":"merge","comment":"Merges the tag being currently resolved into the Result program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"sourceProgram","comment":"","type_short":"Program"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the {@link FunctionTag} instance for the given program and tag ID.\n@param program the program version to use\n@param id the tag id\n@return the tag, or null if not found","static":false,"name":"getTag","comment":"Returns the FunctionTag instance for the given program and tag ID.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program version to use","type_short":"Program"},{"type_long":"long","name":"id","comment":"the tag id","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionTag","comment":"the tag, or null if not found","type_short":"FunctionTag"}},{"javadoc":"Attempts to merge all tag changes between My and Latest. Any conflicts\n will be stored in {@link #tagConflicts} for later resolution.\n@throws IOException","static":false,"name":"autoMerge","comment":"Attempts to merge all tag changes between My and Latest. Any conflicts\n will be stored in #tagConflicts for later resolution.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges tags that have been edited (name\/comment changed). \n \n CONFLICT CASES:\n \t1. The same tag has been edited in both programs, either the name or comment.\n \n Note that the conflict case of a tag being edited in one program and \n deleted in another is handled in {@link #mergeDeletions(FunctionTagManagerDB, List, List, List, List)}.","static":false,"name":"mergeEdits","comment":"Merges tags that have been edited (name\/comment changed). \n \n CONFLICT CASES:\n \t1. The same tag has been edited in both programs, either the name or comment.\n \n Note that the conflict case of a tag being edited in one program and \n deleted in another is handled in #mergeDeletions(FunctionTagManagerDB, List, List, List, List).","params":[{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerMY","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerLATEST","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerRESULT","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"java.util.List<java.lang.Long>","name":"myEditedIDs","comment":"","type_short":"List"},{"type_long":"java.util.List<java.lang.Long>","name":"latestEditedIDs","comment":"","type_short":"List"},{"type_long":"java.util.List<java.lang.Long>","name":"latestDeletedIDs","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges tags that have been deleted. \n \n CONFLICT CASES:\n \t1. A tag has been deleted in one program, but edited in the other.","static":false,"name":"mergeDeletions","comment":"Merges tags that have been deleted. \n \n CONFLICT CASES:\n \t1. A tag has been deleted in one program, but edited in the other.","params":[{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerRESULT","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"java.util.List<java.lang.Long>","name":"myEditedIDs","comment":"","type_short":"List"},{"type_long":"java.util.List<java.lang.Long>","name":"latestEditedIDs","comment":"","type_short":"List"},{"type_long":"java.util.List<java.lang.Long>","name":"myDeletedIDs","comment":"","type_short":"List"},{"type_long":"java.util.List<java.lang.Long>","name":"latestDeletedIDs","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges tags that have been added.\n \n CONFLICT CASES: Name is the same, comment is different.","static":false,"name":"mergeAdditions","comment":"Merges tags that have been added.\n \n CONFLICT CASES: Name is the same, comment is different.","params":[{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerMY","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerLATEST","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"ghidra.program.database.function.FunctionTagManagerDB","name":"tagManagerRESULT","comment":"","type_short":"FunctionTagManagerDB"},{"type_long":"long[]","name":"myAdditionIDs","comment":"","type_short":"long[]"},{"type_long":"long[]","name":"latestAdditionIDs","comment":"","type_short":"long[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Given a list of tag IDs, returns the subset of those who's tags have\n been edited. \n \n This is determined by checking the tag attributes in the given\n program version against Original.\n@param ids the full list of ids to check\n@param tagManager the source program tag manager\n@param originalTagManager the Original program tag manager\n@return ","static":false,"name":"getEdits","comment":"Given a list of tag IDs, returns the subset of those who's tags have\n been edited. \n \n This is determined by checking the tag attributes in the given\n program version against Original.","params":[{"type_long":"long[]","name":"ids","comment":"the full list of ids to check","type_short":"long[]"},{"type_long":"ghidra.program.model.listing.FunctionTagManager","name":"tagManager","comment":"the source program tag manager","type_short":"FunctionTagManager"},{"type_long":"ghidra.program.model.listing.FunctionTagManager","name":"originalTagManager","comment":"the Original program tag manager","type_short":"FunctionTagManager"}],"throws":[],"return":{"type_long":"java.util.List<java.lang.Long>","comment":"","type_short":"List"}},{"javadoc":"Given a list of tag IDs, returns the subset of those who's tags have\n been deleted.\n \n A delete is identified by comparing the given program version against\n Original; if the tag exists in the latter but not the former, it was\n deleted.\n@param ids the full list of ids to check\n@param tagManager the source program tag manager\n@param originalTagManager the Original program tag manager\n@return ","static":false,"name":"getDeletes","comment":"Given a list of tag IDs, returns the subset of those who's tags have\n been deleted.\n \n A delete is identified by comparing the given program version against\n Original; if the tag exists in the latter but not the former, it was\n deleted.","params":[{"type_long":"long[]","name":"ids","comment":"the full list of ids to check","type_short":"long[]"},{"type_long":"ghidra.program.model.listing.FunctionTagManager","name":"tagManager","comment":"the source program tag manager","type_short":"FunctionTagManager"},{"type_long":"ghidra.program.model.listing.FunctionTagManager","name":"originalTagManager","comment":"the Original program tag manager","type_short":"FunctionTagManager"}],"throws":[],"return":{"type_long":"java.util.List<java.lang.Long>","comment":"","type_short":"List"}},{"javadoc":"Displays the conflict panel for a tag.\n@param id the tag id to merge\n@param monitor task monitor","static":false,"name":"showMergePanel","comment":"Displays the conflict panel for a tag.","params":[{"type_long":"long","name":"id","comment":"the tag id to merge","type_short":"long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the {@link FunctionTag} for the given tag id.\n@param id the tag id\n@param program the program version\n@return null function tag, or null if not found\n@throws IOException","static":false,"name":"getTag","comment":"Returns the FunctionTag for the given tag id.","params":[{"type_long":"java.lang.Long","name":"id","comment":"the tag id","type_short":"Long"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program version","type_short":"Program"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.program.model.listing.FunctionTag","comment":"null function tag, or null if not found","type_short":"FunctionTag"}},{"javadoc":"For JUnit testing only, set the option for resolving a conflict.\n@param option","static":false,"name":"setConflictResolution","comment":"For JUnit testing only, set the option for resolving a conflict.","params":[{"type_long":"int","name":"option","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Builds the UI for the conflict panel. This will show the tag ID that is in\n conflict, the reason for the conflict, and widgets allowing the user to\n select a resolution.\n@param id the tag id\n@param listener listener for handling radio button selects\n@param monitor task monitor","static":false,"name":"setupConflictPanel","comment":"Builds the UI for the conflict panel. This will show the tag ID that is in\n conflict, the reason for the conflict, and widgets allowing the user to\n select a resolution.","params":[{"type_long":"long","name":"id","comment":"the tag id","type_short":"long"},{"type_long":"javax.swing.event.ChangeListener","name":"listener","comment":"listener for handling radio button selects","type_short":"ChangeListener"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a string containing information about the current conflict. This will be \n displayed in the header of the conflict panel.\n@param monitor the task monitor\n@return ","static":false,"name":"getConflictInfo","comment":"Returns a string containing information about the current conflict. This will be \n displayed in the header of the conflict panel.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns a string containing the tag contents for the program version\n given.\n \n This is what should be displayed for each choice in the conflict panel.\n@param version the program version (LATEST, MY, ORIGINAL)\n@param name the tag name\n@param comment the tag comment\n@return ","static":false,"name":"getFunctionTagInfo","comment":"Returns a string containing the tag contents for the program version\n given.\n \n This is what should be displayed for each choice in the conflict panel.","params":[{"type_long":"int","name":"version","comment":"the program version (LATEST, MY, ORIGINAL)","type_short":"int"},{"type_long":"java.lang.String","name":"name","comment":"the tag name","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the tag comment","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String[]","comment":"","type_short":"java.lang.String[]"}}],"name":"FunctionTagMerger","comment":"Class for merging function tag changes. Most tag differences can be easily auto-merged, \n which is to say the result will be the set of all of tags from both program 1 and \n program 2. Conflicts arise when both parties have edited\/deleted the same tag.\n \n The specific cases handled by the class are described below, where:\n \n  - X and Y are tags\n  - X(A) means to take A's version of tag X\n  - ** indicates a conflict\n  - NP means the situation is not possible\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\tEdit X\t\tEdit Y\n \t\t\t\t|\n User B\t\t|\n ---------------------------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\tNP\t\t\tX\t\tNP\t\t\tX,Y(A)\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\tNP\t\tX(A),Y\t\tNP\n \t\t\t\t|\n Delete X\t\t|\tNP\t\tY\t\t\t-\t\t\t-\t\t**\t\t\tY(A)\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\tNP\t\t\t-\t\t\t-\t\tX(A)\t\t**\n \t\t\t\t|\n Edit X\t\t|\tNP\t\tX(B),Y\t\t**\t\t\tX(B)\t**\t\t\tX(B),Y(A)\t\n \t\t\t\t|\n Edit Y\t\t|\tX,Y(B)\tNP\t\t\tY(B)\t\t**\t\tX(A),Y(B)\t**","fields":[{"type_long":"java.lang.String[]","javadoc":"","static":true,"name":"FUNCTION_TAG_PHASE","comment":"","type_short":"java.lang.String[]","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"RESULT","comment":"","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"LATEST","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"MY","comment":"","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"","static":true,"name":"ORIGINAL","comment":"","type_short":"int","constant_value":"3"},{"type_long":"ghidra.app.merge.ProgramMultiUserMergeManager","javadoc":"","static":false,"name":"mergeManager","comment":"","type_short":"ProgramMultiUserMergeManager","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"resultProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"originalProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"latestProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"myProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.ProgramChangeSet","javadoc":"","static":false,"name":"latestChanges","comment":"","type_short":"ProgramChangeSet","constant_value":null},{"type_long":"ghidra.program.model.listing.ProgramChangeSet","javadoc":"","static":false,"name":"myChanges","comment":"","type_short":"ProgramChangeSet","constant_value":null},{"type_long":"ghidra.app.merge.listing.VerticalChoicesPanel","javadoc":"","static":false,"name":"conflictPanel","comment":"","type_short":"VerticalChoicesPanel","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"conflictOption","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"conflictChoice","comment":"","type_short":"int","constant_value":null},{"type_long":"java.util.Map<java.lang.Long,java.lang.String>","javadoc":"","static":false,"name":"tagConflicts","comment":"","type_short":"Map","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"currentlyMergingTagID","comment":"","type_short":"long","constant_value":null}]}
