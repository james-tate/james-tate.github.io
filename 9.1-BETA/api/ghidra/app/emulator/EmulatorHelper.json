{"implements":["ghidra.pcode.memstate.MemoryFaultHandler","ghidra.app.emulator.EmulatorConfiguration"],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"dispose","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getMemoryFaultHandler","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.pcode.memstate.MemoryFaultHandler","comment":"","type_short":"MemoryFaultHandler"}},{"javadoc":"","static":false,"name":"getLoadData","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.app.emulator.memory.EmulatorLoadData","comment":"","type_short":"EmulatorLoadData"}},{"javadoc":"","static":false,"name":"getLanguage","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Language","comment":"","type_short":"Language"}},{"javadoc":"","static":false,"name":"getProgram","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"Get Program Counter (PC) register defined by applicable processor specification\n@return Program Counter register","static":false,"name":"getPCRegister","comment":"Get Program Counter (PC) register defined by applicable processor specification","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"Program Counter register","type_short":"Register"}},{"javadoc":"Get Stack Pointer register defined by applicable compiler specification\n@return Stack Pointer register","static":false,"name":"getStackPointerRegister","comment":"Get Stack Pointer register defined by applicable compiler specification","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"Stack Pointer register","type_short":"Register"}},{"javadoc":"Provides ability to install a low-level memory fault handler. \n The handler methods should generally return 'false' to allow \n the default handler to generate the appropriate target error. \n Within the fault handler, the EmulateExecutionState can be used \n to distinguish the pcode-emit state and the actual execution state\n since an attempt to execute an instruction at an uninitialized \n memory location will cause an uninitializedRead during the PCODE_EMIT\n state.\n@param handler memory fault handler.","static":false,"name":"setMemoryFaultHandler","comment":"Provides ability to install a low-level memory fault handler. \n The handler methods should generally return 'false' to allow \n the default handler to generate the appropriate target error. \n Within the fault handler, the EmulateExecutionState can be used \n to distinguish the pcode-emit state and the actual execution state\n since an attempt to execute an instruction at an uninitialized \n memory location will cause an uninitializedRead during the PCODE_EMIT\n state.","params":[{"type_long":"ghidra.pcode.memstate.MemoryFaultHandler","name":"handler","comment":"memory fault handler.","type_short":"MemoryFaultHandler"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return the low-level emulator execution state","static":false,"name":"getEmulateExecutionState","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.pcode.emulate.EmulateExecutionState","comment":"the low-level emulator execution state","type_short":"EmulateExecutionState"}},{"javadoc":"","static":false,"name":"getRegister","comment":"","params":[{"type_long":"java.lang.String","name":"regName","comment":"","type_short":"String"}],"throws":[{"type_long":"java.lang.IllegalArgumentException","comment":"","type_short":"IllegalArgumentException"}],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"","type_short":"Register"}},{"javadoc":"","static":false,"name":"readRegister","comment":"","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"","type_short":"Register"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"","type_short":"BigInteger"}},{"javadoc":"","static":false,"name":"readRegister","comment":"","params":[{"type_long":"java.lang.String","name":"regName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"","type_short":"BigInteger"}},{"javadoc":"","static":false,"name":"writeRegister","comment":"","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"","type_short":"Register"},{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"writeRegister","comment":"","params":[{"type_long":"java.lang.String","name":"regName","comment":"","type_short":"String"},{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"writeRegister","comment":"","params":[{"type_long":"ghidra.program.model.lang.Register","name":"reg","comment":"","type_short":"Register"},{"type_long":"java.math.BigInteger","name":"value","comment":"","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"writeRegister","comment":"","params":[{"type_long":"java.lang.String","name":"regName","comment":"","type_short":"String"},{"type_long":"java.math.BigInteger","name":"value","comment":"","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Read string from memory state.\n@param addr memory address\n@param maxLength limit string read to this length.  If return string is\n truncated, \"...\" will be appended.\n@return string read from memory state","static":false,"name":"readNullTerminatedString","comment":"Read string from memory state.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"memory address","type_short":"Address"},{"type_long":"int","name":"maxLength","comment":"limit string read to this length.  If return string is\n truncated, \"...\" will be appended.","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"string read from memory state","type_short":"String"}},{"javadoc":"","static":false,"name":"readMemoryByte","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"byte","comment":"","type_short":"byte"}},{"javadoc":"","static":false,"name":"readMemory","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"writeMemory","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"writeMemoryValue","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"size","comment":"","type_short":"int"},{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Read a stack value from the memory state.\n@param relativeOffset offset relative to current stack pointer\n@param size data size in bytes\n@param signed true if value read is signed, false if unsigned\n@return value\n@throws Exception error occurs reading stack pointer","static":false,"name":"readStackValue","comment":"Read a stack value from the memory state.","params":[{"type_long":"int","name":"relativeOffset","comment":"offset relative to current stack pointer","type_short":"int"},{"type_long":"int","name":"size","comment":"data size in bytes","type_short":"int"},{"type_long":"boolean","name":"signed","comment":"true if value read is signed, false if unsigned","type_short":"boolean"}],"throws":[{"type_long":"java.lang.Exception","comment":"error occurs reading stack pointer","type_short":"Exception"}],"return":{"type_long":"java.math.BigInteger","comment":"value","type_short":"BigInteger"}},{"javadoc":"Write a value onto the stack\n@param relativeOffset offset relative to current stack pointer\n@param size data size in bytes\n@param value\n@throws Exception error occurs reading stack pointer","static":false,"name":"writeStackValue","comment":"Write a value onto the stack","params":[{"type_long":"int","name":"relativeOffset","comment":"offset relative to current stack pointer","type_short":"int"},{"type_long":"int","name":"size","comment":"data size in bytes","type_short":"int"},{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[{"type_long":"java.lang.Exception","comment":"error occurs reading stack pointer","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write a value onto the stack\n@param relativeOffset offset relative to current stack pointer\n@param size data size in bytes\n@param value\n@throws Exception error occurs reading stack pointer","static":false,"name":"writeStackValue","comment":"Write a value onto the stack","params":[{"type_long":"int","name":"relativeOffset","comment":"offset relative to current stack pointer","type_short":"int"},{"type_long":"int","name":"size","comment":"data size in bytes","type_short":"int"},{"type_long":"java.math.BigInteger","name":"value","comment":"","type_short":"BigInteger"}],"throws":[{"type_long":"java.lang.Exception","comment":"error occurs reading stack pointer","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Establish breakpoint\n@param address memory address for new breakpoint","static":false,"name":"setBreakpoint","comment":"Establish breakpoint","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clear breakpoint\n@param address memory address for breakpoint to be cleared","static":false,"name":"clearBreakpoint","comment":"Clear breakpoint","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set current context register value.\n Keep in mind that any non-flowing context values will be stripped.\n@param ctxRegValue","static":false,"name":"setContextRegister","comment":"Set current context register value.\n Keep in mind that any non-flowing context values will be stripped.","params":[{"type_long":"ghidra.program.model.lang.RegisterValue","name":"ctxRegValue","comment":"","type_short":"RegisterValue"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set current context register value.\n Keep in mind that any non-flowing context values will be stripped.\n@param ctxReg context register\n@param value context value","static":false,"name":"setContextRegister","comment":"Set current context register value.\n Keep in mind that any non-flowing context values will be stripped.","params":[{"type_long":"ghidra.program.model.lang.Register","name":"ctxReg","comment":"context register","type_short":"Register"},{"type_long":"java.math.BigInteger","name":"value","comment":"context value","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the current context register value\n@return context register value or null if not set or unknown","static":false,"name":"getContextRegister","comment":"Get the current context register value","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.RegisterValue","comment":"context register value or null if not set or unknown","type_short":"RegisterValue"}},{"javadoc":"Register callback for language defined pcodeop (call other).\n WARNING! Using this method may circumvent the default CALLOTHER emulation support\n when supplied by the Processor module.\n@param pcodeOpName\n@param callback","static":false,"name":"registerCallOtherCallback","comment":"Register callback for language defined pcodeop (call other).\n WARNING! Using this method may circumvent the default CALLOTHER emulation support\n when supplied by the Processor module.","params":[{"type_long":"java.lang.String","name":"pcodeOpName","comment":"","type_short":"String"},{"type_long":"ghidra.pcode.emulate.BreakCallBack","name":"callback","comment":"","type_short":"BreakCallBack"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Register default callback for language defined pcodeops (call other).\n WARNING! Using this method may circumvent the default CALLOTHER emulation support\n when supplied by the Processor module.\n@param pcodeOpName\n@param callback","static":false,"name":"registerDefaultCallOtherCallback","comment":"Register default callback for language defined pcodeops (call other).\n WARNING! Using this method may circumvent the default CALLOTHER emulation support\n when supplied by the Processor module.","params":[{"type_long":"ghidra.pcode.emulate.BreakCallBack","name":"callback","comment":"","type_short":"BreakCallBack"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Unregister callback for language defined pcodeop (call other).\n@param pcodeOpName","static":false,"name":"unregisterCallOtherCallback","comment":"Unregister callback for language defined pcodeop (call other).","params":[{"type_long":"java.lang.String","name":"pcodeOpName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Unregister default callback for language defined pcodeops (call other).\n WARNING! Using this method may circumvent the default CALLOTHER emulation support\n when supplied by the Processor module.","static":false,"name":"unregisterDefaultCallOtherCallback","comment":"Unregister default callback for language defined pcodeops (call other).\n WARNING! Using this method may circumvent the default CALLOTHER emulation support\n when supplied by the Processor module.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get current execution address\n@return current execution address","static":false,"name":"getExecutionAddress","comment":"Get current execution address","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"current execution address","type_short":"Address"}},{"javadoc":"Start execution at the specified address using the initial context specified.\n Method will block until execution stops.  This method will initialize context\n register based upon the program stored context if not already done.  In addition,\n both general register value and the context register may be further modified\n via the context parameter if specified.\n@param addr initial program address\n@param context optional context settings which override current program context\n@param monitor\n@return true if execution completes without error (i.e., is at breakpoint)\n@throws CancelledException if execution cancelled via monitor","static":false,"name":"run","comment":"Start execution at the specified address using the initial context specified.\n Method will block until execution stops.  This method will initialize context\n register based upon the program stored context if not already done.  In addition,\n both general register value and the context register may be further modified\n via the context parameter if specified.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"initial program address","type_short":"Address"},{"type_long":"ghidra.program.model.lang.ProcessorContext","name":"context","comment":"optional context settings which override current program context","type_short":"ProcessorContext"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if execution cancelled via monitor","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"true if execution completes without error (i.e., is at breakpoint)","type_short":"boolean"}},{"javadoc":"Continue execution from the current execution address.\n No adjustment will be made to the context beyond the normal \n context flow behavior defined by the language.\n Method will block until execution stops.\n@param monitor\n@return true if execution completes without error (i.e., is at breakpoint)\n@throws CancelledException if execution cancelled via monitor","static":false,"name":"run","comment":"Continue execution from the current execution address.\n No adjustment will be made to the context beyond the normal \n context flow behavior defined by the language.\n Method will block until execution stops.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if execution cancelled via monitor","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"true if execution completes without error (i.e., is at breakpoint)","type_short":"boolean"}},{"javadoc":"Continue execution and block until either a breakpoint hits or error occurs.\n@throws CancelledException if execution was cancelled","static":false,"name":"continueExecution","comment":"Continue execution and block until either a breakpoint hits or error occurs.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if execution was cancelled","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Execute instruction at current address\n@param stopAtBreakpoint if true and breakpoint hits at current execution address\n execution will halt without executing instruction.\n@throws CancelledException if execution was cancelled","static":false,"name":"executeInstruction","comment":"Execute instruction at current address","params":[{"type_long":"boolean","name":"stopAtBreakpoint","comment":"if true and breakpoint hits at current execution address\n execution will halt without executing instruction.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if execution was cancelled","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Used when the emulator has had the execution address changed to\n make sure it has a context consistent with the program context\n if there is one.","static":false,"name":"setProcessorContext","comment":"Used when the emulator has had the execution address changed to\n make sure it has a context consistent with the program context\n if there is one.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return last error message associated with execution failure","static":false,"name":"getLastError","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"last error message associated with execution failure","type_short":"String"}},{"javadoc":"Step execution one instruction which may consist of multiple\n pcode operations.  No adjustment will be made to the context beyond the normal \n context flow behavior defined by the language.\n Method will block until execution stops.\n@return true if execution completes without error\n@throws CancelledException if execution cancelled via monitor","static":false,"name":"step","comment":"Step execution one instruction which may consist of multiple\n pcode operations.  No adjustment will be made to the context beyond the normal \n context flow behavior defined by the language.\n Method will block until execution stops.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if execution cancelled via monitor","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"true if execution completes without error","type_short":"boolean"}},{"javadoc":"Create a new initialized memory block using the current emulator memory state\n@param name block name\n@param start start address of the block\n@param length the size of the block\n@param overlay if true, the block will be created as an OVERLAY which means that a new \n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.\n@param monitor\n@return new memory block\n@throws LockException if exclusive lock not in place (see haveLock())\n@throws MemoryConflictException if the new block overlaps with a\n previous block\n@throws AddressOverflowException if the start is beyond the\n address space\n@throws CancelledException user cancelled operation\n@throws DuplicateNameException","static":false,"name":"createMemoryBlockFromMemoryState","comment":"Create a new initialized memory block using the current emulator memory state","params":[{"type_long":"java.lang.String","name":"name","comment":"block name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start address of the block","type_short":"Address"},{"type_long":"int","name":"length","comment":"the size of the block","type_short":"int"},{"type_long":"boolean","name":"overlay","comment":"if true, the block will be created as an OVERLAY which means that a new \n overlay address space will be created and the block will have a starting address at the same\n offset as the given start address parameter, but in the new address space.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryConflictException","comment":"if the new block overlaps with a\n previous block","type_short":"MemoryConflictException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the start is beyond the\n address space","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"user cancelled operation","type_short":"CancelledException"},{"type_long":"ghidra.framework.store.LockException","comment":"if exclusive lock not in place (see haveLock())","type_short":"LockException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"new memory block","type_short":"MemoryBlock"}},{"javadoc":"Enable\/Disable tracking of memory writes in the form of an\n address set.\n@param enable","static":false,"name":"enableMemoryWriteTracking","comment":"Enable\/Disable tracking of memory writes in the form of an\n address set.","params":[{"type_long":"boolean","name":"enable","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return address set of memory locations written by the emulator\n if memory write tracking is enabled, otherwise null is returned.\n The address set returned will continue to be updated unless\n memory write tracking becomes disabled.","static":false,"name":"getTrackedMemoryWriteSet","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"address set of memory locations written by the emulator\n if memory write tracking is enabled, otherwise null is returned.\n The address set returned will continue to be updated unless\n memory write tracking becomes disabled.","type_short":"AddressSetView"}},{"javadoc":"","static":false,"name":"unknownAddress","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"boolean","name":"write","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"uninitializedRead","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"int","name":"size","comment":"","type_short":"int"},{"type_long":"byte[]","name":"buf","comment":"","type_short":"byte[]"},{"type_long":"int","name":"bufOffset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getEmulator","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.app.emulator.Emulator","comment":"","type_short":"Emulator"}}],"name":"EmulatorHelper","comment":"","fields":[{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"program","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.app.emulator.Emulator","javadoc":"","static":false,"name":"emulator","comment":"","type_short":"Emulator","constant_value":null},{"type_long":"ghidra.program.model.lang.Register","javadoc":"","static":false,"name":"stackPtrReg","comment":"","type_short":"Register","constant_value":null},{"type_long":"ghidra.program.model.address.AddressSpace","javadoc":"","static":false,"name":"stackMemorySpace","comment":"","type_short":"AddressSpace","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"lastError","comment":"","type_short":"String","constant_value":null},{"type_long":"ghidra.app.emulator.EmulatorHelper.MemoryWriteTracker","javadoc":"","static":false,"name":"memoryWriteTracker","comment":"","type_short":"MemoryWriteTracker","constant_value":null},{"type_long":"ghidra.pcode.memstate.MemoryFaultHandler","javadoc":"","static":false,"name":"faultHandler","comment":"","type_short":"MemoryFaultHandler","constant_value":null},{"type_long":"ghidra.pcode.emulate.BreakCallBack","javadoc":"","static":false,"name":"addressBreak","comment":"","type_short":"BreakCallBack","constant_value":null}]}
