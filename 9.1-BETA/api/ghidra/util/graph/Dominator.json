{"implements":[],"javadoc":"Title: Dominator\n Description: This class contains the functions necessary to build the\n dominance graph of a FlowGraph, ShrinkWrap or Modularized Graph.\n A more complete explanation of my algorithm can be found in my paper\n titled \"Building a Dominance Graph\"","static":false,"extends":"ghidra.util.graph.DirectedGraph","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"int","name":"vertexCapacity","comment":"","type_short":"int"},{"type_long":"int","name":"edgeCapacity","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.util.graph.DirectedGraph","name":"cg","comment":"","type_short":"DirectedGraph"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"this aids in going back to the parent from which a vertex was accessed in\n the depth first search","static":false,"name":"backTrack","comment":"this aids in going back to the parent from which a vertex was accessed in\n the depth first search","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"ghidra.util.graph.Vertex","comment":"","type_short":"Vertex"}},{"javadoc":"this returns the vertex that is the dominator","static":false,"name":"getDominator","comment":"this returns the vertex that is the dominator","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"ghidra.util.graph.Vertex","comment":"","type_short":"Vertex"}},{"javadoc":"this returns all paths that contain v which we need to consider when\n looking for the dominator of v.  It places the longest path as the\n first element in the vector pathSet.","static":false,"name":"allPathsContaining","comment":"this returns all paths that contain v which we need to consider when\n looking for the dominator of v.  It places the longest path as the\n first element in the vector pathSet.","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"java.util.Vector","comment":"","type_short":"Vector"}},{"javadoc":"This takes the longest path that contains vertex v and looks to see\n if any of v's ancestors from that path are contained in all other\n paths that contain v.","static":false,"name":"allPathsContain","comment":"This takes the longest path that contains vertex v and looks to see\n if any of v's ancestors from that path are contained in all other\n paths that contain v.","params":[{"type_long":"java.util.Vector","name":"pathSet","comment":"","type_short":"Vector"},{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"},{"type_long":"java.util.Vector","name":"path","comment":"","type_short":"Vector"}],"throws":[],"return":{"type_long":"ghidra.util.graph.Vertex","comment":"","type_short":"Vertex"}},{"javadoc":"Goes to the next child of v that has not been visited and sets the\n calling parent to be v so that we can backtrack.","static":false,"name":"goToNextWhiteChild","comment":"Goes to the next child of v that has not been visited and sets the\n calling parent to be v so that we can backtrack.","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"ghidra.util.graph.Vertex","comment":"","type_short":"Vertex"}},{"javadoc":"This makes a list of all the paths that are in a graph that terminate\n either because of a repeated vertex or hitting a sink. It then calls\n getDominanceGraph which gets the dominator for every vertex and builds a\n dominance graph.","static":false,"name":"setDominance","comment":"This makes a list of all the paths that are in a graph that terminate\n either because of a repeated vertex or hitting a sink. It then calls\n getDominanceGraph which gets the dominator for every vertex and builds a\n dominance graph.","params":[],"throws":[],"return":{"type_long":"ghidra.util.graph.DirectedGraph","comment":"","type_short":"DirectedGraph"}},{"javadoc":"This iterates through the vertices of our graph and gets the dominator\n for each.  In a new graph - dom - it adds each vertex and an edge between the\n vertex and its dominator.  It returns dom, the dominance graph.","static":false,"name":"getDominanceGraph","comment":"This iterates through the vertices of our graph and gets the dominator\n for each.  In a new graph - dom - it adds each vertex and an edge between the\n vertex and its dominator.  It returns dom, the dominance graph.","params":[],"throws":[],"return":{"type_long":"ghidra.util.graph.DirectedGraph","comment":"","type_short":"DirectedGraph"}},{"javadoc":"This function originally did not return anything.  It returns a vertex\n for the purpose of keeping track of which vertex we left off on.  So if we\n backtrack, we can copy the portion of the previous path that is contained\n in the path we are currently construction.  I tried to do this without\n passing v as a parameter and it did not work.  Something funny happened I\n suppose with JAVA and pointers.\n This  function simply adds to singlePath until there are no more white\n children which means we've either reached a sink, or the only vertices\n left are repeated meaning we have a loop.","static":false,"name":"addToPaths","comment":"This function originally did not return anything.  It returns a vertex\n for the purpose of keeping track of which vertex we left off on.  So if we\n backtrack, we can copy the portion of the previous path that is contained\n in the path we are currently construction.  I tried to do this without\n passing v as a parameter and it did not work.  Something funny happened I\n suppose with JAVA and pointers.\n This  function simply adds to singlePath until there are no more white\n children which means we've either reached a sink, or the only vertices\n left are repeated meaning we have a loop.","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"},{"type_long":"java.util.Vector","name":"singlePath","comment":"","type_short":"Vector"}],"throws":[],"return":{"type_long":"ghidra.util.graph.Vertex","comment":"","type_short":"Vertex"}},{"javadoc":"","static":false,"name":"hasWhiteChild","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Whitens the children of v.  It is only called after v has no more\n  children left and we have backtracked to the calling parent of\n  v.  This is to ensure that we don't miss out on any paths that\n  contain a child of v which has other parents.","static":false,"name":"whitenChildren","comment":"Whitens the children of v.  It is only called after v has no more\n  children left and we have backtracked to the calling parent of\n  v.  This is to ensure that we don't miss out on any paths that\n  contain a child of v which has other parents.","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setColor","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"},{"type_long":"int","name":"color","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getColor","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"setCallingParent","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"},{"type_long":"ghidra.util.graph.Vertex","name":"parent","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getCallingParent","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"ghidra.util.graph.Vertex","comment":"","type_short":"Vertex"}},{"javadoc":"","static":false,"name":"setType","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"},{"type_long":"java.lang.String","name":"type","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getType","comment":"","params":[{"type_long":"ghidra.util.graph.KeyedObject","name":"o","comment":"","type_short":"KeyedObject"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"setWeight","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"},{"type_long":"double","name":"weight","comment":"","type_short":"double"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getWeight","comment":"","params":[{"type_long":"ghidra.util.graph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"double","comment":"","type_short":"double"}},{"javadoc":"","static":false,"name":"setWeight","comment":"","params":[{"type_long":"ghidra.util.graph.Edge","name":"e","comment":"","type_short":"Edge"},{"type_long":"double","name":"weight","comment":"","type_short":"double"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getWeight","comment":"","params":[{"type_long":"ghidra.util.graph.Edge","name":"e","comment":"","type_short":"Edge"}],"throws":[],"return":{"type_long":"double","comment":"","type_short":"double"}}],"name":"Dominator","comment":"Title: Dominator\n Description: This class contains the functions necessary to build the\n dominance graph of a FlowGraph, ShrinkWrap or Modularized Graph.\n A more complete explanation of my algorithm can be found in my paper\n titled \"Building a Dominance Graph\"","fields":[{"type_long":"ghidra.util.graph.attributes.IntegerAttribute<ghidra.util.graph.Vertex>","javadoc":"","static":false,"name":"vertexColor","comment":"","type_short":"IntegerAttribute","constant_value":null},{"type_long":"ghidra.util.graph.attributes.ObjectAttribute<ghidra.util.graph.Vertex>","javadoc":"","static":false,"name":"callingParent","comment":"","type_short":"ObjectAttribute","constant_value":null},{"type_long":"ghidra.util.graph.attributes.DoubleAttribute<ghidra.util.graph.Vertex>","javadoc":"","static":false,"name":"vertexWeight","comment":"","type_short":"DoubleAttribute","constant_value":null},{"type_long":"ghidra.util.graph.attributes.DoubleAttribute<ghidra.util.graph.Edge>","javadoc":"","static":false,"name":"edgeWeight","comment":"","type_short":"DoubleAttribute","constant_value":null},{"type_long":"ghidra.util.graph.attributes.StringAttribute<ghidra.util.graph.Vertex>","javadoc":"","static":false,"name":"vertexType","comment":"","type_short":"StringAttribute","constant_value":null},{"type_long":"ghidra.util.graph.Path","javadoc":"","static":false,"name":"paths","comment":"","type_short":"Path","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"white","comment":"","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"gray","comment":"","type_short":"int","constant_value":"1"}]}
