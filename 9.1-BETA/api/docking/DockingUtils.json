{"implements":[],"javadoc":"<h1>Notes about how to use HTML safely:<\/h1>\n Java's built-in HTML rendering in UI components is very useful, but can also introduce security\n issues when a hostile actor is providing the text strings that are being rendered.\n <p>\n Before using a native Java UI component, search for a corresponding 'G'hidra component, and\n if possible choose the non-HTML version of that component (if available).\n <p>\n For instance, instead of using {@link JLabel}, use either {@link GLabel} or {@link GHtmlLabel}\n (and their variants).\n <p>\n (native JLabel, JCheckbox, etc, usage is actually disallowed in the Ghidra project)\n <p>\n When using a UI component that is HTML enabled, care must be used when constructing the text\n that is being rendered.\n <p>\n During string-building or concatenation, appending a non-literal string value (ie. \n {@code \"Hello \" + getFoo();} ), the non-literal string value should be escaped using \n {@link HTMLUtilities#escapeHTML(String)} (ie. {@code \"Hello \" + HTMLUtilities.escapeHTML(getFoo());}.\n <p>\n Of course, there are exceptions to every rule, and if the string value can be definitely be \n traced to its source and there are no user-supplied origins, the HTML escaping can be skipped.\n <p>\n Note: just using a UI component that is HTML enabled does not mean that it will treat its\n text as HTML text.  If you need to HTML escape any values that are being fed to the component, you\n need to force the HTML mode 'on' by pre-pending a \"&lt;HTML&gt;\" at the beginning of the string.\n If you fail to do this, the escaped substrings will look wrong because any '&lt;' and '&gt;' chars\n (and others) in the substring will be mangled when rendered in plain-text mode.\n <p>\n When working with plain text, try to avoid allowing a user supplied string being the first \n value of text that could be fed to a UI component.  This will prevent the possibly hostile \n string from having a leading HTML start tag.  \n (ie. when displaying an error to the user about a bad file, don't put the filename\n value at the start of the string, but instead put a quote or some other delimiter to prevent\n html mode).\n <p>\n <h1>Recommended Ghidra UI Components:<\/h1>\n <p>\n <table border=1>\n \t<tr><th>Native Component<\/th><th>Recommended Component<\/th><\/tr>\n \t<tr><td>{@link JLabel}<\/td><td>{@link GLabel}<br>{@link GDLabel}<br>{@link GHtmlLabel}<br>{@link GDHtmlLabel}<br>{@link GIconLabel}<\/td><\/tr>\n \t<tr><td>{@link JCheckBox}<\/td><td>{@link GCheckBox}<br>{@link GHtmlCheckBox}<\/td><\/tr>\n \t<tr><td>{@link JComboBox}<\/td><td>{@link GComboBox}<br>{@link GhidraComboBox}<\/td><\/tr>\n \t<tr><td>{@link JList}<\/td><td>{@link GList}<\/td><\/tr>\n \t<tr><td>{@link ListCellRenderer}<br>{@link DefaultListCellRenderer}<\/td><td>{@link GListCellRenderer}<\/td><\/tr>\n \t<tr><td>{@link TableCellRenderer}<\/td><td>{@link GTableCellRenderer}<\/td><\/tr>\n \t<tr><td>{@link TreeCellRenderer}<br>{@link DefaultTreeCellRenderer}<\/td><td>{@link GTreeRenderer}<br><code>DnDTreeCellRenderer<\/code><\/td><\/tr>\n \t<tr><td>{@link JRadioButton}<\/td><td>{@link GRadioButton}<\/td><\/tr>\n \t<tr><td>{@link JButton}<\/td><td>???tbd???<\/td><\/tr>\n <\/table>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"createToolbarSeparator","comment":"","params":[],"throws":[],"return":{"type_long":"javax.swing.JSeparator","comment":"","type_short":"JSeparator"}},{"javadoc":"","static":true,"name":"scaleIconAsNeeded","comment":"","params":[{"type_long":"javax.swing.Icon","name":"icon","comment":"","type_short":"Icon"}],"throws":[],"return":{"type_long":"javax.swing.Icon","comment":"","type_short":"Icon"}},{"javadoc":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the <tt>control<\/tt> key.  On Mac, it is the <tt>command<\/tt> key.\n@param mouseEvent the event to check\n@return true if the control key is pressed","static":true,"name":"isControlModifier","comment":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the control key.  On Mac, it is the command key.","params":[{"type_long":"java.awt.event.MouseEvent","name":"mouseEvent","comment":"the event to check","type_short":"MouseEvent"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the control key is pressed","type_short":"boolean"}},{"javadoc":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the <tt>control<\/tt> key.  On Mac, it is the <tt>command<\/tt> key.\n@param keyEvent the event to check\n@return true if the control key is pressed","static":true,"name":"isControlModifier","comment":"Checks if the mouseEvent has the \"control\" key down.  On windows, this is actually\n the control key.  On Mac, it is the command key.","params":[{"type_long":"java.awt.event.KeyEvent","name":"keyEvent","comment":"the event to check","type_short":"KeyEvent"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the control key is pressed","type_short":"boolean"}},{"javadoc":"","static":true,"name":"installUndoRedo","comment":"","params":[{"type_long":"javax.swing.text.JTextComponent","name":"textComponent","comment":"","type_short":"JTextComponent"}],"throws":[],"return":{"type_long":"docking.UndoRedoKeeper","comment":"","type_short":"UndoRedoKeeper"}},{"javadoc":"Perform some operation on a component and all of its descendants, recursively\n \n This traverses the swing\/awt component tree starting at the given container and descends\n recursively through all containers. Any time a component of type (or subclass of type) is\n found, the given callback is executed on it. If order is\n {@link TreeTraversalOrder#CHILDREN_FIRST}, then the traversal will execute the callback on\n the children of a container before executing the callback on the container itself; if\n {@link TreeTraversalOrder#PARENT_FIRST}, then the traversal will execute the callback on the\n container before descending.\n \n The callback must return one of three result values. In normal circumstances, it should\n return {@link TreeTraversalResult#CONTINUE}, allowing traversal to continue to the next\n element. If the callback wishes to terminate traversal \"successfully,\" e.g., because it\n needed to locate the first element satisfying some predicate, then it should return\n {@link TreeTraversalResult#FINISH}. If an error occurs during traversal, then it should\n either return {@link TreeTraversalResult#TERMINATE} or throw an appropriate exception to\n terminate traversal \"unsuccessfully.\"\n \n This method will also return a value of {@link TreeTraversalResult} indicating how traversal\n terminated. If {@link TreeTraversalResult#CONTINUE}, then every element in the subtree was\n visited, and traversal was successful. If {@link TreeTraversalResult#FINISH}, then some\n elements may have been omitted, but traversal was still successful. If\n {@link TreeTraversalResult#TERMINATE}, then some elements may have been omitted, and\n traversal was not successful.\n@param start the \"root\" container of the subtree on which to operate\n@param type the type of components on which to operate\n@param order whether to operation on children or parents first\n@param cb the callback to perform the actual operation\n@return a result indicating whether or not traversal completed successfully","static":true,"name":"forAllDescendants","comment":"Perform some operation on a component and all of its descendants, recursively\n \n This traverses the swing\/awt component tree starting at the given container and descends\n recursively through all containers. Any time a component of type (or subclass of type) is\n found, the given callback is executed on it. If order is\n TreeTraversalOrder#CHILDREN_FIRST, then the traversal will execute the callback on\n the children of a container before executing the callback on the container itself; if\n TreeTraversalOrder#PARENT_FIRST, then the traversal will execute the callback on the\n container before descending.\n \n The callback must return one of three result values. In normal circumstances, it should\n return TreeTraversalResult#CONTINUE, allowing traversal to continue to the next\n element. If the callback wishes to terminate traversal \"successfully,\" e.g., because it\n needed to locate the first element satisfying some predicate, then it should return\n TreeTraversalResult#FINISH. If an error occurs during traversal, then it should\n either return TreeTraversalResult#TERMINATE or throw an appropriate exception to\n terminate traversal \"unsuccessfully.\"\n \n This method will also return a value of TreeTraversalResult indicating how traversal\n terminated. If TreeTraversalResult#CONTINUE, then every element in the subtree was\n visited, and traversal was successful. If TreeTraversalResult#FINISH, then some\n elements may have been omitted, but traversal was still successful. If\n TreeTraversalResult#TERMINATE, then some elements may have been omitted, and\n traversal was not successful.","params":[{"type_long":"java.awt.Container","name":"start","comment":"the \"root\" container of the subtree on which to operate","type_short":"Container"},{"type_long":"java.lang.Class<T>","name":"type","comment":"the type of components on which to operate","type_short":"Class"},{"type_long":"docking.DockingUtils.TreeTraversalOrder","name":"order","comment":"whether to operation on children or parents first","type_short":"TreeTraversalOrder"},{"type_long":"docking.DockingUtils.ComponentCallback<T>","name":"cb","comment":"the callback to perform the actual operation","type_short":"ComponentCallback"}],"throws":[],"return":{"type_long":"docking.DockingUtils.TreeTraversalResult","comment":"a result indicating whether or not traversal completed successfully","type_short":"TreeTraversalResult"}},{"javadoc":"Perform some operation on a component and all of its descendents, recursively.\n \n This applies the operation to all components in the tree, children first.\n@param start the \"root\" container of the subtree on which to operate\n@param cb the callback to perform the actual operation\n@return a result indicating whether or not traversal completed successfully\n@see DockingUtils#forAllDescendants(Container, Class, TreeTraversalOrder, ComponentCallback)","static":true,"name":"forAllDescendants","comment":"Perform some operation on a component and all of its descendents, recursively.\n \n This applies the operation to all components in the tree, children first.","params":[{"type_long":"java.awt.Container","name":"start","comment":"the \"root\" container of the subtree on which to operate","type_short":"Container"},{"type_long":"docking.DockingUtils.ComponentCallback<java.awt.Component>","name":"cb","comment":"the callback to perform the actual operation","type_short":"ComponentCallback"}],"throws":[],"return":{"type_long":"docking.DockingUtils.TreeTraversalResult","comment":"a result indicating whether or not traversal completed successfully","type_short":"TreeTraversalResult"}},{"javadoc":"Sets the given component to transparent, which allows the parent component's background\n to be painted.\n <p>\n <u>Notes<\/u>\n Historically, to make a component transparent you would call \n {@link JComponent#setOpaque(boolean)} with a <tt>false<\/tt> value.  However, it turns out\n that the definition and the implementation of this method are at odds.  <tt>setOpaque(false)<\/tt>\n is meant to signal that some part of the component is transparent, so the parent component\n needs to be painted.  Most LaFs implemented this by not painting the background of the\n component, but used the parent's color instead.  The Nimbus LaF actually honors the \n contract of <tt>setOpaque()<\/tt>, which has the effect of painting the components \n background by default.\n <p>\n This method allows components to achieve transparency when they used to \n rely on <tt>setOpaque(false)<\/tt>.\n@param c the component to be made transparent","static":true,"name":"setTransparent","comment":"Sets the given component to transparent, which allows the parent component's background\n to be painted.\n \n Notes\n Historically, to make a component transparent you would call \n JComponent#setOpaque(boolean) with a false value.  However, it turns out\n that the definition and the implementation of this method are at odds.  setOpaque(false)\n is meant to signal that some part of the component is transparent, so the parent component\n needs to be painted.  Most LaFs implemented this by not painting the background of the\n component, but used the parent's color instead.  The Nimbus LaF actually honors the \n contract of setOpaque(), which has the effect of painting the components \n background by default.\n \n This method allows components to achieve transparency when they used to \n rely on setOpaque(false).","params":[{"type_long":"javax.swing.JComponent","name":"c","comment":"the component to be made transparent","type_short":"JComponent"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"doSetTransparent","comment":"","params":[{"type_long":"javax.swing.JComponent","name":"c","comment":"","type_short":"JComponent"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Hides any open tooltip window","static":true,"name":"hideTipWindow","comment":"Hides any open tooltip window","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"DockingUtils","comment":"Notes about how to use HTML safely:\n Java's built-in HTML rendering in UI components is very useful, but can also introduce security\n issues when a hostile actor is providing the text strings that are being rendered.\n \n Before using a native Java UI component, search for a corresponding 'G'hidra component, and\n if possible choose the non-HTML version of that component (if available).\n \n For instance, instead of using JLabel, use either GLabel or GHtmlLabel\n (and their variants).\n \n (native JLabel, JCheckbox, etc, usage is actually disallowed in the Ghidra project)\n \n When using a UI component that is HTML enabled, care must be used when constructing the text\n that is being rendered.\n \n During string-building or concatenation, appending a non-literal string value (ie. \n  ), the non-literal string value should be escaped using \n HTMLUtilities#escapeHTML(String) (ie. .\n \n Of course, there are exceptions to every rule, and if the string value can be definitely be \n traced to its source and there are no user-supplied origins, the HTML escaping can be skipped.\n \n Note: just using a UI component that is HTML enabled does not mean that it will treat its\n text as HTML text.  If you need to HTML escape any values that are being fed to the component, you\n need to force the HTML mode 'on' by pre-pending a \"HTML\" at the beginning of the string.\n If you fail to do this, the escaped substrings will look wrong because any '' and '' chars\n (and others) in the substring will be mangled when rendered in plain-text mode.\n \n When working with plain text, try to avoid allowing a user supplied string being the first \n value of text that could be fed to a UI component.  This will prevent the possibly hostile \n string from having a leading HTML start tag.  \n (ie. when displaying an error to the user about a bad file, don't put the filename\n value at the start of the string, but instead put a quote or some other delimiter to prevent\n html mode).\n \n Recommended Ghidra UI Components:\n \n \n \tNative ComponentRecommended Component\n \tJLabelGLabelGDLabelGHtmlLabelGDHtmlLabelGIconLabel\n \tJCheckBoxGCheckBoxGHtmlCheckBox\n \tJComboBoxGComboBoxGhidraComboBox\n \tJListGList\n \tListCellRendererDefaultListCellRendererGListCellRenderer\n \tTableCellRendererGTableCellRenderer\n \tTreeCellRendererDefaultTreeCellRendererGTreeRendererDnDTreeCellRenderer\n \tJRadioButtonGRadioButton\n \tJButton???tbd???\n ","fields":[{"type_long":"int","javadoc":"","static":true,"name":"ICON_SIZE","comment":"","type_short":"int","constant_value":"16"},{"type_long":"int","javadoc":"System dependent mask for the Ctrl key","static":true,"name":"CONTROL_KEY_MODIFIER_MASK","comment":"System dependent mask for the Ctrl key","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"A version the control key modifiers that is based upon the pre-Java 9 {@link InputEvent}\n usage.  This mask is here for those clients that cannot be upgraded, such as those with \n dependencies on 3rd-party libraries that still use the old mask style.\n@deprecated use instead {@link #CONTROL_KEY_MODIFIER_MASK}","static":true,"name":"CONTROL_KEY_MODIFIER_MASK_DEPRECATED","comment":"A version the control key modifiers that is based upon the pre-Java 9 InputEvent\n usage.  This mask is here for those clients that cannot be upgraded, such as those with \n dependencies on 3rd-party libraries that still use the old mask style.","type_short":"int","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"CONTROL_KEY_NAME","comment":"","type_short":"String","constant_value":null},{"type_long":"javax.swing.KeyStroke","javadoc":"","static":true,"name":"UNDO_KEYSTROKE","comment":"","type_short":"KeyStroke","constant_value":null},{"type_long":"javax.swing.KeyStroke","javadoc":"","static":true,"name":"REDO_KEYSTROKE","comment":"","type_short":"KeyStroke","constant_value":null}]}
