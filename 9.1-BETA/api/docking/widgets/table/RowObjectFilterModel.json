{"implements":["docking.widgets.table.RowObjectTableModel"],"javadoc":"","static":false,"methods":[{"javadoc":"","static":false,"name":"setTableFilter","comment":"","params":[{"type_long":"docking.widgets.table.TableFilter<ROW_OBJECT>","name":"filter","comment":"","type_short":"TableFilter"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getTableFilter","comment":"","params":[],"throws":[],"return":{"type_long":"docking.widgets.table.TableFilter<ROW_OBJECT>","comment":"","type_short":"TableFilter"}},{"javadoc":"","static":false,"name":"isFiltered","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getUnfilteredRowCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getUnfilteredData","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ROW_OBJECT>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getModelRow","comment":"","params":[{"type_long":"int","name":"viewRow","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getViewRow","comment":"","params":[{"type_long":"int","name":"modelRow","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns the view index of the given item.  When filtered, this is the index is the smaller,\n visible set of data; when unfiltered, this index is the same as that returned by\n {@link #getModelIndex(Object)}.\n \n <p>This operation will be O(n) unless the implementation is sorted, in which case the \n operation is O(log n), as it uses a binary search.\n@param t the item\n@return the view index","static":false,"name":"getViewIndex","comment":"Returns the view index of the given item.  When filtered, this is the index is the smaller,\n visible set of data; when unfiltered, this index is the same as that returned by\n #getModelIndex(Object).\n \n This operation will be O(n) unless the implementation is sorted, in which case the \n operation is O(log n), as it uses a binary search.","params":[{"type_long":"ROW_OBJECT","name":"t","comment":"the item","type_short":"ROW_OBJECT"}],"throws":[],"return":{"type_long":"int","comment":"the view index","type_short":"int"}},{"javadoc":"Returns the model index of the given item.  When filtered, this is the index is the larger,\n set of data; when unfiltered, this index is the same as that returned by\n {@link #getModelIndex(Object)}.\n \n <p>This operation will be O(n) unless the implementation is sorted, in which case the \n operation is O(log n), as it uses a binary search.\n@param t the item\n@return the model index","static":false,"name":"getModelIndex","comment":"Returns the model index of the given item.  When filtered, this is the index is the larger,\n set of data; when unfiltered, this index is the same as that returned by\n #getModelIndex(Object).\n \n This operation will be O(n) unless the implementation is sorted, in which case the \n operation is O(log n), as it uses a binary search.","params":[{"type_long":"ROW_OBJECT","name":"t","comment":"the item","type_short":"ROW_OBJECT"}],"throws":[],"return":{"type_long":"int","comment":"the model index","type_short":"int"}}],"name":"RowObjectFilterModel","comment":"","fields":[{"type_long":"java.lang.String","javadoc":"This property allows for the disabling of 'sub-filtering'.  When enabled, which is the\n default, data from current filters will be reused when additional filter criteria is\n added to that current filter.  For example,\n <blockquote>\n <p>\n Given a table has a 'contains' filter with a text value of 'bob',\n <p>\n then, if the users types an 'o' into the filter field, producing a value of 'bobo',\n <p>\n then the data that matched 'bob' will be used as the data to filter for the new 'bobo'\n text.\n <\/blockquote>\n\n <p>The downside of this is that we cache data for every completed filter.  So, in a\n degenerate case, with a large dataset, with many incremental filtering steps, where each\n did not significantly reduce the previous set of data, the table could then consume\n a large amount of memory, roughly equal to <tt>allData.size() * numberOfFilterSteps<\/tt>\n\n <p>Most tables do not have enough data for this to have a significant impact.","static":true,"name":"SUB_FILTERING_DISABLED_PROPERTY","comment":"This property allows for the disabling of 'sub-filtering'.  When enabled, which is the\n default, data from current filters will be reused when additional filter criteria is\n added to that current filter.  For example,\n \n \n Given a table has a 'contains' filter with a text value of 'bob',\n \n then, if the users types an 'o' into the filter field, producing a value of 'bobo',\n \n then the data that matched 'bob' will be used as the data to filter for the new 'bobo'\n text.\n \n\n The downside of this is that we cache data for every completed filter.  So, in a\n degenerate case, with a large dataset, with many incremental filtering steps, where each\n did not significantly reduce the previous set of data, the table could then consume\n a large amount of memory, roughly equal to allData.size() * numberOfFilterSteps\n\n Most tables do not have enough data for this to have a significant impact.","type_short":"String","constant_value":"\"tables.subfilter.disabled\""}]}
