{"implements":[],"javadoc":"A helper class to build up the potentially complicated {@link ConcurrentQ}.\n <P>\n Note: you must supply either a {@link GThreadPool} instance or a thread pool name.  Further, \n if you supply the name of a thread pool, then a private, non-shared pool will be used.  If you\n wish to make use of a shared pool, then you need to create that thread pool yourself.  See\n {@link GThreadPool#getSharedThreadPool(String)}.\n \n <P>\n Examples:\n <p>\n <pre>\n QCallback<I, R> callback = new AbstractQCallback<I, R>() {\n     public R process(I item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n \n ConcurrentQBuilder<I, R> builder = new ConcurrentQBuilder<I, R>();\n builder.setThreadPoolName(\"Thread Pool Name\");\n builder.setQueue(new PriorityBlockingQueue());\n concurrentQ = builder.build(callback);\n \n \/\/ OR, you can chain the builder calls:\n ConcurrentQBuilder<I, R> builder = new ConcurrentQBuilder<I, R>();\n queue = builder.setThreadPoolName(\"Thread Pool Name\").\n \t\t\t\tsetQueue(new PriorityBlockingQueue()).\n \t\t\t\tsetMaxInProgress(1).\n \t\t\t\tbuild(callback);\n \n <\/pre>\n <p>\n  \n Note: if you wish to take advantage of blocking when adding items to the {@link ConcurrentQ}, \n       see {@link #setQueue(Queue)}.\n@param <I> The type of the items to be processed.\n@param <R> The type of objects resulting from processing an item","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the queue to be used by the {@link ConcurrentQ}.  If you would like advanced features, \n like a queue that blocks when too many items have been placed in it, then use an \n advanced queue here, such as a {@link LinkedBlockingQueue}.\n <p>\n Note: if you wish to take advantage of blocking when adding items to the {@link ConcurrentQ}, \n       then be sure to call the appropriate method, such as \n       {@link ConcurrentQ#offer(java.util.Iterator)}.\n@param queue the queue to be used by the {@link ConcurrentQ}\n@return this builder","static":false,"name":"setQueue","comment":"Sets the queue to be used by the ConcurrentQ.  If you would like advanced features, \n like a queue that blocks when too many items have been placed in it, then use an \n advanced queue here, such as a LinkedBlockingQueue.\n \n Note: if you wish to take advantage of blocking when adding items to the ConcurrentQ, \n       then be sure to call the appropriate method, such as \n       ConcurrentQ#offer(java.util.Iterator).","params":[{"type_long":"java.util.Queue<I>","name":"queue","comment":"the queue to be used by the ConcurrentQ","type_short":"Queue"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"this builder","type_short":"ConcurrentQBuilder"}},{"javadoc":"Specifies the maximum number of items that can be process at a time.  \n If this is set to 0, then the concurrent queue will attempt to execute as many \n items at a time as there are threads in the given threadPool.  Setting \n this parameter to 1 will have the effect of guaranteeing that\n all times are processed one at a time in the order they were submitted.\n Any other positive value will run that many items concurrently, \n up to the number of available threads.\n@param max the max number of items to execute at one time; defaults to 0\n@return this builder instance","static":false,"name":"setMaxInProgress","comment":"Specifies the maximum number of items that can be process at a time.  \n If this is set to 0, then the concurrent queue will attempt to execute as many \n items at a time as there are threads in the given threadPool.  Setting \n this parameter to 1 will have the effect of guaranteeing that\n all times are processed one at a time in the order they were submitted.\n Any other positive value will run that many items concurrently, \n up to the number of available threads.","params":[{"type_long":"int","name":"max","comment":"the max number of items to execute at one time; defaults to 0","type_short":"int"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"this builder instance","type_short":"ConcurrentQBuilder"}},{"javadoc":"Sets the name to be used when creating a <b>private thread pool<\/b>.  If you wish to use\n a <i>shared thread pool<\/i>, then you need to create that thread pool youself and call\n {@link #setThreadPool(GThreadPool)}.\n@param name the name of the thread pool.\n@return this builder instance\n@see GThreadPool#getSharedThreadPool(String)","static":false,"name":"setThreadPoolName","comment":"Sets the name to be used when creating a private thread pool.  If you wish to use\n a shared thread pool, then you need to create that thread pool youself and call\n #setThreadPool(GThreadPool).","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the thread pool.","type_short":"String"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"this builder instance","type_short":"ConcurrentQBuilder"}},{"javadoc":"Use the given thread pool for processing the work items.  If you do not care to configure\n the thread pool used and you do not wish to make use of shared thread pools, then you \n can call {@link #setThreadPoolName(String)} instead of this method.\n@param threadPool the thread pool to use\n@return this builder instance\n@see GThreadPool#getSharedThreadPool(String)","static":false,"name":"setThreadPool","comment":"Use the given thread pool for processing the work items.  If you do not care to configure\n the thread pool used and you do not wish to make use of shared thread pools, then you \n can call #setThreadPoolName(String) instead of this method.","params":[{"type_long":"generic.concurrent.GThreadPool","name":"threadPool","comment":"the thread pool to use","type_short":"GThreadPool"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"this builder instance","type_short":"ConcurrentQBuilder"}},{"javadoc":"Specifies if the concurrent queue should collect the results as items are processed\n so they can be returned in a {@link ConcurrentQ#waitForResults()} call.\n@param collectResults true signals to collect the generated results; defaults to false\n@return this builder instance","static":false,"name":"setCollectResults","comment":"Specifies if the concurrent queue should collect the results as items are processed\n so they can be returned in a ConcurrentQ#waitForResults() call.","params":[{"type_long":"boolean","name":"collectResults","comment":"true signals to collect the generated results; defaults to false","type_short":"boolean"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"this builder instance","type_short":"ConcurrentQBuilder"}},{"javadoc":"True signals that the jobs run by the client wish to report progress.  The default value \n is false.\n <p>\n The default of false is good for clients that have a known amount of work to be processed.\n In this case, a total count of work jobs is maintained by the queue.  As items are \n completed, the queue will update the monitor provided to it at construction time to reflect\n the number of jobs completed as work is done.  On the other hand, some clients have \n known known number of jobs to complete, but simply add work to the queue as it arrives.  \n In that case, the client should update its monitor for progress, as the queue cannot \n do so in a meaningful way.\n@param reportsProgress true signals that the client will update progress; false signals \n        that the queue should do so\n@return this builder instance","static":false,"name":"setJobsReportProgress","comment":"True signals that the jobs run by the client wish to report progress.  The default value \n is false.\n \n The default of false is good for clients that have a known amount of work to be processed.\n In this case, a total count of work jobs is maintained by the queue.  As items are \n completed, the queue will update the monitor provided to it at construction time to reflect\n the number of jobs completed as work is done.  On the other hand, some clients have \n known known number of jobs to complete, but simply add work to the queue as it arrives.  \n In that case, the client should update its monitor for progress, as the queue cannot \n do so in a meaningful way.","params":[{"type_long":"boolean","name":"reportsProgress","comment":"true signals that the client will update progress; false signals \n        that the queue should do so","type_short":"boolean"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"this builder instance","type_short":"ConcurrentQBuilder"}},{"javadoc":"","static":false,"name":"setListener","comment":"","params":[{"type_long":"generic.concurrent.QItemListener<I,R>","name":"listener","comment":"","type_short":"QItemListener"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"","type_short":"ConcurrentQBuilder"}},{"javadoc":"","static":false,"name":"setMonitor","comment":"","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"","type_short":"ConcurrentQBuilder"}},{"javadoc":"@see {@link ConcurrentQ#setMonitor(TaskMonitor, boolean)}\n <p>\n The default value is <tt>true<\/tt>.","static":false,"name":"setCancelClearsAllJobs","comment":"","params":[{"type_long":"boolean","name":"clearAllJobs","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQBuilder<I,R>","comment":"","type_short":"ConcurrentQBuilder"}},{"javadoc":"","static":false,"name":"build","comment":"","params":[{"type_long":"generic.concurrent.QCallback<I,R>","name":"callback","comment":"","type_short":"QCallback"}],"throws":[],"return":{"type_long":"generic.concurrent.ConcurrentQ<I,R>","comment":"","type_short":"ConcurrentQ"}},{"javadoc":"","static":false,"name":"getThreadPool","comment":"","params":[],"throws":[],"return":{"type_long":"generic.concurrent.GThreadPool","comment":"","type_short":"GThreadPool"}},{"javadoc":"","static":false,"name":"getQueue","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Queue<I>","comment":"","type_short":"Queue"}}],"name":"ConcurrentQBuilder","comment":"A helper class to build up the potentially complicated ConcurrentQ.\n \n Note: you must supply either a GThreadPool instance or a thread pool name.  Further, \n if you supply the name of a thread pool, then a private, non-shared pool will be used.  If you\n wish to make use of a shared pool, then you need to create that thread pool yourself.  See\n GThreadPool#getSharedThreadPool(String).\n \n \n Examples:\n \n \n QCallbackI, R callback = new AbstractQCallbackI, R() {\n     public R process(I item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n \n ConcurrentQBuilderI, R builder = new ConcurrentQBuilderI, R();\n builder.setThreadPoolName(\"Thread Pool Name\");\n builder.setQueue(new PriorityBlockingQueue());\n concurrentQ = builder.build(callback);\n \n \/\/ OR, you can chain the builder calls:\n ConcurrentQBuilderI, R builder = new ConcurrentQBuilderI, R();\n queue = builder.setThreadPoolName(\"Thread Pool Name\").\n \t\t\t\tsetQueue(new PriorityBlockingQueue()).\n \t\t\t\tsetMaxInProgress(1).\n \t\t\t\tbuild(callback);\n \n \n \n  \n Note: if you wish to take advantage of blocking when adding items to the ConcurrentQ, \n       see #setQueue(Queue).","fields":[{"type_long":"java.util.Queue<I>","javadoc":"","static":false,"name":"queue","comment":"","type_short":"Queue","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"threadPoolName","comment":"","type_short":"String","constant_value":null},{"type_long":"generic.concurrent.GThreadPool","javadoc":"","static":false,"name":"threadPool","comment":"","type_short":"GThreadPool","constant_value":null},{"type_long":"generic.concurrent.QItemListener<I,R>","javadoc":"","static":false,"name":"listener","comment":"","type_short":"QItemListener","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"collectResults","comment":"","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"maxInProgress","comment":"","type_short":"int","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"jobsReportProgress","comment":"","type_short":"boolean","constant_value":null},{"type_long":"ghidra.util.task.TaskMonitor","javadoc":"","static":false,"name":"monitor","comment":"","type_short":"TaskMonitor","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"cancelClearsAllJobs","comment":"","type_short":"boolean","constant_value":null}]}
