{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a column object that is usable by the given model.\n <p>\n Dynamic columns and models work on row types.  This method allows clients to use columns\n with row types that differ from the model's row type, as long as a suitable mapper can\n be found.  If no mapper can be found, then an IllegalArgumentException is thrown.  Also,\n if the given column is of the correct type, then that column is returned.\n@param <ROW_TYPE> the <b>model's<\/b> row type\n@param <COLUMN_TYPE> the <b>model's<\/b> row type\n@param model the table model for which a column is needed\n@param column the column that you want to use with the given model\n@return a column object that is usable by the given model.\n@throws IllegalArgumentException if this method cannot figure out how to map the given\n         column's row type to the given model's row type.","static":true,"name":"adaptColumForModel","comment":"Returns a column object that is usable by the given model.\n \n Dynamic columns and models work on row types.  This method allows clients to use columns\n with row types that differ from the model's row type, as long as a suitable mapper can\n be found.  If no mapper can be found, then an IllegalArgumentException is thrown.  Also,\n if the given column is of the correct type, then that column is returned.","params":[{"type_long":"docking.widgets.table.GDynamicColumnTableModel<ROW_TYPE,COLUMN_TYPE>","name":"model","comment":"the table model for which a column is needed","type_short":"GDynamicColumnTableModel"},{"type_long":"docking.widgets.table.AbstractDynamicTableColumn<?,?,?>","name":"column","comment":"the column that you want to use with the given model","type_short":"AbstractDynamicTableColumn"}],"throws":[],"return":{"type_long":"docking.widgets.table.DynamicTableColumn<ROW_TYPE,COLUMN_TYPE,DATA_SOURCE>","comment":"a column object that is usable by the given model.","type_short":"DynamicTableColumn"}},{"javadoc":"Returns all \"discovered\" {@link AbstractDynamicTableColumn} classes that are compatible with the\n given class, which represents the object for a table's row.  For example, many tables use\n <tt>Address<\/tt> as the row type.  In this case, passing <tt>Address.class<\/tt> as the\n parameter to this method will return all {@link AbstractDynamicTableColumn}s that can provide column\n data by working with <tt>Address<\/tt> instances.\n \n <p><u>Usage Notes:<\/u>  This class will not only discover {@link AbstractDynamicTableColumn}s\n that directly support the given class type, but will also use discovered\n {@link TableRowMapper} objects to create adapters that allow the\n use of table row data that does not exactly match the supported type of discovered\n {@link AbstractDynamicTableColumn} classes.  For example, suppose that a table's row type is\n <tt>Address<\/tt>.  This methods will return at least all {@link AbstractDynamicTableColumn}s\n that support <tt>Address<\/tt> data.  In order to support extra columns, Ghidra has\n created a {@link TableRowMapper} that can convert a <tt>ProgramLocation<\/tt> into an\n <tt>Address<\/tt>.  This method will find and use this mapper to return a\n {@link MappedTableColumn} instance (which is an {@link AbstractDynamicTableColumn}).  By doing\n this, any table that has <tt>Address<\/tt> objects as its row type can now use\n {@link AbstractDynamicTableColumn}s that support <tt>ProgramLocations<\/tt> in addition to\n <tt>Address<\/tt> objects.  These mappers provide a way for tables that have non-standard\n Ghidra data as their row type to take advantage of existing dynamic columns for standard\n Ghidra data (like ProgramLocations and Addresses).\n@param rowTypeClass table's row type\n@return the discovered column","static":true,"name":"getDynamicTableColumns","comment":"Returns all \"discovered\" AbstractDynamicTableColumn classes that are compatible with the\n given class, which represents the object for a table's row.  For example, many tables use\n Address as the row type.  In this case, passing Address.class as the\n parameter to this method will return all AbstractDynamicTableColumns that can provide column\n data by working with Address instances.\n \n Usage Notes:  This class will not only discover AbstractDynamicTableColumns\n that directly support the given class type, but will also use discovered\n TableRowMapper objects to create adapters that allow the\n use of table row data that does not exactly match the supported type of discovered\n AbstractDynamicTableColumn classes.  For example, suppose that a table's row type is\n Address.  This methods will return at least all AbstractDynamicTableColumns\n that support Address data.  In order to support extra columns, Ghidra has\n created a TableRowMapper that can convert a ProgramLocation into an\n Address.  This method will find and use this mapper to return a\n MappedTableColumn instance (which is an AbstractDynamicTableColumn).  By doing\n this, any table that has Address objects as its row type can now use\n AbstractDynamicTableColumns that support ProgramLocations in addition to\n Address objects.  These mappers provide a way for tables that have non-standard\n Ghidra data as their row type to take advantage of existing dynamic columns for standard\n Ghidra data (like ProgramLocations and Addresses).","params":[{"type_long":"java.lang.Class<ROW_TYPE>","name":"rowTypeClass","comment":"table's row type","type_short":"Class"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.DynamicTableColumn<ROW_TYPE,?,?>>","comment":"the discovered column","type_short":"Collection"}},{"javadoc":"","static":true,"name":"getTableColumExtensions","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.DynamicTableColumn<?,?,?>>","comment":"","type_short":"Collection"}},{"javadoc":"If the given <tt>DynamicTableColumn<\/tt> is a match for the given <tt>rowTypeClass<\/tt>, then\n it will be added to the given list.\n <p>\n <u>Implementation Notes:<\/u>\n This method does some odd things with Java Generics.  Specifically, it declares three\n generic types, but only relies on the caller of the method to provide one of those types.\n Further, in some cases the method uses the Generic wildcard '?' feature.  In one case it\n does not use this feature, since we need to create a new object, and the\n compiler requires that we have a type and not a wildcard to do this.  In this usage, we are\n just guaranteeing that the created type matches our needs, even though we don't know what\n that type actually is.\n@param <COLUMN_ROW_TYPE> A placeholder type for discovered column row types\n                          that may differ from the given TABLE_ROW_TYPE.\n@param <TABLE_ROW_TYPE> The class of the table's row data\n@param <COLUMN_TYPE> The type of object that the column generates from the call to\n                          column's <tt>getValue()<\/t> method.\n@param rowTypeClass The class of the table's row data (with the same type as\n \t\t\t\t\t\t    COLUMN_ROW_TYPE)\n@param tableColumn The column to add to the given collection if it supports the\n                          given <tt>rowTypeClass<\/tt>.","static":true,"name":"getTableColumnForTypes","comment":"If the given DynamicTableColumn is a match for the given rowTypeClass, then\n it will be added to the given list.\n \n Implementation Notes:\n This method does some odd things with Java Generics.  Specifically, it declares three\n generic types, but only relies on the caller of the method to provide one of those types.\n Further, in some cases the method uses the Generic wildcard '?' feature.  In one case it\n does not use this feature, since we need to create a new object, and the\n compiler requires that we have a type and not a wildcard to do this.  In this usage, we are\n just guaranteeing that the created type matches our needs, even though we don't know what\n that type actually is.","params":[{"type_long":"java.lang.Class<TABLE_ROW_TYPE>","name":"rowTypeClass","comment":"The class of the table's row data (with the same type as\n \t\t\t\t\t\t    COLUMN_ROW_TYPE)","type_short":"Class"},{"type_long":"docking.widgets.table.DynamicTableColumn<?,?,?>","name":"tableColumn","comment":"The column to add to the given collection if it supports the\n                          given rowTypeClass.","type_short":"DynamicTableColumn"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.DynamicTableColumn<TABLE_ROW_TYPE,COLUMN_TYPE,DATA_SOURCE>>","comment":"","type_short":"Collection"}},{"javadoc":"Returns a {@link TableRowMapper} for the given class types if one is found.  The\n returned mapper will know how to translate instances of <tt>fromType<\/tt> to\n <tt>toType<\/tt>.\n@param <ROW_TYPE> The type of row that is defined by the table\n@param <EXPECTED_TYPE> The type of row object that is desired\n@param fromType The <tt>Class<\/tt> object of the given row type\n@param toType The <tt>Class<\/tt> object of the desired row type\n@return a new TableRowMapper","static":true,"name":"getTableRowObjectMapper","comment":"Returns a TableRowMapper for the given class types if one is found.  The\n returned mapper will know how to translate instances of fromType to\n toType.","params":[{"type_long":"java.lang.Class<ROW_TYPE>","name":"fromType","comment":"The Class object of the given row type","type_short":"Class"},{"type_long":"java.lang.Class<?>","name":"toType","comment":"The Class object of the desired row type","type_short":"Class"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.TableRowMapper<ROW_TYPE,EXPECTED_TYPE,DATA_SOURCE>>","comment":"a new TableRowMapper","type_short":"Collection"}},{"javadoc":"","static":true,"name":"createMappedTableColumn","comment":"","params":[{"type_long":"java.util.Collection<docking.widgets.table.TableRowMapper<ROW_TYPE,EXPECTED_TYPE,DATA_SOURCE>>","name":"mappers","comment":"","type_short":"Collection"},{"type_long":"docking.widgets.table.DynamicTableColumn<EXPECTED_TYPE,COLUMN_TYPE,DATA_SOURCE>","name":"wrappedColumn","comment":"","type_short":"DynamicTableColumn"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.DynamicTableColumn<ROW_TYPE,COLUMN_TYPE,DATA_SOURCE>>","comment":"","type_short":"Collection"}},{"javadoc":"Returns a list of all the {@link ColumnConstraint} that are capable of filtering the\n destination type of the given mapper.  The mapper will be used to create a mapped constraint\n that will be called with an instance of the type <code>T<\/code>.\n@param mapper the mapper that will be used to convert\n@return a list of all the {@link ColumnConstraint} that are capable of filtering the\n \t\t   given column type","static":true,"name":"getColumnConstraints","comment":"Returns a list of all the ColumnConstraint that are capable of filtering the\n destination type of the given mapper.  The mapper will be used to create a mapped constraint\n that will be called with an instance of the type T.","params":[{"type_long":"docking.widgets.table.constraint.ColumnTypeMapper<T,M>","name":"mapper","comment":"the mapper that will be used to convert","type_short":"ColumnTypeMapper"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"a list of all the ColumnConstraint that are capable of filtering the\n \t\t   given column type","type_short":"Collection"}},{"javadoc":"Returns a list of all the {@link ColumnConstraint} that are capable of filtering the\n given column type.\n@param columnType the class of the data that is return by the table model for specific column.\n@return a list of all the {@link ColumnConstraint} that are capable of filtering the\n given column type.","static":true,"name":"getColumnConstraints","comment":"Returns a list of all the ColumnConstraint that are capable of filtering the\n given column type.","params":[{"type_long":"java.lang.Class<T>","name":"columnType","comment":"the class of the data that is return by the table model for specific column.","type_short":"Class"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"a list of all the ColumnConstraint that are capable of filtering the\n given column type.","type_short":"Collection"}},{"javadoc":"","static":true,"name":"initializeColumnConstraints","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"generateMappedConstraints","comment":"","params":[{"type_long":"docking.widgets.table.constraint.ColumnTypeMapper<T,M>","name":"mapper","comment":"","type_short":"ColumnTypeMapper"},{"type_long":"java.util.List<docking.widgets.table.constraint.ColumnConstraint<?>>","name":"foundConstraints","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<?>>","comment":"","type_short":"Collection"}},{"javadoc":"","static":true,"name":"mapConstraints","comment":"","params":[{"type_long":"docking.widgets.table.constraint.ColumnTypeMapper<T,M>","name":"mapper","comment":"","type_short":"ColumnTypeMapper"},{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<M>>","name":"constraints","comment":"","type_short":"Collection"}],"throws":[],"return":{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"","type_short":"Collection"}},{"javadoc":"","static":true,"name":"getMatchingConstraints","comment":"","params":[{"type_long":"java.util.List<docking.widgets.table.constraint.ColumnConstraint<?>>","name":"constraints","comment":"","type_short":"List"},{"type_long":"java.lang.Class<T>","name":"destinationType","comment":"","type_short":"Class"}],"throws":[],"return":{"type_long":"java.util.List<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"","type_short":"List"}},{"javadoc":"","static":true,"name":"hasGoodStringConversion","comment":"","params":[{"type_long":"java.lang.Class<?>","name":"columnType","comment":"","type_short":"Class"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"wrapToStringConstraints","comment":"","params":[{"type_long":"java.lang.Class<T>","name":"type","comment":"","type_short":"Class"},{"type_long":"java.util.Collection<docking.widgets.table.constraint.ColumnConstraint<java.lang.String>>","name":"stringConstraints","comment":"","type_short":"Collection"}],"throws":[],"return":{"type_long":"java.util.List<docking.widgets.table.constraint.ColumnConstraint<T>>","comment":"","type_short":"List"}},{"javadoc":"","static":true,"name":"findColumnConstraints","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<docking.widgets.table.constraint.ColumnConstraint<?>>","comment":"","type_short":"List"}}],"name":"DiscoverableTableUtils","comment":"","fields":[{"type_long":"java.util.List<docking.widgets.table.constraint.ColumnConstraint<?>>","javadoc":"","static":true,"name":"columnConstraints","comment":"","type_short":"List","constant_value":null}]}
