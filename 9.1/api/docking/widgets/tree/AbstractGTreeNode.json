{"implements":[],"javadoc":"Base class for GTNodes.  To create a simple GTNode where nodes will be added immediately\n using the addNode() methods, simply extend this class and implement the following methods:\n\n <ul>\n \t\t<li>getName()<\/li>\n \t\t<li>getToolTip()<\/li>\n \t\t<li>isLeaf()<\/li>\n \t\t<li>getIcon()<\/li>\n <\/ul>\n\n <a name=\"usage\"><\/a>Usage Notes:\n <ul>\n \t<li>The <b><tt>equals()<\/tt><\/b> method:  The <tt>GTree<\/tt> has the ability to remember expanded and\n      selected states.  This will only work if the nodes in the saved state can be matched\n      with the nodes in the <tt>GTree<\/tt>.  Java will do this by using the <tt>equals()<\/tt> method.\n      There is a potential problem with this usage.  If nodes within the <tt>GTree<\/tt> get rebuilt (\n      i.e., new nodes are created), then, by default, the expanded and selected state\n      feature will be unable to find the correct nodes, since the default <tt>equals()<\/tt>\n      method on <tt>GTreeNode<\/tt> performs a comparison based upon instances.  To fix this problem you\n      must override the <tt>equals()<\/tt> method that can find the same logical nodes when\n      the instances in memory have changed; typically this is done by overriding <tt>equals()<\/tt>\n       to compare by node name.\n      <p><br>\n      <p>\n      The <tt>GTreeNode<\/tt> has already overridden {@link #hashCode()} so that the node name is\n       used to generate the correct value.  If you override the {@link #equals(Object)} method,\n      <b>and you do not compare only by {@link #getName()}, then you must also override the\n      {@link #hashCode()} method to generate a value based upon the same algorithm used by the\n       new <tt>equals()<\/tt> method.<\/b>\n      <p><br>\n      <p>\n      As a rule of thumb, unless you want to allow multiple nodes under one parent with the\n      same name, then it is a swell idea to override the <tt>equals()<\/tt> method to compare on\n      {@link #getName()}, as outlined above.\n   <\/li>\n <\/ul>","static":false,"extends":"docking.widgets.tree.CoreGTreeNode","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This will be called when it is time to load children.  Some subclasses may not use this\n method, but may instead have children externally added.","static":false,"name":"loadChildren","comment":"This will be called when it is time to load children.  Some subclasses may not use this\n method, but may instead have children externally added.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"addNode","comment":"","params":[{"type_long":"docking.widgets.tree.GTreeNode","name":"node","comment":"","type_short":"GTreeNode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"addNode","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"},{"type_long":"docking.widgets.tree.GTreeNode","name":"node","comment":"","type_short":"GTreeNode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"compareTo","comment":"","params":[{"type_long":"docking.widgets.tree.GTreeNode","name":"node","comment":"","type_short":"GTreeNode"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getAllChildren","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<docking.widgets.tree.GTreeNode>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getChildren","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<docking.widgets.tree.GTreeNode>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getChildCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getAllChildCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getChild","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"docking.widgets.tree.GTreeNode","comment":"","type_short":"GTreeNode"}},{"javadoc":"","static":false,"name":"getChild","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"docking.widgets.tree.GTreeNode","comment":"","type_short":"GTreeNode"}},{"javadoc":"","static":false,"name":"getNodeCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getLeafCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getIndexInParent","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getIndexOfChild","comment":"","params":[{"type_long":"docking.widgets.tree.GTreeNode","name":"node","comment":"","type_short":"GTreeNode"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getTreePath","comment":"","params":[],"throws":[],"return":{"type_long":"javax.swing.tree.TreePath","comment":"","type_short":"TreePath"}},{"javadoc":"","static":false,"name":"removeAll","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setChildren","comment":"","params":[{"type_long":"java.util.List<docking.widgets.tree.GTreeNode>","name":"childList","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isAncestor","comment":"","params":[{"type_long":"docking.widgets.tree.GTreeNode","name":"node","comment":"","type_short":"GTreeNode"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"allPaths","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.Iterable<javax.swing.tree.TreePath>","comment":"","type_short":"Iterable"}},{"javadoc":"","static":false,"name":"iterator","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<docking.widgets.tree.GTreeNode>","comment":"","type_short":"Iterator"}},{"javadoc":"","static":false,"name":"filter","comment":"","params":[{"type_long":"docking.widgets.tree.support.GTreeFilter","name":"filter","comment":"","type_short":"GTreeFilter"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"},{"type_long":"int","name":"min","comment":"","type_short":"int"},{"type_long":"int","name":"max","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"stopCurrentFilterAndRestart","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"doFilter","comment":"","params":[{"type_long":"docking.widgets.tree.support.GTreeFilter","name":"filter","comment":"","type_short":"GTreeFilter"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"},{"type_long":"int","name":"min","comment":"","type_short":"int"},{"type_long":"int","name":"max","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clearFilter","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isFilteredOut","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"valueChanged","comment":"","params":[{"type_long":"java.lang.Object","name":"newValue","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isEditable","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getRoot","comment":"","params":[],"throws":[],"return":{"type_long":"docking.widgets.tree.GTreeRootNode","comment":"","type_short":"GTreeRootNode"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getTree","comment":"","params":[],"throws":[],"return":{"type_long":"docking.widgets.tree.GTree","comment":"","type_short":"GTree"}},{"javadoc":"","static":false,"name":"getPathToRoot","comment":"","params":[{"type_long":"docking.widgets.tree.GTreeNode","name":"node","comment":"","type_short":"GTreeNode"},{"type_long":"int","name":"depth","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"docking.widgets.tree.GTreeNode[]","comment":"","type_short":"docking.widgets.tree.GTreeNode[]"}},{"javadoc":"","static":false,"name":"getFilter","comment":"","params":[],"throws":[],"return":{"type_long":"docking.widgets.tree.support.GTreeFilter","comment":"","type_short":"GTreeFilter"}}],"name":"AbstractGTreeNode","comment":"Base class for GTNodes.  To create a simple GTNode where nodes will be added immediately\n using the addNode() methods, simply extend this class and implement the following methods:\n\n \n \t\tgetName()\n \t\tgetToolTip()\n \t\tisLeaf()\n \t\tgetIcon()\n \n\n Usage Notes:\n \n \tThe equals() method:  The GTree has the ability to remember expanded and\n      selected states.  This will only work if the nodes in the saved state can be matched\n      with the nodes in the GTree.  Java will do this by using the equals() method.\n      There is a potential problem with this usage.  If nodes within the GTree get rebuilt (\n      i.e., new nodes are created), then, by default, the expanded and selected state\n      feature will be unable to find the correct nodes, since the default equals()\n      method on GTreeNode performs a comparison based upon instances.  To fix this problem you\n      must override the equals() method that can find the same logical nodes when\n      the instances in memory have changed; typically this is done by overriding equals()\n       to compare by node name.\n      \n      \n      The GTreeNode has already overridden #hashCode() so that the node name is\n       used to generate the correct value.  If you override the #equals(Object) method,\n      and you do not compare only by #getName(), then you must also override the\n      #hashCode() method to generate a value based upon the same algorithm used by the\n       new equals() method.\n      \n      \n      As a rule of thumb, unless you want to allow multiple nodes under one parent with the\n      same name, then it is a swell idea to override the equals() method to compare on\n      #getName(), as outlined above.\n   \n ","fields":[{"type_long":"java.util.concurrent.atomic.AtomicBoolean","javadoc":"","static":false,"name":"isFiltering","comment":"","type_short":"AtomicBoolean","constant_value":null}]}
