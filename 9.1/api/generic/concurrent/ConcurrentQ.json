{"implements":[],"javadoc":"A queue for easily scheduling tasks to be run in parallel (or sequentially) \n via a thread pool.  This class provides a clean separation of items that need to \n be processed from the algorithm that does the processing, making it easy to parallelize \n the processing of multiple items.   Further, you can control the maximum number of items that\n can be processed concurrently.  This is useful to throttle operations that may starve the\n other threads in the system.  You may also control how many items get placed into the queue\n at one time, blocking if some threshold is exceeded.\n <p>\n Examples:\n <hr>\n <p>\n <u>Put and Forget:<\/u>\n <pre>\n QCallback<ITEM, RESULT> callback = new AbstractQCallback<ITEM, RESULT>() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n \n ConcurrentQBuilder<ITEM, RESULT> builder = new ConcurrentQBuilder<ITEM, RESULT>();\n builder.setThreadPoolName(\"Thread Pool Name\");\n concurrentQ = builder.getQueue(callback);\n ...\n ...\n concurrentQ.add(item); \/\/ where item is one of the instances of ITEM\n \n <\/pre>\n <hr>\n <p>\n <u>Put Items and Handle Results in Any Order as They Available:<\/u>\n <pre>\n QCallback<ITEM, RESULT> callback = new AbstractQCallback<ITEM, RESULT>() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n \n QItemListener<ITEM, RESULT> itemListener = new QItemListener<ITEM, RESULT>() {\n     public void itemProcessed(QResult<ITEM, RESULT> result) {\n         RESULT result = result.getResult();\n             <font color=\"blue\"><b>\/\/ work on my result...<\/b><\/font>\n         }\n };\n \n ConcurrentQBuilder<ITEM, RESULT> builder = new ConcurrentQBuilder<ITEM, RESULT>();\n builder.setThreadPoolName(\"Thread Pool Name\");\n <font color=\"blue\"><b>builder.setListener(itemListener);<\/b><\/font>\n concurrentQ = builder.build(callback);\n ...\n ...\n concurrentQ.add(item); \/\/ where item is one of the instances of ITEM\n concurrentQ.add(item);\n concurrentQ.add(item);\n \n <\/pre>\n \n <hr>\n <p>\n <u>Put Items and Handle Results When All Items Have Been Processed:<\/u>\n <pre>\n QCallback<ITEM, RESULT> callback = new AbstractQCallback<ITEM, RESULT>() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n\n ConcurrentQBuilder<ITEM, RESULT> builder = new ConcurrentQBuilder<ITEM, RESULT>();\n builder.setThreadPoolName(\"Thread Pool Name\");\n <font color=\"blue\"><b>builder.setCollectResults(true);<\/b><\/font>\n concurrentQ = builder.getQueue(callback);\n ...\n ...\n concurrentQ.add(item); \/\/ where item is one of the instances of ITEM\n concurrentQ.add(item);\n concurrentQ.add(item);\n ...\n <font color=\"blue\"><b>List&lt;QResult&lt;I, R&gt;&gt; results = concurrentQ.waitForResults();<\/b><\/font>\n \/\/ process the results...\n \n <\/pre>\n <hr>\n <p>\n <u>Put Items, <b>Blocking While Full<\/b>, and Handle Results in Any Order as They Available:<\/u>\n <pre>\n QCallback<ITEM, RESULT> callback = new AbstractQCallback<ITEM, RESULT>() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n\n QItemListener<ITEM, RESULT> itemListener = new QItemListener<ITEM, RESULT>() {\n     public void itemProcessed(QResult<ITEM, RESULT> result) {\n         RESULT result = result.getResult();\n             \/\/ work on my result...\n         }\n };\n \n ConcurrentQBuilder<ITEM, RESULT> builder = new ConcurrentQBuilder<ITEM, RESULT>();\n \tbuilder.setThreadPoolName(\"Thread Pool Name\");\n <font color=\"blue\"><b>builder.setQueue(new LinkedBlockingQueue(100));<\/b><\/font>\n concurrentQ = builder.getQueue(callback);\n ...\n ...\n Iterator<ITEM> iterator = &lt;get an iterator for 1000s of items somewhere&gt;\n <font color=\"blue\"><b>concurrentQ.offer(iterator); \/\/ this call will block when the queue fills up (100 items or more)<\/b><\/font>\n \n <\/pre>\n <hr>\n@param <I> The type of the items to be processed.\n@param <R> The type of objects resulting from processing an item; if you don't care about the\n            return value, then make this value whatever you want, like <tt>Object<\/tt> or the \n            same value as {@link I} and return null from {@link QCallback#process(Object, TaskMonitor)}.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Creates a ConcurrentQ that will process as many items as the given threadPool can handle\n at one time.\n@param name The name of the thread pool that will be created by this constructor.\n@param callback the QWorker object that will be used to process items concurrently.","static":false,"name":"<init>","comment":"Creates a ConcurrentQ that will process as many items as the given threadPool can handle\n at one time.","params":[{"type_long":"java.lang.String","name":"name","comment":"The name of the thread pool that will be created by this constructor.","type_short":"String"},{"type_long":"generic.concurrent.QCallback<I,R>","name":"callback","comment":"the QWorker object that will be used to process items concurrently.","type_short":"QCallback"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a ConcurrentQ that will process at most maxInProgress items at a time, regardless of\n how many threads are available in the GThreadPool.\n@param callback the QWorker object that will be used to process items concurrently.\n@param queue the internal storage queue to use in this concurrent queue.\n@param threadPool the GThreadPool to used for providing the threads for concurrent processing.\n@param listener An optional QItemListener that will be called back with results when the \n                item has been processed.\n@param collectResults specifies if this queue should collect the results as items are processed\n                 so they can be returned in a waitForResults() call.\n@param maxInProgress specifies the maximum number of items that can be process at a time.  \n                 If this is set to 0, then this queue will attempt to execute as many \n                 items at a time as there are threads in the given threadPool.  Setting \n                 this parameter to 1 will have the effect of guaranteeing that\n                 all times are processed one at a time in the order they were submitted.\n                 Any other positive value will run that many items concurrently, \n                 up to the number of available threads.\n@param jobsReportProgress true signals that jobs wish to report progress via their task\n                 monitor.  The default is false, which triggers this queue to report an \n                 overall progress for each job that is processed.  False is a good default\n                 for clients that have a finite number of jobs to be done.","static":false,"name":"<init>","comment":"Creates a ConcurrentQ that will process at most maxInProgress items at a time, regardless of\n how many threads are available in the GThreadPool.","params":[{"type_long":"generic.concurrent.QCallback<I,R>","name":"callback","comment":"the QWorker object that will be used to process items concurrently.","type_short":"QCallback"},{"type_long":"java.util.Queue<I>","name":"queue","comment":"the internal storage queue to use in this concurrent queue.","type_short":"Queue"},{"type_long":"generic.concurrent.GThreadPool","name":"threadPool","comment":"the GThreadPool to used for providing the threads for concurrent processing.","type_short":"GThreadPool"},{"type_long":"generic.concurrent.QItemListener<I,R>","name":"listener","comment":"An optional QItemListener that will be called back with results when the \n                item has been processed.","type_short":"QItemListener"},{"type_long":"boolean","name":"collectResults","comment":"specifies if this queue should collect the results as items are processed\n                 so they can be returned in a waitForResults() call.","type_short":"boolean"},{"type_long":"int","name":"maxInProgress","comment":"specifies the maximum number of items that can be process at a time.  \n                 If this is set to 0, then this queue will attempt to execute as many \n                 items at a time as there are threads in the given threadPool.  Setting \n                 this parameter to 1 will have the effect of guaranteeing that\n                 all times are processed one at a time in the order they were submitted.\n                 Any other positive value will run that many items concurrently, \n                 up to the number of available threads.","type_short":"int"},{"type_long":"boolean","name":"jobsReportProgress","comment":"true signals that jobs wish to report progress via their task\n                 monitor.  The default is false, which triggers this queue to report an \n                 overall progress for each job that is processed.  False is a good default\n                 for clients that have a finite number of jobs to be done.","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a progress listener for this queue.  All the progress and messages reported by a\n QWorker will be routed to these listener.\n@param listener the listener for receiving progress and message notifications.","static":false,"name":"addProgressListener","comment":"Adds a progress listener for this queue.  All the progress and messages reported by a\n QWorker will be routed to these listener.","params":[{"type_long":"generic.concurrent.QProgressListener<I>","name":"listener","comment":"the listener for receiving progress and message notifications.","type_short":"QProgressListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes a progress listener from this queue.  All the progress and messages reported by a\n QWorker will be routed to this listener.\n@param listener the listener for receiving progress and message notifications.","static":false,"name":"removeProgressListener","comment":"Removes a progress listener from this queue.  All the progress and messages reported by a\n QWorker will be routed to this listener.","params":[{"type_long":"generic.concurrent.QProgressListener<I>","name":"listener","comment":"the listener for receiving progress and message notifications.","type_short":"QProgressListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the monitor to use with this queue.\n@param monitor the monitor to attache to this queue\n@param cancelClearsAllItems if true, cancelling the monitor will cancel all items currently\n \t\t\t\t\t\t\t\tbeing processed by a thread and clear the scheduled \n \t\t\t\t\t\t\t\titems that haven't yet run. \n \t\t\t\t\t\t\t\tIf false, only the items currently being processed will be cancelled.","static":false,"name":"setMonitor","comment":"Sets the monitor to use with this queue.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the monitor to attache to this queue","type_short":"TaskMonitor"},{"type_long":"boolean","name":"cancelClearsAllItems","comment":"if true, cancelling the monitor will cancel all items currently\n \t\t\t\t\t\t\t\tbeing processed by a thread and clear the scheduled \n \t\t\t\t\t\t\t\titems that haven't yet run. \n \t\t\t\t\t\t\t\tIf false, only the items currently being processed will be cancelled.","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds the list of items to this queue for concurrent processing.\n@param items the items to be scheduled for concurrent processing","static":false,"name":"add","comment":"Adds the list of items to this queue for concurrent processing.","params":[{"type_long":"java.util.Collection<I>","name":"items","comment":"the items to be scheduled for concurrent processing","type_short":"Collection"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds the items of the given iterator to this queue for concurrent processing.\n@param iterator an iterator from which the items to be scheduled for concurrent processing\n \t      will be taken.","static":false,"name":"add","comment":"Adds the items of the given iterator to this queue for concurrent processing.","params":[{"type_long":"java.util.Iterator<I>","name":"iterator","comment":"an iterator from which the items to be scheduled for concurrent processing\n \t      will be taken.","type_short":"Iterator"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Allows clients to use a bounded queue (such as a {@link LinkedBlockingQueue} to control\n how many items get placed into this queue at one time.  Calling the <tt>add<\/tt> methods\n will place all items into the queue, which for a large number of items, can consume a \n large amount of memory.  This method will block once the queue at maximum capacity, \n continuing to add new items as existing items on the queue are processed.\n <p>\n To enable blocking on the queue when it is full, construct this <tt>ConcurrentQ<\/tt>\n with an instance of {@link BlockingQueue}.\n@param iterator An iterator from which items will be taken.\n@throws InterruptedException if this queue is interrupted while waiting to add more items","static":false,"name":"offer","comment":"Allows clients to use a bounded queue (such as a LinkedBlockingQueue to control\n how many items get placed into this queue at one time.  Calling the add methods\n will place all items into the queue, which for a large number of items, can consume a \n large amount of memory.  This method will block once the queue at maximum capacity, \n continuing to add new items as existing items on the queue are processed.\n \n To enable blocking on the queue when it is full, construct this ConcurrentQ\n with an instance of BlockingQueue.","params":[{"type_long":"java.util.Iterator<I>","name":"iterator","comment":"An iterator from which items will be taken.","type_short":"Iterator"}],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if this queue is interrupted while waiting to add more items","type_short":"InterruptedException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds the item to this queue for concurrent processing.\n@param item the item to be scheduled for concurrent processing.","static":false,"name":"add","comment":"Adds the item to this queue for concurrent processing.","params":[{"type_long":"I","name":"item","comment":"the item to be scheduled for concurrent processing.","type_short":"I"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if this queue has no items waiting to be processed or currently being processed.\n@return true if this queue has no items waiting to be processed or currently being processed.","static":false,"name":"isEmpty","comment":"Returns true if this queue has no items waiting to be processed or currently being processed.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this queue has no items waiting to be processed or currently being processed.","type_short":"boolean"}},{"javadoc":"Waits until all scheduled items have been completed or cancelled and returns a list of \n QResults if this queue has been told to collect results.\n <P>\n You can still call this method to wait for items to be processed, even if you did not\n specify to collect results.  In that case, the list returned will be empty.\n@return the list of QResult objects that have all the results of the completed jobs.\n@throws InterruptedException if this call was interrupted--Note:  this interruption only \n             happens if the calling thread cannot acquire the lock.  If the thread is \n             interrupted while waiting for results, then it will try again.","static":false,"name":"waitForResults","comment":"Waits until all scheduled items have been completed or cancelled and returns a list of \n QResults if this queue has been told to collect results.\n \n You can still call this method to wait for items to be processed, even if you did not\n specify to collect results.  In that case, the list returned will be empty.","params":[],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if this call was interrupted--Note:  this interruption only \n             happens if the calling thread cannot acquire the lock.  If the thread is \n             interrupted while waiting for results, then it will try again.","type_short":"InterruptedException"}],"return":{"type_long":"java.util.Collection<generic.concurrent.QResult<I,R>>","comment":"the list of QResult objects that have all the results of the completed jobs.","type_short":"Collection"}},{"javadoc":"Wait until at least one result is available and then return the first result.\n@return the first available result\n@throws InterruptedException if interrupted while waiting for a result\n@throws {@link IllegalStateException} if this queue has been set to not collect results \n         (see the constructor).","static":false,"name":"waitForNextResult","comment":"Wait until at least one result is available and then return the first result.","params":[],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if interrupted while waiting for a result","type_short":"InterruptedException"}],"return":{"type_long":"generic.concurrent.QResult<I,R>","comment":"the first available result","type_short":"QResult"}},{"javadoc":"Waits until all items have been processed <b>OR<\/b> an Exception happens during the\n processing of <b>ANY item<\/b>.  \n <p>\n <b><u>Note:<\/u><\/b>\n If an exception does occur then the remaining items in the\n queue will be cleared and all current items will be cancelled. \n <p>\n If you wish for processing to continue for remaining items when any item encounters an \n exception, then you should instead use {@link #waitForResults()}.  That method will return\n all results, both with and without exceptions, which you can then process, including \n checking for exceptions.  Note that to use {@link #waitForResults()} to examine exceptions,\n you must have created this queue with <tt>collectResults<\/tt> as true.\n@throws InterruptedException if interrupted while waiting for a result\n@throws Exception any exception encountered while processing an item (this will cancel all\n         items in the queue).","static":false,"name":"waitUntilDone","comment":"Waits until all items have been processed OR an Exception happens during the\n processing of ANY item.  \n \n Note:\n If an exception does occur then the remaining items in the\n queue will be cleared and all current items will be cancelled. \n \n If you wish for processing to continue for remaining items when any item encounters an \n exception, then you should instead use #waitForResults().  That method will return\n all results, both with and without exceptions, which you can then process, including \n checking for exceptions.  Note that to use #waitForResults() to examine exceptions,\n you must have created this queue with collectResults as true.","params":[],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if interrupted while waiting for a result","type_short":"InterruptedException"},{"type_long":"java.lang.Exception","comment":"any exception encountered while processing an item (this will cancel all\n         items in the queue).","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"checkException","comment":"","params":[],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Waits up to the specified time for scheduled jobs to complete.  The results of all completed\n jobs will be returned if this queue has been told to collect results.  At the time that this\n returns, there may still be work to process.  The returned list will contain as much work \n as has been processed when the wait has finished.  Repeated calls to this method will not\n return results from previous waits.\n <P>\n You can still call this method to wait for items to be processed, even if you did not\n specify to collect results.  In that case, the list returned will be empty.\n@return the list of QResult objects that have all the results of the completed jobs.\n@throws InterruptedException if this call was interrupted.","static":false,"name":"waitForResults","comment":"Waits up to the specified time for scheduled jobs to complete.  The results of all completed\n jobs will be returned if this queue has been told to collect results.  At the time that this\n returns, there may still be work to process.  The returned list will contain as much work \n as has been processed when the wait has finished.  Repeated calls to this method will not\n return results from previous waits.\n \n You can still call this method to wait for items to be processed, even if you did not\n specify to collect results.  In that case, the list returned will be empty.","params":[{"type_long":"long","name":"timeout","comment":"","type_short":"long"},{"type_long":"java.util.concurrent.TimeUnit","name":"unit","comment":"","type_short":"TimeUnit"}],"throws":[{"type_long":"java.lang.InterruptedException","comment":"if this call was interrupted.","type_short":"InterruptedException"}],"return":{"type_long":"java.util.Collection<generic.concurrent.QResult<I,R>>","comment":"the list of QResult objects that have all the results of the completed jobs.","type_short":"Collection"}},{"javadoc":"Cancels the processing of currently scheduled items in this queue.  Any items that haven't\n yet been scheduled on the threadPool are returned immediately from this call.  Items that\n are currently being processed will be cancelled and those results will be available on the\n next waitForResults() call and also if there is a QItemListener, it will be called with\n the QResult.  There is no guarantee that scheduled tasks will terminate any time soon.  If \n they check the isCancelled() state of their QMonitor, it will be true.  Setting the \n interruptRunningTasks to true, will result in a thread interrupt to any currently running\n task which might be useful if the task perform waiting operations like I\/O.\n@param interruptRunningTasks if true, an attempt will be made to interrupt any currently \n processing thread.\n@return a list of all items that have not yet been queued to the threadPool.","static":false,"name":"cancelAllTasks","comment":"Cancels the processing of currently scheduled items in this queue.  Any items that haven't\n yet been scheduled on the threadPool are returned immediately from this call.  Items that\n are currently being processed will be cancelled and those results will be available on the\n next waitForResults() call and also if there is a QItemListener, it will be called with\n the QResult.  There is no guarantee that scheduled tasks will terminate any time soon.  If \n they check the isCancelled() state of their QMonitor, it will be true.  Setting the \n interruptRunningTasks to true, will result in a thread interrupt to any currently running\n task which might be useful if the task perform waiting operations like I\/O.","params":[{"type_long":"boolean","name":"interruptRunningTasks","comment":"if true, an attempt will be made to interrupt any currently \n processing thread.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.List<I>","comment":"a list of all items that have not yet been queued to the threadPool.","type_short":"List"}},{"javadoc":"","static":false,"name":"removeUnscheduledJobs","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<I>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"cancelScheduledJobs","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Cancels all running tasks and disposes of the internal thread pool if it is a private \n pool.","static":false,"name":"dispose","comment":"Cancels all running tasks and disposes of the internal thread pool if it is a private \n pool.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"waitUntilDone","comment":"","params":[{"type_long":"long","name":"timeout","comment":"","type_short":"long"},{"type_long":"java.util.concurrent.TimeUnit","name":"unit","comment":"","type_short":"TimeUnit"}],"throws":[{"type_long":"java.lang.InterruptedException","comment":"","type_short":"InterruptedException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"fillOpenProcessingSlots","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"notifyTaskStarted","comment":"","params":[{"type_long":"generic.concurrent.FutureTaskMonitor<I,R>","name":"task","comment":"","type_short":"FutureTaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getInProgressCount","comment":"","params":[],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"itemProcessed","comment":"","params":[{"type_long":"generic.concurrent.FutureTaskMonitor<I,R>","name":"task","comment":"","type_short":"FutureTaskMonitor"},{"type_long":"generic.concurrent.QResult<I,R>","name":"result","comment":"","type_short":"QResult"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"progressChanged","comment":"","params":[{"type_long":"long","name":"id","comment":"","type_short":"long"},{"type_long":"I","name":"item","comment":"","type_short":"I"},{"type_long":"long","name":"currentProgress","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"maxProgressChanged","comment":"","params":[{"type_long":"long","name":"id","comment":"","type_short":"long"},{"type_long":"I","name":"item","comment":"","type_short":"I"},{"type_long":"long","name":"maxProgress","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"progressModeChanged","comment":"","params":[{"type_long":"long","name":"id","comment":"","type_short":"long"},{"type_long":"I","name":"item","comment":"","type_short":"I"},{"type_long":"boolean","name":"indeterminate","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"progressMessageChanged","comment":"","params":[{"type_long":"long","name":"id","comment":"","type_short":"long"},{"type_long":"I","name":"item","comment":"","type_short":"I"},{"type_long":"java.lang.String","name":"message","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"ConcurrentQ","comment":"A queue for easily scheduling tasks to be run in parallel (or sequentially) \n via a thread pool.  This class provides a clean separation of items that need to \n be processed from the algorithm that does the processing, making it easy to parallelize \n the processing of multiple items.   Further, you can control the maximum number of items that\n can be processed concurrently.  This is useful to throttle operations that may starve the\n other threads in the system.  You may also control how many items get placed into the queue\n at one time, blocking if some threshold is exceeded.\n \n Examples:\n \n \n Put and Forget:\n \n QCallbackITEM, RESULT callback = new AbstractQCallbackITEM, RESULT() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n \n ConcurrentQBuilderITEM, RESULT builder = new ConcurrentQBuilderITEM, RESULT();\n builder.setThreadPoolName(\"Thread Pool Name\");\n concurrentQ = builder.getQueue(callback);\n ...\n ...\n concurrentQ.add(item); \/\/ where item is one of the instances of ITEM\n \n \n \n \n Put Items and Handle Results in Any Order as They Available:\n \n QCallbackITEM, RESULT callback = new AbstractQCallbackITEM, RESULT() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n \n QItemListenerITEM, RESULT itemListener = new QItemListenerITEM, RESULT() {\n     public void itemProcessed(QResultITEM, RESULT result) {\n         RESULT result = result.getResult();\n             \/\/ work on my result...\n         }\n };\n \n ConcurrentQBuilderITEM, RESULT builder = new ConcurrentQBuilderITEM, RESULT();\n builder.setThreadPoolName(\"Thread Pool Name\");\n builder.setListener(itemListener);\n concurrentQ = builder.build(callback);\n ...\n ...\n concurrentQ.add(item); \/\/ where item is one of the instances of ITEM\n concurrentQ.add(item);\n concurrentQ.add(item);\n \n \n \n \n \n Put Items and Handle Results When All Items Have Been Processed:\n \n QCallbackITEM, RESULT callback = new AbstractQCallbackITEM, RESULT() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n\n ConcurrentQBuilderITEM, RESULT builder = new ConcurrentQBuilderITEM, RESULT();\n builder.setThreadPoolName(\"Thread Pool Name\");\n builder.setCollectResults(true);\n concurrentQ = builder.getQueue(callback);\n ...\n ...\n concurrentQ.add(item); \/\/ where item is one of the instances of ITEM\n concurrentQ.add(item);\n concurrentQ.add(item);\n ...\n ListQResultI, R results = concurrentQ.waitForResults();\n \/\/ process the results...\n \n \n \n \n Put Items, Blocking While Full, and Handle Results in Any Order as They Available:\n \n QCallbackITEM, RESULT callback = new AbstractQCallbackITEM, RESULT() {\n     public RESULT process(ITEM item, TaskMonitor monitor) {\n         \/\/ do work here...\n     }\n };\n\n QItemListenerITEM, RESULT itemListener = new QItemListenerITEM, RESULT() {\n     public void itemProcessed(QResultITEM, RESULT result) {\n         RESULT result = result.getResult();\n             \/\/ work on my result...\n         }\n };\n \n ConcurrentQBuilderITEM, RESULT builder = new ConcurrentQBuilderITEM, RESULT();\n \tbuilder.setThreadPoolName(\"Thread Pool Name\");\n builder.setQueue(new LinkedBlockingQueue(100));\n concurrentQ = builder.getQueue(callback);\n ...\n ...\n Iterator iterator = get an iterator for 1000s of items somewhere\n concurrentQ.offer(iterator); \/\/ this call will block when the queue fills up (100 items or more)\n \n \n ","fields":[{"type_long":"java.util.Queue<I>","javadoc":"","static":false,"name":"queue","comment":"","type_short":"Queue","constant_value":null},{"type_long":"generic.concurrent.GThreadPool","javadoc":"","static":false,"name":"threadPool","comment":"","type_short":"GThreadPool","constant_value":null},{"type_long":"generic.concurrent.QCallback<I,R>","javadoc":"","static":false,"name":"callback","comment":"","type_short":"QCallback","constant_value":null},{"type_long":"generic.concurrent.QItemListener<I,R>","javadoc":"","static":false,"name":"itemListener","comment":"","type_short":"QItemListener","constant_value":null},{"type_long":"generic.concurrent.QProgressListener<I>","javadoc":"","static":false,"name":"progressListener","comment":"","type_short":"QProgressListener","constant_value":null},{"type_long":"java.util.Deque<generic.concurrent.QResult<I,R>>","javadoc":"","static":false,"name":"resultList","comment":"","type_short":"Deque","constant_value":null},{"type_long":"java.util.Set<generic.concurrent.FutureTaskMonitor<I,R>>","javadoc":"","static":false,"name":"taskSet","comment":"","type_short":"Set","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"maxInProgress","comment":"","type_short":"int","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"collectResults","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"jobsReportProgress","comment":"","type_short":"boolean","constant_value":null},{"type_long":"generic.concurrent.ConcurrentQ<I,R>.QMonitorAdapter","javadoc":"","static":false,"name":"monitorAdapter","comment":"","type_short":"QMonitorAdapter","constant_value":null},{"type_long":"java.lang.Exception","javadoc":"","static":false,"name":"unhandledException","comment":"","type_short":"Exception","constant_value":null},{"type_long":"generic.concurrent.ProgressTracker","javadoc":"","static":false,"name":"tracker","comment":"","type_short":"ProgressTracker","constant_value":null},{"type_long":"java.util.concurrent.locks.ReentrantLock","javadoc":"","static":false,"name":"lock","comment":"","type_short":"ReentrantLock","constant_value":null}]}
