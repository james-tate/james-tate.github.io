{"implements":[],"javadoc":"A decisionTree is used to find property values that are determined by traversing a tree\n of constraints. Each node in the tree has an associated constraint.  If the constraint is\n satisfied for a given test object, then its child nodes are tested to find more and more\n specific results.  When either there are no children in a node or none of the children's \n constraints are satisfied or by traversing those that are satisfied did not result in find\n a property match, the current node is check to see if it has a value for the property being\n search.  If so, that result is added as a Decision.\n \n <P> There can be multiple paths where all constraints a matched resulting in multiple possible\n decisions.<\/P>\n <P> A non-leaf node can have properties as well, that serve as a default if it's constraint\n is satisfied, but not of its children is satisfied or resulted in a decision.<\/P>\n@param <T> the type of object that the constraints are checked against.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Searches the decision tree for values of given property name that match the constraints\n within this tree.\n@param testObject the object that the constraints are test against.\n@param propertyName the name of the property whose values are being collected.\n@return a DecisionSet containing all the values of the given property whose path in the\n tree matched all the constraints for the given test object.","static":false,"name":"getDecisionsSet","comment":"Searches the decision tree for values of given property name that match the constraints\n within this tree.","params":[{"type_long":"T","name":"testObject","comment":"the object that the constraints are test against.","type_short":"T"},{"type_long":"java.lang.String","name":"propertyName","comment":"the name of the property whose values are being collected.","type_short":"String"}],"throws":[],"return":{"type_long":"generic.constraint.DecisionSet","comment":"a DecisionSet containing all the values of the given property whose path in the\n tree matched all the constraints for the given test object.","type_short":"DecisionSet"}},{"javadoc":"Registers a constraint class to be recognized from an xml constraint specification file.\n@param name the name of the constraint which is also the xml tag value.\n@param constraintClass the constraint type which will be initialized from the xml constraint\n specification file.","static":false,"name":"registerConstraintType","comment":"Registers a constraint class to be recognized from an xml constraint specification file.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the constraint which is also the xml tag value.","type_short":"String"},{"type_long":"java.lang.Class<? extends generic.constraint.Constraint<T>>","name":"constraintClass","comment":"the constraint type which will be initialized from the xml constraint\n specification file.","type_short":"Class"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Registers a property name.  Every tag in an xml constraint file (except the root tag which\n is unused) must be either a constraint name or a property name.\n@param propertyName the name of a valid property to be expected in an xml constraints file.","static":false,"name":"registerPropertyName","comment":"Registers a property name.  Every tag in an xml constraint file (except the root tag which\n is unused) must be either a constraint name or a property name.","params":[{"type_long":"java.lang.String","name":"propertyName","comment":"the name of a valid property to be expected in an xml constraints file.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Loads the tree from an xml data contained within an input stream. Note: this method can be\n called multiple times, with each call appending to the existing tree.\n@param name the name of the input source so that decisions can be traced back to \n the appropriate xml constraints source.\n@param stream the InputStream from which to read an xml constraints specification.\n@throws IOException if an I\/O problem occurs reading from the stream.\n@throws XmlParseException if the XML is not property formatted or a tag that is not\n a constraint name or property name is encountered.","static":false,"name":"loadConstraints","comment":"Loads the tree from an xml data contained within an input stream. Note: this method can be\n called multiple times, with each call appending to the existing tree.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the input source so that decisions can be traced back to \n the appropriate xml constraints source.","type_short":"String"},{"type_long":"java.io.InputStream","name":"stream","comment":"the InputStream from which to read an xml constraints specification.","type_short":"InputStream"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O problem occurs reading from the stream.","type_short":"IOException"},{"type_long":"ghidra.xml.XmlParseException","comment":"if the XML is not property formatted or a tag that is not\n a constraint name or property name is encountered.","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Loads the tree from an xml constraint file. Note: this method can be called multiple times,\n with each call appending to the existing tree.\n@param file the file that contains the xml for the constraint.\n@throws IOException if an I\/O problem occurs reading from the stream.\n@throws XmlParseException if the XML is not property formatted or a tag that is not\n a constraint name or property name is encountered.","static":false,"name":"loadConstraints","comment":"Loads the tree from an xml constraint file. Note: this method can be called multiple times,\n with each call appending to the existing tree.","params":[{"type_long":"generic.jar.ResourceFile","name":"file","comment":"the file that contains the xml for the constraint.","type_short":"ResourceFile"}],"throws":[{"type_long":"java.io.FileNotFoundException","comment":"","type_short":"FileNotFoundException"},{"type_long":"java.io.IOException","comment":"if an I\/O problem occurs reading from the stream.","type_short":"IOException"},{"type_long":"ghidra.xml.XmlParseException","comment":"if the XML is not property formatted or a tag that is not\n a constraint name or property name is encountered.","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"processSubContraintsAndProperties","comment":"","params":[{"type_long":"generic.constraint.DecisionNode<T>","name":"parent","comment":"","type_short":"DecisionNode"},{"type_long":"ghidra.xml.XmlPullParser","name":"parser","comment":"","type_short":"XmlPullParser"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getConstraint","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"generic.constraint.Constraint<T>","comment":"","type_short":"Constraint"}},{"javadoc":"","static":false,"name":"processPropertyElement","comment":"","params":[{"type_long":"generic.constraint.DecisionNode<T>","name":"node","comment":"","type_short":"DecisionNode"},{"type_long":"ghidra.xml.XmlElement","name":"element","comment":"","type_short":"XmlElement"},{"type_long":"ghidra.xml.XmlPullParser","name":"parser","comment":"","type_short":"XmlPullParser"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"readConstraint","comment":"","params":[{"type_long":"ghidra.xml.XmlElement","name":"element","comment":"","type_short":"XmlElement"}],"throws":[{"type_long":"ghidra.xml.XmlParseException","comment":"","type_short":"XmlParseException"}],"return":{"type_long":"generic.constraint.Constraint<T>","comment":"","type_short":"Constraint"}}],"name":"DecisionTree","comment":"A decisionTree is used to find property values that are determined by traversing a tree\n of constraints. Each node in the tree has an associated constraint.  If the constraint is\n satisfied for a given test object, then its child nodes are tested to find more and more\n specific results.  When either there are no children in a node or none of the children's \n constraints are satisfied or by traversing those that are satisfied did not result in find\n a property match, the current node is check to see if it has a value for the property being\n search.  If so, that result is added as a Decision.\n \n  There can be multiple paths where all constraints a matched resulting in multiple possible\n decisions.\n  A non-leaf node can have properties as well, that serve as a default if it's constraint\n is satisfied, but not of its children is satisfied or resulted in a decision.","fields":[{"type_long":"generic.constraint.DecisionNode<T>","javadoc":"","static":false,"name":"root","comment":"","type_short":"DecisionNode","constant_value":null},{"type_long":"java.util.Map<java.lang.String,java.lang.Class<? extends generic.constraint.Constraint<T>>>","javadoc":"","static":false,"name":"constraintClassMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Set<java.lang.String>","javadoc":"","static":false,"name":"propertyNameSet","comment":"","type_short":"Set","constant_value":null}]}
