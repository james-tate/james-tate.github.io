{"implements":[],"javadoc":"<code>FixedRecNode<\/code> is an implementation of a BTree leaf node\n which utilizes long key values and stores fixed-length records.\n <p>\n This type of node has the following layout within a single DataBuffer \n (field size in bytes):\n <pre>\n   | NodeType(1) | KeyCount(4) | PrevLeafId(4) | NextLeafId(4) | Key0(8) | Rec0 | ...\n \n   | KeyN(8) | RecN |\n <\/pre>","static":false,"extends":"db.LongKeyRecordNode","methods":[{"javadoc":"Construct an existing long-key fixed-length record leaf node.\n@param nodeMgr table node manager instance\n@param buf node buffer","static":false,"name":"<init>","comment":"Construct an existing long-key fixed-length record leaf node.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager instance","type_short":"NodeMgr"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"node buffer","type_short":"DataBuffer"},{"type_long":"int","name":"recordLength","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new long-key fixed-length record leaf node.\n@param nodeMgr table node manager instance\n@param recordLength fixed record length\n@param prevLeafId node buffer id for previous leaf ( &lt; 0: no leaf)\n@param nextLeafId node buffer id for next leaf ( &lt; 0 : no leaf)\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new long-key fixed-length record leaf node.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager instance","type_short":"NodeMgr"},{"type_long":"int","name":"recordLength","comment":"fixed record length","type_short":"int"},{"type_long":"int","name":"prevLeafId","comment":"node buffer id for previous leaf (  0: no leaf)","type_short":"int"},{"type_long":"int","name":"nextLeafId","comment":"node buffer id for next leaf (  0 : no leaf)","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"createNewLeaf","comment":"","params":[{"type_long":"int","name":"prevLeafId","comment":"","type_short":"int"},{"type_long":"int","name":"nextLeafId","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.LongKeyRecordNode","comment":"","type_short":"LongKeyRecordNode"}},{"javadoc":"","static":false,"name":"getKey","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Get the record offset within the buffer\n@param index key index\n@return record offset","static":false,"name":"getRecordOffset","comment":"Get the record offset within the buffer","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"record offset","type_short":"int"}},{"javadoc":"Shift all records by one starting with index to the end.\n@param index the smaller key index (0 &lt;= index1)\n@param rightShift shift right by one record if true, else shift left by\n one record.","static":false,"name":"shiftRecords","comment":"Shift all records by one starting with index to the end.","params":[{"type_long":"int","name":"index","comment":"the smaller key index (0 = index1)","type_short":"int"},{"type_long":"boolean","name":"rightShift","comment":"shift right by one record if true, else shift left by\n one record.","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"remove","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"insertRecord","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"},{"type_long":"db.Record","name":"record","comment":"","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"updateRecord","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"},{"type_long":"db.Record","name":"record","comment":"","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.LongKeyNode","comment":"","type_short":"LongKeyNode"}},{"javadoc":"","static":false,"name":"getRecord","comment":"","params":[{"type_long":"long","name":"key","comment":"","type_short":"long"},{"type_long":"db.Schema","name":"schema","comment":"","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"","type_short":"Record"}},{"javadoc":"","static":false,"name":"getRecord","comment":"","params":[{"type_long":"db.Schema","name":"schema","comment":"","type_short":"Schema"},{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"","type_short":"Record"}},{"javadoc":"","static":false,"name":"splitData","comment":"","params":[{"type_long":"db.LongKeyRecordNode","name":"newRightLeaf","comment":"","type_short":"LongKeyRecordNode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"delete","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getBufferReferences","comment":"","params":[],"throws":[],"return":{"type_long":"int[]","comment":"","type_short":"int[]"}}],"name":"FixedRecNode","comment":"FixedRecNode is an implementation of a BTree leaf node\n which utilizes long key values and stores fixed-length records.\n \n This type of node has the following layout within a single DataBuffer \n (field size in bytes):\n \n   | NodeType(1) | KeyCount(4) | PrevLeafId(4) | NextLeafId(4) | Key0(8) | Rec0 | ...\n \n   | KeyN(8) | RecN |\n ","fields":[{"type_long":"int","javadoc":"","static":true,"name":"HEADER_SIZE","comment":"","type_short":"int","constant_value":"13"},{"type_long":"int","javadoc":"","static":true,"name":"ENTRY_BASE_OFFSET","comment":"","type_short":"int","constant_value":"13"},{"type_long":"int","javadoc":"","static":true,"name":"KEY_SIZE","comment":"","type_short":"int","constant_value":"8"},{"type_long":"int[]","javadoc":"","static":true,"name":"EMPTY_ID_LIST","comment":"","type_short":"int[]","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"entrySize","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"recordLength","comment":"","type_short":"int","constant_value":null}]}
