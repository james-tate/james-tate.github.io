{"implements":[],"javadoc":"<code>VarRecNode<\/code> is an implementation of a BTree leaf node\n which utilizes long key values and stores variable-length records.\n <p>\n This type of node has the following layout within a single DataBuffer \n (field size in bytes):\n <pre>\n   | NodeType(1) | KeyCount(4) | PrevLeafId(4) | NextLeafId(4) | Key0(8) | RecOffset0(4) | IndFlag0(1) |...  \n     \n   | KeyN(8) | RecOffsetN(4) | IndFlagN(1) |...<FreeSpace>... | RecN |... | Rec1 |\n <\/pre>\n IndFlag - if not zero the record has been stored within a chained DBBuffer \n whose 4-byte integer buffer ID has been stored within this leaf at the record offset.","static":false,"extends":"db.LongKeyRecordNode","methods":[{"javadoc":"Construct an existing long-key variable-length record leaf node.\n@param nodeMgr table node manager instance\n@param buf node buffer","static":false,"name":"<init>","comment":"Construct an existing long-key variable-length record leaf node.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager instance","type_short":"NodeMgr"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"node buffer","type_short":"DataBuffer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new long-key variable-length record leaf node.\n@param nodeMgr table node manager instance\n@param prevLeafId node buffer id for previous leaf ( &lt; 0: no leaf)\n@param nextLeafId node buffer id for next leaf ( &lt; 0 : no leaf)\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new long-key variable-length record leaf node.","params":[{"type_long":"db.NodeMgr","name":"nodeMgr","comment":"table node manager instance","type_short":"NodeMgr"},{"type_long":"int","name":"prevLeafId","comment":"node buffer id for previous leaf (  0: no leaf)","type_short":"int"},{"type_long":"int","name":"nextLeafId","comment":"node buffer id for next leaf (  0 : no leaf)","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"createNewLeaf","comment":"","params":[{"type_long":"int","name":"prevLeafId","comment":"","type_short":"int"},{"type_long":"int","name":"nextLeafId","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.LongKeyRecordNode","comment":"","type_short":"LongKeyRecordNode"}},{"javadoc":"","static":false,"name":"getKey","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Get the record offset within the buffer\n@param index key index\n@return record offset","static":false,"name":"getRecordOffset","comment":"Get the record offset within the buffer","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"record offset","type_short":"int"}},{"javadoc":"Store the record offset within the buffer for the specified key index\n@param index key index\n@param offset record offset","static":false,"name":"putRecordOffset","comment":"Store the record offset within the buffer for the specified key index","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"},{"type_long":"int","name":"offset","comment":"record offset","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determine if a record is utilizing a chained DBBuffer for data storage\n@param index key index\n@return true if indirect storage is used for record, else false","static":false,"name":"hasIndirectStorage","comment":"Determine if a record is utilizing a chained DBBuffer for data storage","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"true if indirect storage is used for record, else false","type_short":"boolean"}},{"javadoc":"Set the indirect storage flag associated with a record\n@param index key index\n@param state indirect storage used (true) or not used (false)","static":false,"name":"enableIndirectStorage","comment":"Set the indirect storage flag associated with a record","params":[{"type_long":"int","name":"index","comment":"key index","type_short":"int"},{"type_long":"boolean","name":"state","comment":"indirect storage used (true) or not used (false)","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return unused free space within node","static":false,"name":"getFreeSpace","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"unused free space within node","type_short":"int"}},{"javadoc":"Get the length of a stored record.\n@param keyIndex key index associated with record.","static":false,"name":"getRecordLength","comment":"Get the length of a stored record.","params":[{"type_long":"int","name":"keyIndex","comment":"key index associated with record.","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get the length of a stored record.  Optimized if record offset \n already known.\n@param keyIndex key index associated with record.\n@param offset record offset","static":false,"name":"getRecordLength","comment":"Get the length of a stored record.  Optimized if record offset \n already known.","params":[{"type_long":"int","name":"keyIndex","comment":"key index associated with record.","type_short":"int"},{"type_long":"int","name":"offset","comment":"record offset","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Move all record data, starting with index, by the specified offset amount.\n If the node contains 5 records, an index of 3 would shift the record data\n for indexes 3 and 4 left by the spacified offset amount.  This is used to \n make space for a new or updated record.\n@param index the smaller key index (0 &lt;= index1)\n@param offset movement offset in bytes\n@return insertion offset immediately following moved block.","static":false,"name":"moveRecords","comment":"Move all record data, starting with index, by the specified offset amount.\n If the node contains 5 records, an index of 3 would shift the record data\n for indexes 3 and 4 left by the spacified offset amount.  This is used to \n make space for a new or updated record.","params":[{"type_long":"int","name":"index","comment":"the smaller key index (0 = index1)","type_short":"int"},{"type_long":"int","name":"offset","comment":"movement offset in bytes","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"insertion offset immediately following moved block.","type_short":"int"}},{"javadoc":"","static":false,"name":"getRecord","comment":"","params":[{"type_long":"db.Schema","name":"schema","comment":"","type_short":"Schema"},{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"","type_short":"Record"}},{"javadoc":"","static":false,"name":"getRecord","comment":"","params":[{"type_long":"long","name":"key","comment":"","type_short":"long"},{"type_long":"db.Schema","name":"schema","comment":"","type_short":"Schema"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.Record","comment":"","type_short":"Record"}},{"javadoc":"Find the index which represents the halfway point within the record data.\n@returns key index.","static":false,"name":"getSplitIndex","comment":"Find the index which represents the halfway point within the record data.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"splitData","comment":"","params":[{"type_long":"db.LongKeyRecordNode","name":"newRightLeaf","comment":"","type_short":"LongKeyRecordNode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"updateRecord","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"},{"type_long":"db.Record","name":"record","comment":"","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.LongKeyNode","comment":"","type_short":"LongKeyNode"}},{"javadoc":"Insert the specified record at the specified key index.\n Existing data may be shifted within the buffer to make room for\n the new record.  Parent must be notified if this changes the leftmost\n key.\n@param keyIndex\n@param record\n@throws IOException","static":false,"name":"insertRecord","comment":"Insert the specified record at the specified key index.\n Existing data may be shifted within the buffer to make room for\n the new record.  Parent must be notified if this changes the leftmost\n key.","params":[{"type_long":"int","name":"keyIndex","comment":"","type_short":"int"},{"type_long":"db.Record","name":"record","comment":"","type_short":"Record"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"remove","comment":"","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes this leaf and all associated chained buffers.\n@see db.LongKeyRecordNode#removeLeaf()","static":false,"name":"removeLeaf","comment":"Removes this leaf and all associated chained buffers.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.LongKeyNode","comment":"","type_short":"LongKeyNode"}},{"javadoc":"Remove a chained buffer.\n@param bufferId chained buffer ID","static":false,"name":"removeChainedBuffer","comment":"Remove a chained buffer.","params":[{"type_long":"int","name":"bufferId","comment":"chained buffer ID","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"delete","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getBufferReferences","comment":"","params":[],"throws":[],"return":{"type_long":"int[]","comment":"","type_short":"int[]"}}],"name":"VarRecNode","comment":"VarRecNode is an implementation of a BTree leaf node\n which utilizes long key values and stores variable-length records.\n \n This type of node has the following layout within a single DataBuffer \n (field size in bytes):\n \n   | NodeType(1) | KeyCount(4) | PrevLeafId(4) | NextLeafId(4) | Key0(8) | RecOffset0(4) | IndFlag0(1) |...  \n     \n   | KeyN(8) | RecOffsetN(4) | IndFlagN(1) |...... | RecN |... | Rec1 |\n \n IndFlag - if not zero the record has been stored within a chained DBBuffer \n whose 4-byte integer buffer ID has been stored within this leaf at the record offset.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"HEADER_SIZE","comment":"","type_short":"int","constant_value":"13"},{"type_long":"int","javadoc":"","static":true,"name":"KEY_SIZE","comment":"","type_short":"int","constant_value":"8"},{"type_long":"int","javadoc":"","static":true,"name":"OFFSET_SIZE","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"INDIRECT_OPTION_SIZE","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"ENTRY_SIZE","comment":"","type_short":"int","constant_value":"13"},{"type_long":"int","javadoc":"","static":true,"name":"KEY_BASE_OFFSET","comment":"","type_short":"int","constant_value":"13"},{"type_long":"int","javadoc":"","static":true,"name":"DATA_OFFSET_BASE_OFFSET","comment":"","type_short":"int","constant_value":"21"},{"type_long":"int","javadoc":"","static":true,"name":"IND_OPTION_BASE_OFFSET","comment":"","type_short":"int","constant_value":"25"}]}
