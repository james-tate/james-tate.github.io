{"implements":[],"javadoc":"<code>BufferMgr<\/code> provides low-level buffer management and caching.\n Checkpointing and buffer versioning is supported along with an undo\/redo\n capability.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a new buffer manager with no underlying source file using the\n default buffer size, cache size and maximum undo count.\n@throws IOException if a cache file access error occurs","static":false,"name":"<init>","comment":"Construct a new buffer manager with no underlying source file using the\n default buffer size, cache size and maximum undo count.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if a cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new buffer manager with no underlying source file.\n@param requestedBufferSize requested buffer size.  Actual buffer size may\n vary.\n@param approxCacheSize approximate size of cache in Bytes.\n@param maxUndos maximum number of checkpoints retained for undo (Minimum=1).\n@throws IOException if a cache file access error occurs","static":false,"name":"<init>","comment":"Construct a new buffer manager with no underlying source file.","params":[{"type_long":"int","name":"requestedBufferSize","comment":"requested buffer size.  Actual buffer size may\n vary.","type_short":"int"},{"type_long":"long","name":"approxCacheSize","comment":"approximate size of cache in Bytes.","type_short":"long"},{"type_long":"int","name":"maxUndos","comment":"maximum number of checkpoints retained for undo (Minimum=1).","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if a cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a buffer manager for a given source file using default\n cache size and maximum undo count.\n@param sourceFile buffer file\n@throws IOException if source or cache file access error occurs","static":false,"name":"<init>","comment":"Construct a buffer manager for a given source file using default\n cache size and maximum undo count.","params":[{"type_long":"db.buffers.BufferFile","name":"sourceFile","comment":"buffer file","type_short":"BufferFile"}],"throws":[{"type_long":"java.io.FileNotFoundException","comment":"","type_short":"FileNotFoundException"},{"type_long":"java.io.IOException","comment":"if source or cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a buffer manager for a given source file using default\n cache size and maximum undo count.\n@param sourceFile buffer file\n@param approxCacheSize approximate size of cache in Bytes.\n@param maxUndos maximum number of checkpoints retained for undo (Minimum=1).\n@throws IOException if source or cache file access error occurs","static":false,"name":"<init>","comment":"Construct a buffer manager for a given source file using default\n cache size and maximum undo count.","params":[{"type_long":"db.buffers.BufferFile","name":"sourceFile","comment":"buffer file","type_short":"BufferFile"},{"type_long":"long","name":"approxCacheSize","comment":"approximate size of cache in Bytes.","type_short":"long"},{"type_long":"int","name":"maxUndos","comment":"maximum number of checkpoints retained for undo (Minimum=1).","type_short":"int"}],"throws":[{"type_long":"java.io.FileNotFoundException","comment":"","type_short":"FileNotFoundException"},{"type_long":"java.io.IOException","comment":"if source or cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a buffer manager for a given source file.\n@param sourceFile buffer source file\n@param requestedBufferSize requested buffer size.  Actual buffer size may\n vary (ignored if source is not null).\n@param approxCacheSize approximate size of cache in Bytes.\n@param maxUndos maximum number of checkpoints retained for undo (Minimum=1).\n@throws IOException if source or cache file access error occurs","static":false,"name":"<init>","comment":"Construct a buffer manager for a given source file.","params":[{"type_long":"db.buffers.BufferFile","name":"sourceFile","comment":"buffer source file","type_short":"BufferFile"},{"type_long":"int","name":"requestedbufferSize","comment":"","type_short":"int"},{"type_long":"long","name":"approxCacheSize","comment":"approximate size of cache in Bytes.","type_short":"long"},{"type_long":"int","name":"maxUndos","comment":"maximum number of checkpoints retained for undo (Minimum=1).","type_short":"int"}],"throws":[{"type_long":"java.io.FileNotFoundException","comment":"","type_short":"FileNotFoundException"},{"type_long":"java.io.IOException","comment":"if source or cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Enable and start source buffer file pre-cache if appropriate.\n This may be forced for all use cases by setting the System property \n db.always.precache=true\n WARNING! EXPERIMENTAL !!!","static":false,"name":"enablePreCache","comment":"Enable and start source buffer file pre-cache if appropriate.\n This may be forced for all use cases by setting the System property \n db.always.precache=true\n WARNING! EXPERIMENTAL !!!","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add new BufferMgr instance and ensure that all non-disposed\n BufferMgr instances are properly disposed when the VM shuts-down.\n@param bufMgr new instance","static":true,"name":"addInstance","comment":"Add new BufferMgr instance and ensure that all non-disposed\n BufferMgr instances are properly disposed when the VM shuts-down.","params":[{"type_long":"db.buffers.BufferMgr","name":"bufMgr","comment":"new instance","type_short":"BufferMgr"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the corrupt state flag for this buffer manager.  This will cause any snapshot\n attempt to fail and cause most public access methods to throw an IOException.\n The caller should log this action and the reason for it.","static":false,"name":"setCorruptedState","comment":"Set the corrupt state flag for this buffer manager.  This will cause any snapshot\n attempt to fail and cause most public access methods to throw an IOException.\n The caller should log this action and the reason for it.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determine if BufferMgr has become corrupted (IOException has occurred).\n@return true if this BufferMgr is corrupt.","static":false,"name":"isCorrupted","comment":"Determine if BufferMgr has become corrupted (IOException has occurred).","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this BufferMgr is corrupt.","type_short":"boolean"}},{"javadoc":"Remove a BufferMgr instance after it has been disposed.\n@param bufMgr disposed instance","static":true,"name":"removeInstance","comment":"Remove a BufferMgr instance after it has been disposed.","params":[{"type_long":"db.buffers.BufferMgr","name":"bufMgr","comment":"disposed instance","type_short":"BufferMgr"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the current number of locked buffers.\n@return int","static":false,"name":"getLockCount","comment":"Get the current number of locked buffers.","params":[],"throws":[],"return":{"type_long":"int","comment":"int","type_short":"int"}},{"javadoc":"@return the size of each buffer in bytes.","static":false,"name":"getBufferSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of each buffer in bytes.","type_short":"int"}},{"javadoc":"@return returns the source file","static":false,"name":"getSourceFile","comment":"","params":[],"throws":[],"return":{"type_long":"db.buffers.BufferFile","comment":"returns the source file","type_short":"BufferFile"}},{"javadoc":"Dispose of buffer manager when finalized.","static":false,"name":"finalize","comment":"Dispose of buffer manager when finalized.","params":[],"throws":[{"type_long":"java.lang.Throwable","comment":"","type_short":"Throwable"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get file parameter","static":false,"name":"getParameter","comment":"Get file parameter","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[{"type_long":"java.util.NoSuchElementException","comment":"","type_short":"NoSuchElementException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Set file parameter\n@param name\n@param value","static":false,"name":"setParameter","comment":"Set file parameter","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"int","name":"value","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dispose of all buffer manager resources including any source\n buffer file.  Any existing recovery data will be discarded.\n This method should be called when this buffer manager instance\n is no longer needed.","static":false,"name":"dispose","comment":"Dispose of all buffer manager resources including any source\n buffer file.  Any existing recovery data will be discarded.\n This method should be called when this buffer manager instance\n is no longer needed.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dispose of all buffer manager resources including any source\n buffer file.\n This method should be called when this buffer manager instance\n is no longer needed.\n@param keepRecoveryData","static":false,"name":"dispose","comment":"Dispose of all buffer manager resources including any source\n buffer file.\n This method should be called when this buffer manager instance\n is no longer needed.","params":[{"type_long":"boolean","name":"keepRecoveryData","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"If maximum number of checkpoints is exceeded, pack oldest\n checkpoint into baseline.","static":false,"name":"packCheckpoints","comment":"If maximum number of checkpoints is exceeded, pack oldest\n checkpoint into baseline.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dispose a checkpoint buffer node.\n Node is removed from all applicable lists and the disk\n cache index added to free index list.\n@param node buffer node to dispose","static":false,"name":"disposeNode","comment":"Dispose a checkpoint buffer node.\n Node is removed from all applicable lists and the disk\n cache index added to free index list.","params":[{"type_long":"db.buffers.BufferNode","name":"node","comment":"buffer node to dispose","type_short":"BufferNode"},{"type_long":"boolean","name":"isVersioned","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dispose all nodes in list.\n@param head list head","static":false,"name":"disposeNodeList","comment":"Dispose all nodes in list.","params":[{"type_long":"db.buffers.BufferNode","name":"head","comment":"list head","type_short":"BufferNode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Dispose all redo checkpoint lists.","static":false,"name":"disposeRedoCheckpoints","comment":"Dispose all redo checkpoint lists.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the maximum number of undoable checkpoints maintained by buffer manager.\n Existing redo checkpoints are cleared and the stack of undo checkpoints\n will be reduced if maxUndos is less than the current setting.\n@param maxUndos maximum number of undo checkpoints.  A negative\n value restores the default value.","static":false,"name":"setMaxUndos","comment":"Set the maximum number of undoable checkpoints maintained by buffer manager.\n Existing redo checkpoints are cleared and the stack of undo checkpoints\n will be reduced if maxUndos is less than the current setting.","params":[{"type_long":"int","name":"maxUndos","comment":"maximum number of undo checkpoints.  A negative\n value restores the default value.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clear all checkpoints and re-baseline buffers","static":false,"name":"clearCheckpoints","comment":"Clear all checkpoints and re-baseline buffers","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the maximum number of checkpoints retained.\n@return int","static":false,"name":"getMaxUndos","comment":"Get the maximum number of checkpoints retained.","params":[],"throws":[],"return":{"type_long":"int","comment":"int","type_short":"int"}},{"javadoc":"Get a reusable buffer object from cache.\n The oldest buffer node is removed from memory cache.\n@return buffer object.\n@throws IOException if a cache file access error occurs","static":false,"name":"getCacheBuffer","comment":"Get a reusable buffer object from cache.\n The oldest buffer node is removed from memory cache.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if a cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"buffer object.","type_short":"DataBuffer"}},{"javadoc":"Remove a buffer node from memory cache.\n@param node buffer node\n@return buffer object, or null if buffer node was not cached","static":false,"name":"removeFromCache","comment":"Remove a buffer node from memory cache.","params":[{"type_long":"db.buffers.BufferNode","name":"node","comment":"buffer node","type_short":"BufferNode"}],"throws":[],"return":{"type_long":"void","comment":"buffer object, or null if buffer node was not cached","type_short":"void"}},{"javadoc":"Return the specified node to cache with the associated buffer object.\n@param node node to be cached\n@param buf buffer object","static":false,"name":"returnToCache","comment":"Return the specified node to cache with the associated buffer object.","params":[{"type_long":"db.buffers.BufferNode","name":"node","comment":"node to be cached","type_short":"BufferNode"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"buffer object","type_short":"DataBuffer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return a reusable buffer to the cache.\n@param buf buffer to be returned.","static":false,"name":"returnFreeBuffer","comment":"Return a reusable buffer to the cache.","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"buffer to be returned.","type_short":"DataBuffer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Stop the pre-cache thread if currently active","static":false,"name":"stopPreCache","comment":"Stop the pre-cache thread if currently active","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Start pre-cache of source file if appropriate.\n This targets remote buffer file adapters only.","static":false,"name":"startPreCacheIfNeeded","comment":"Start pre-cache of source file if appropriate.\n This targets remote buffer file adapters only.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Pre-cache source file into cache file.  This is intended to be run in a \n dedicated thread when the source file is remote.","static":false,"name":"preCacheSourceFile","comment":"Pre-cache source file into cache file.  This is intended to be run in a \n dedicated thread when the source file is remote.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Pre-cache an non-requested buffer from the sourceFile\n@param buf source file data buffer\n@throws IOException if cache file access error occurs\n@return true if block added to cache, false if already cached","static":false,"name":"preCacheBuffer","comment":"Pre-cache an non-requested buffer from the sourceFile","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"source file data buffer","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"if cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if block added to cache, false if already cached","type_short":"boolean"}},{"javadoc":"Get the buffer node at the current checkpoint level.\n Creates node from source if necessary.\n@param id buffer id.\n@param load if true, buffer will be loaded into memory cache.\n@return buffer node or null if node not found\n@throws IOException if source or cache file access error occurs","static":false,"name":"getBufferNode","comment":"Get the buffer node at the current checkpoint level.\n Creates node from source if necessary.","params":[{"type_long":"int","name":"id","comment":"buffer id.","type_short":"int"},{"type_long":"boolean","name":"load","comment":"if true, buffer will be loaded into memory cache.","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"if source or cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"db.buffers.BufferNode","comment":"buffer node or null if node not found","type_short":"BufferNode"}},{"javadoc":"Create a new buffer node associated with the specified checkpoint list.\n If versionHead is null, a new buffer table entry and version list will be created.\n@param id buffer id\n@param checkpointHead head of checkpoint list\n@param versionHead head of buffer version list, may be null\n@return new buffer node","static":false,"name":"createNewBufferNode","comment":"Create a new buffer node associated with the specified checkpoint list.\n If versionHead is null, a new buffer table entry and version list will be created.","params":[{"type_long":"int","name":"id","comment":"buffer id","type_short":"int"},{"type_long":"db.buffers.BufferNode","name":"checkpointHead","comment":"head of checkpoint list","type_short":"BufferNode"},{"type_long":"db.buffers.BufferNode","name":"versionHead","comment":"head of buffer version list, may be null","type_short":"BufferNode"}],"throws":[],"return":{"type_long":"db.buffers.BufferNode","comment":"new buffer node","type_short":"BufferNode"}},{"javadoc":"Create a new buffer version list and add the specified node.\n@param id buffer id\n@param node the first buffer version to add into list\n@return buffer version head.","static":false,"name":"createNewBufferList","comment":"Create a new buffer version list and add the specified node.","params":[{"type_long":"int","name":"id","comment":"buffer id","type_short":"int"},{"type_long":"db.buffers.BufferNode","name":"node","comment":"the first buffer version to add into list","type_short":"BufferNode"}],"throws":[],"return":{"type_long":"db.buffers.BufferNode","comment":"buffer version head.","type_short":"BufferNode"}},{"javadoc":"Get the buffer node at the current checkpoint level.\n@param id buffer id.\n@return buffer node or null if node not found","static":false,"name":"getCachedBufferNode","comment":"Get the buffer node at the current checkpoint level.","params":[{"type_long":"int","name":"id","comment":"buffer id.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.BufferNode","comment":"buffer node or null if node not found","type_short":"BufferNode"}},{"javadoc":"Load buffer from disk cache into memory cache.\n@param node buffer node to be unloaded from memory cache.\n@throws IOException if a cache file access error occurs","static":false,"name":"loadCachedNode","comment":"Load buffer from disk cache into memory cache.","params":[{"type_long":"db.buffers.BufferNode","name":"node","comment":"buffer node to be unloaded from memory cache.","type_short":"BufferNode"}],"throws":[{"type_long":"java.io.IOException","comment":"if a cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Unload buffer from memory cache to disk cache if needed.\n@param node buffer node to be unloaded from memory cache.\n@throws IOException if a cache file access error occurs","static":false,"name":"unloadCachedNode","comment":"Unload buffer from memory cache to disk cache if needed.","params":[{"type_long":"db.buffers.BufferNode","name":"node","comment":"buffer node to be unloaded from memory cache.","type_short":"BufferNode"}],"throws":[{"type_long":"java.io.IOException","comment":"if a cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the specified buffer.\n When done working with the buffer, the method releaseBuffer\n must be used to return it to the buffer manager.  Buffers\n should not be held for long periods.\n@param id buffer id\n@return buffer object, or null if buffer not found\n@throws IOException if source or cache file access error occurs","static":false,"name":"getBuffer","comment":"Get the specified buffer.\n When done working with the buffer, the method releaseBuffer\n must be used to return it to the buffer manager.  Buffers\n should not be held for long periods.","params":[{"type_long":"int","name":"id","comment":"buffer id","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if source or cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"buffer object, or null if buffer not found","type_short":"DataBuffer"}},{"javadoc":"Get a new or recycled buffer.\n New buffer is always returned with update enabled.\n When done working with the buffer, the method releaseBuffer\n must be used to return it to the buffer manager.  Buffers\n should not be held for long periods.\n@return buffer object, or null if buffer not found\n@throws IOException if a cache file access error occurs","static":false,"name":"createBuffer","comment":"Get a new or recycled buffer.\n New buffer is always returned with update enabled.\n When done working with the buffer, the method releaseBuffer\n must be used to return it to the buffer manager.  Buffers\n should not be held for long periods.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if a cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"buffer object, or null if buffer not found","type_short":"DataBuffer"}},{"javadoc":"Return buffer.\n After invoking this method, the buffer object should not\n be used and all references should be dropped.","static":false,"name":"releaseBuffer","comment":"Return buffer.\n After invoking this method, the buffer object should not\n be used and all references should be dropped.","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Handle exception which indicates a potential corruption of the BufferMgr state\n@param exception\n@param errorText\n@throws IOException","static":false,"name":"handleCorruptionException","comment":"Handle exception which indicates a potential corruption of the BufferMgr state","params":[{"type_long":"java.lang.Exception","name":"exception","comment":"","type_short":"Exception"},{"type_long":"java.lang.String","name":"errorText","comment":"","type_short":"String"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"releaseCleanBuffer","comment":"","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"releaseDirtyBuffer","comment":"","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"java.lang.AssertionError","comment":"","type_short":"AssertionError"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Delete buffer.\n DataBuffer is added to the free list for reuse.\n@param id buffer id\n@throws IOException if source or cache file access error occurs","static":false,"name":"deleteBuffer","comment":"Delete buffer.\n DataBuffer is added to the free list for reuse.","params":[{"type_long":"int","name":"id","comment":"buffer id","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if source or cache file access error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return true if no buffers have been updated since last checkpoint.","static":false,"name":"atCheckpoint","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if no buffers have been updated since last checkpoint.","type_short":"boolean"}},{"javadoc":"Completes a transaction by closing the current checkpoint.  All\n modified buffers since the previous invocation of this method\n will be contained within \"transaction\".\n The redo stack will be cleared.\n@return true if checkpoint successful, or false if buffers are read-only","static":false,"name":"checkpoint","comment":"Completes a transaction by closing the current checkpoint.  All\n modified buffers since the previous invocation of this method\n will be contained within \"transaction\".\n The redo stack will be cleared.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if checkpoint successful, or false if buffers are read-only","type_short":"boolean"}},{"javadoc":"Returns true if unsaved \"buffer\" changes exist.\n If no changes have been made, or all changes have been\n \"undone\", false will be returned.  Parameter changes\n are no considered.","static":false,"name":"isChanged","comment":"Returns true if unsaved \"buffer\" changes exist.\n If no changes have been made, or all changes have been\n \"undone\", false will be returned.  Parameter changes\n are no considered.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Create a new checkpoint node list.\n The redo stack will be cleared.\n@param force if true the checkpoint will be performed regardless of\n the lock count.\n@return true if checkpoint successful, or false if buffers are read-only","static":false,"name":"startCheckpoint","comment":"Create a new checkpoint node list.\n The redo stack will be cleared.","params":[],"throws":[],"return":{"type_long":"void","comment":"true if checkpoint successful, or false if buffers are read-only","type_short":"void"}},{"javadoc":"Indicates whether checkpoint versions are available for undo.\n@return true if undo is available","static":false,"name":"hasUndoCheckpoints","comment":"Indicates whether checkpoint versions are available for undo.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if undo is available","type_short":"boolean"}},{"javadoc":"Indicates whether checkpoint versions are available for redo.\n@return true if redo is available","static":false,"name":"hasRedoCheckpoints","comment":"Indicates whether checkpoint versions are available for redo.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if redo is available","type_short":"boolean"}},{"javadoc":"Returns number of undo-able transactions","static":false,"name":"getAvailableUndoCount","comment":"Returns number of undo-able transactions","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns the number of redo-able transactions","static":false,"name":"getAvailableRedoCount","comment":"Returns the number of redo-able transactions","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Backup to previous checkpoint.","static":false,"name":"undo","comment":"Backup to previous checkpoint.","params":[{"type_long":"boolean","name":"redoable","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Redo next checkpoint.","static":false,"name":"redo","comment":"Redo next checkpoint.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if save operation can be performed.","static":false,"name":"canSave","comment":"Returns true if save operation can be performed.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if buffers have been modified since opening or since\n last snapshot.","static":false,"name":"modifiedSinceSnapshot","comment":"Returns true if buffers have been modified since opening or since\n last snapshot.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Generate recovery snapshot of unsaved data.\n@param changeSet an optional database-backed change set which reflects changes\n made since the last version.\n@param monitor task monitor\n@returns true if snapshot successful, false if","static":false,"name":"takeRecoverySnapshot","comment":"Generate recovery snapshot of unsaved data.","params":[{"type_long":"db.DBChangeSet","name":"changeSet","comment":"an optional database-backed change set which reflects changes\n made since the last version.","type_short":"DBChangeSet"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the recovery changeSet data file for reading or null if one is not available.\n The caller must dispose of the returned file before peforming generating any new\n recovery snapshots.\n@throws IOException","static":false,"name":"getRecoveryChangeSetFile","comment":"Returns the recovery changeSet data file for reading or null if one is not available.\n The caller must dispose of the returned file before peforming generating any new\n recovery snapshots.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.LocalBufferFile","comment":"","type_short":"LocalBufferFile"}},{"javadoc":"Immediately following instantiation of this BufferMgr, discard any pre-existing\n recovery snapshots.","static":false,"name":"clearRecoveryFiles","comment":"Immediately following instantiation of this BufferMgr, discard any pre-existing\n recovery snapshots.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Immediately following instatiation of this BufferMgr, attempt a unsaved data recovery.\n If successful, the method getRecoveryChangeSetFile should be invoked to obtain\/open the\n changeSet data file which must be used by the application to recover the changeSet.\n If recovery is cancelled, this buffer manager must be disposed.\n since the underlying state will be corrupt.\n@param monitor task monitor","static":false,"name":"recover","comment":"Immediately following instatiation of this BufferMgr, attempt a unsaved data recovery.\n If successful, the method getRecoveryChangeSetFile should be invoked to obtain\/open the\n changeSet data file which must be used by the application to recover the changeSet.\n If recovery is cancelled, this buffer manager must be disposed.\n since the underlying state will be corrupt.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Recover data from recovery file\n@param recoveryFile\n@param monitor\n@throws CancelledException","static":false,"name":"recover","comment":"Recover data from recovery file","params":[{"type_long":"db.buffers.RecoveryFile","name":"recoveryFile","comment":"","type_short":"RecoveryFile"},{"type_long":"int","name":"recoveryIndex","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determine if unsaved changes can be recovered for the current BufferFile\n associated with the specified bfMgr.\n@param bfMgr buffer file manager\n@return true if a recover is possible","static":true,"name":"canRecover","comment":"Determine if unsaved changes can be recovered for the current BufferFile\n associated with the specified bfMgr.","params":[{"type_long":"db.buffers.BufferFileManager","name":"bfMgr","comment":"buffer file manager","type_short":"BufferFileManager"}],"throws":[],"return":{"type_long":"boolean","comment":"true if a recover is possible","type_short":"boolean"}},{"javadoc":"Save the current set of buffers to a new version of the source buffer file.\n If the buffer manager was not instantiated with a source file an\n IllegalStateException will be thrown.\n@param comment if version history is maintained, this comment will be\n associated with the new version.\n@param changeSet an optional database-backed change set which reflects changes\n made since the last version.\n@param monitor a cancellable task monitor.  This method will establish the\n maximum progress count.\n@throws CancelledException if the task monitor cancelled the operation.\n@throws IOException if source, cache or destination file access error occurs","static":false,"name":"save","comment":"Save the current set of buffers to a new version of the source buffer file.\n If the buffer manager was not instantiated with a source file an\n IllegalStateException will be thrown.","params":[{"type_long":"java.lang.String","name":"comment","comment":"if version history is maintained, this comment will be\n associated with the new version.","type_short":"String"},{"type_long":"db.DBChangeSet","name":"changeSet","comment":"an optional database-backed change set which reflects changes\n made since the last version.","type_short":"DBChangeSet"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"a cancellable task monitor.  This method will establish the\n maximum progress count.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if source, cache or destination file access error occurs","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the task monitor cancelled the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Save the current set of buffers to a new buffer file.\n@param outFile an empty buffer file open for writing\n@param associateWithNewFile if true the outFile will be associated with this BufferMgr as the\n current source file, if false no change will be made to this BufferMgr's state and the outFile\n will be written and set as read-only.  The caller is responsible for disposing the outFile if\n this parameter is false.\n@param monitor a cancelable task monitor.  This method will establish the\n maximum progress count.\n@throws CancelledException if the task monitor canceled the operation.\n@throws IOException if source, cache or destination file access error occurs","static":false,"name":"saveAs","comment":"Save the current set of buffers to a new buffer file.","params":[{"type_long":"db.buffers.BufferFile","name":"outFile","comment":"an empty buffer file open for writing","type_short":"BufferFile"},{"type_long":"boolean","name":"associateWithNewFile","comment":"if true the outFile will be associated with this BufferMgr as the\n current source file, if false no change will be made to this BufferMgr's state and the outFile\n will be written and set as read-only.  The caller is responsible for disposing the outFile if\n this parameter is false.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"a cancelable task monitor.  This method will establish the\n maximum progress count.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if source, cache or destination file access error occurs","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the task monitor canceled the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write all changes to the specified outFile\n@param outFile output buffer file\n@param monitor task monitor\n@throws IOException\n@throws CancelledException thrown if task cancelled","static":false,"name":"doSave","comment":"Write all changes to the specified outFile","params":[{"type_long":"db.buffers.BufferFile","name":"outFile","comment":"output buffer file","type_short":"BufferFile"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"thrown if task cancelled","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setSourceFile","comment":"","params":[{"type_long":"db.buffers.BufferFile","name":"newFile","comment":"","type_short":"BufferFile"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getCacheHits","comment":"","params":[],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getCacheMisses","comment":"","params":[],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getLowBufferCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"resetCacheStatistics","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getStatusInfo","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getAllocatedBufferCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getFreeBufferCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":true,"name":"cleanupOldCacheFiles","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"BufferMgr","comment":"BufferMgr provides low-level buffer management and caching.\n Checkpointing and buffer versioning is supported along with an undo\/redo\n capability.","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"ALWAYS_PRECACHE_PROPERTY","comment":"","type_short":"String","constant_value":"\"db.always.precache\""},{"type_long":"boolean","javadoc":"","static":true,"name":"alwaysPreCache","comment":"","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"DEFAULT_BUFFER_SIZE","comment":"","type_short":"int","constant_value":"16384"},{"type_long":"int","javadoc":"","static":true,"name":"DEFAULT_CHECKPOINT_COUNT","comment":"","type_short":"int","constant_value":"10"},{"type_long":"int","javadoc":"","static":true,"name":"DEFAULT_CACHE_SIZE","comment":"","type_short":"int","constant_value":"4194304"},{"type_long":"int","javadoc":"","static":true,"name":"MINIMUM_CACHE_SIZE","comment":"","type_short":"int","constant_value":"65536"},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"CACHE_FILE_PREFIX","comment":"","type_short":"String","constant_value":"\"ghidra\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"CACHE_FILE_EXT","comment":"","type_short":"String","constant_value":"\".cache\""},{"type_long":"int","javadoc":"","static":true,"name":"HEAD","comment":"","type_short":"int","constant_value":"-1"},{"type_long":"int","javadoc":"","static":true,"name":"TAIL","comment":"","type_short":"int","constant_value":"-2"},{"type_long":"java.util.HashSet<db.buffers.BufferMgr>","javadoc":"","static":true,"name":"openInstances","comment":"","type_short":"HashSet","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"maxCheckpoints","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"maxCacheSize","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"currentCheckpoint","comment":"","type_short":"int","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"corruptedState","comment":"","type_short":"boolean","constant_value":null},{"type_long":"db.buffers.BufferFile","javadoc":"","static":false,"name":"sourceFile","comment":"","type_short":"BufferFile","constant_value":null},{"type_long":"db.buffers.LocalBufferFile","javadoc":"","static":false,"name":"cacheFile","comment":"","type_short":"LocalBufferFile","constant_value":null},{"type_long":"db.buffers.RecoveryMgr","javadoc":"","static":false,"name":"recoveryMgr","comment":"","type_short":"RecoveryMgr","constant_value":null},{"type_long":"java.lang.Object","javadoc":"","static":false,"name":"snapshotLock","comment":"","type_short":"Object","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"modifiedSinceSnapshot","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"hasNonUndoableChanges","comment":"","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"bufferSize","comment":"","type_short":"int","constant_value":null},{"type_long":"db.buffers.BufferNode","javadoc":"The cached buffer list provides a linked list of all\n buffer nodes which have an in-memory buffer.  Oldest\n cached nodes are at the bottom (cacheTail.prevCached).","static":false,"name":"cacheHead","comment":"The cached buffer list provides a linked list of all\n buffer nodes which have an in-memory buffer.  Oldest\n cached nodes are at the bottom (cacheTail.prevCached).","type_short":"BufferNode","constant_value":null},{"type_long":"db.buffers.BufferNode","javadoc":"","static":false,"name":"cacheTail","comment":"","type_short":"BufferNode","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"cacheSize","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"buffersOnHand","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"lockCount","comment":"","type_short":"int","constant_value":null},{"type_long":"java.util.Stack<db.buffers.DataBuffer>","javadoc":"Available memory cache buffers","static":false,"name":"freeBuffers","comment":"Available memory cache buffers","type_short":"Stack","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"cacheHits","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"cacheMisses","comment":"","type_short":"long","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"lowWaterMark","comment":"","type_short":"int","constant_value":null},{"type_long":"java.util.ArrayList<db.buffers.BufferNode>","javadoc":"Collection of checkpoint heads for undo","static":false,"name":"checkpointHeads","comment":"Collection of checkpoint heads for undo","type_short":"ArrayList","constant_value":null},{"type_long":"java.util.ArrayList<db.buffers.BufferNode>","javadoc":"Collection of checkpoint heads for redo","static":false,"name":"redoCheckpointHeads","comment":"Collection of checkpoint heads for redo","type_short":"ArrayList","constant_value":null},{"type_long":"db.buffers.BufferNode","javadoc":"Current checkpoint head.  If null a new checkpoint must be\n established on the first buffer modification.","static":false,"name":"currentCheckpointHead","comment":"Current checkpoint head.  If null a new checkpoint must be\n established on the first buffer modification.","type_short":"BufferNode","constant_value":null},{"type_long":"db.buffers.BufferNode","javadoc":"Baseline checkpoint head.  This is holds the oldest version of\n each buffer supported by undo.","static":false,"name":"baselineCheckpointHead","comment":"Baseline checkpoint head.  This is holds the oldest version of\n each buffer supported by undo.","type_short":"BufferNode","constant_value":null},{"type_long":"db.buffers.IndexProvider","javadoc":"Index provider for database buffer file.","static":false,"name":"indexProvider","comment":"Index provider for database buffer file.","type_short":"IndexProvider","constant_value":null},{"type_long":"db.buffers.IndexProvider","javadoc":"Index provider for cache file.","static":false,"name":"cacheIndexProvider","comment":"Index provider for cache file.","type_short":"IndexProvider","constant_value":null},{"type_long":"ghidra.util.datastruct.ObjectArray","javadoc":"The buffer table contains stacks for each buffer id.\n The table contains the head buffer node.  When new buffer\n versions are created, they are pushed onto the stack - e.g.,\n inserted between the head and the next node.","static":false,"name":"bufferTable","comment":"The buffer table contains stacks for each buffer id.\n The table contains the head buffer node.  When new buffer\n versions are created, they are pushed onto the stack - e.g.,\n inserted between the head and the next node.","type_short":"ObjectArray","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"INITIAL_BUFFER_TABLE_SIZE","comment":"","type_short":"int","constant_value":"1024"},{"type_long":"db.buffers.BufferMgr.PreCacheStatus","javadoc":"","static":false,"name":"preCacheStatus","comment":"","type_short":"PreCacheStatus","constant_value":null},{"type_long":"java.lang.Thread","javadoc":"","static":false,"name":"preCacheThread","comment":"","type_short":"Thread","constant_value":null},{"type_long":"java.lang.Object","javadoc":"","static":false,"name":"preCacheLock","comment":"","type_short":"Object","constant_value":null}]}
