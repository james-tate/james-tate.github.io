{"implements":["db.buffers.BufferFile"],"javadoc":"<code>LocalBufferFile<\/code> implements a BufferFile as block-oriented\n random-access file.  This type of buffer file supports save-as but does\n not support the save operation.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Create a temporary read\/write block file.\n@param bufferSize user buffer size\n@param tmpPrefix temporary file prefix\n@param tmpExtension temporary file extension","static":false,"name":"<init>","comment":"Create a temporary read\/write block file.","params":[{"type_long":"int","name":"bufferSize","comment":"user buffer size","type_short":"int"},{"type_long":"java.lang.String","name":"tmpPrefix","comment":"temporary file prefix","type_short":"String"},{"type_long":"java.lang.String","name":"tmpExtension","comment":"temporary file extension","type_short":"String"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Create a new buffer file for writing.\n If the file does not exist and create is true, a new buffer file will\n be created.\n The file will be saved when closed.\n@param file buffer file\n@param bufferSize user buffer size\n@throws DuplicateFileException if file already exists\n@throws IOException if an I\/O error occurs during file creation","static":false,"name":"<init>","comment":"Create a new buffer file for writing.\n If the file does not exist and create is true, a new buffer file will\n be created.\n The file will be saved when closed.","params":[{"type_long":"java.io.File","name":"file","comment":"buffer file","type_short":"File"},{"type_long":"int","name":"bufferSize","comment":"user buffer size","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs during file creation","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Open an existing block file.\n@param file block file\n@param readOnly if true the file will be opened read-only\n@throws IOException if an IO error occurs or the incorrect magicNumber\n was read from the file.","static":false,"name":"<init>","comment":"Open an existing block file.","params":[{"type_long":"java.io.File","name":"file","comment":"block file","type_short":"File"},{"type_long":"boolean","name":"readOnly","comment":"if true the file will be opened read-only","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"if an IO error occurs or the incorrect magicNumber\n was read from the file.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Modify an existing buffer file.\n WARNING! Use with extreme caution since this modifies\n the original file and could destroy data if used\n improperly.\n@param file\n@param bufferIndex\n@param buf\n@throws IOException","static":true,"name":"poke","comment":"Modify an existing buffer file.\n WARNING! Use with extreme caution since this modifies\n the original file and could destroy data if used\n improperly.","params":[{"type_long":"java.io.File","name":"file","comment":"","type_short":"File"},{"type_long":"int","name":"bufferIndex","comment":"","type_short":"int"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Read a buffer from an existing buffer file.\n@param file\n@param bufferIndex\n@return \n@throws IOException","static":true,"name":"peek","comment":"Read a buffer from an existing buffer file.","params":[{"type_long":"java.io.File","name":"file","comment":"","type_short":"File"},{"type_long":"int","name":"bufferIndex","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"","type_short":"DataBuffer"}},{"javadoc":"Returns the physical file associated with this BufferFile.","static":false,"name":"getFile","comment":"Returns the physical file associated with this BufferFile.","params":[],"throws":[],"return":{"type_long":"java.io.File","comment":"","type_short":"File"}},{"javadoc":"","static":false,"name":"isReadOnly","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getParameter","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[{"type_long":"java.util.NoSuchElementException","comment":"","type_short":"NoSuchElementException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"setParameter","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"int","name":"value","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clearParameters","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getParameterNames","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String[]","comment":"","type_short":"java.lang.String[]"}},{"javadoc":"","static":false,"name":"getFreeIndexes","comment":"","params":[],"throws":[],"return":{"type_long":"int[]","comment":"","type_short":"int[]"}},{"javadoc":"","static":false,"name":"setFreeIndexes","comment":"","params":[{"type_long":"int[]","name":"indexes","comment":"","type_short":"int[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return the file ID assigned to this file.","static":false,"name":"getFileId","comment":"","params":[],"throws":[],"return":{"type_long":"long","comment":"the file ID assigned to this file.","type_short":"long"}},{"javadoc":"Assigns the file ID for this file.  This should only be done\n when reconstructing a file.\n@param fileId file ID","static":false,"name":"setFileId","comment":"Assigns the file ID for this file.  This should only be done\n when reconstructing a file.","params":[{"type_long":"long","name":"id","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return number of buffers countained within this file","static":false,"name":"getBufferCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"number of buffers countained within this file","type_short":"int"}},{"javadoc":"Assigns the buffer count for this file.  This should only be done\n when reconstructing a file.\n@param count number of valid buffers contained within this file","static":false,"name":"setBufferCount","comment":"Assigns the buffer count for this file.  This should only be done\n when reconstructing a file.","params":[{"type_long":"int","name":"count","comment":"number of valid buffers contained within this file","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the temporary status of this buffer file.\n Temporary buffer files are deleted when closed.\n@param isTemporary","static":false,"name":"setTemporary","comment":"Set the temporary status of this buffer file.\n Temporary buffer files are deleted when closed.","params":[{"type_long":"boolean","name":"isTemporary","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Rename underlying file\n@param newFile\n@return true if rename successful\n@throws IOException","static":false,"name":"renameFile","comment":"Rename underlying file","params":[{"type_long":"java.io.File","name":"newFile","comment":"","type_short":"File"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if rename successful","type_short":"boolean"}},{"javadoc":"Set random access file (raf) position to the file block containing the specified buffer \n identified by its' bufferIndex.  It is important to understand the distinction between \n blocks and buffers, where buffers are stored within file blocks which are slightly larger.  \n In addition, the first file block stores the file header and is not used to store a buffer.\n@param bufferIndex buffer index\n@return file block index (=bufferIndex+1)\n@throws IOException","static":false,"name":"seekBufferBlock","comment":"Set random access file (raf) position to the file block containing the specified buffer \n identified by its' bufferIndex.  It is important to understand the distinction between \n blocks and buffers, where buffers are stored within file blocks which are slightly larger.  \n In addition, the first file block stores the file header and is not used to store a buffer.","params":[{"type_long":"int","name":"bufferIndex","comment":"buffer index","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"file block index (=bufferIndex+1)","type_short":"int"}},{"javadoc":"Set random access file (raf) position to the specified file block and offset\n within that block.  NOTE: block#0 contains the file header.\n@param blockIndex block index\n@param offsetWithinBlock offset within file block\n@throws IOException","static":false,"name":"seekBlock","comment":"Set random access file (raf) position to the specified file block and offset\n within that block.  NOTE: block#0 contains the file header.","params":[{"type_long":"int","name":"blockIndex","comment":"block index","type_short":"int"},{"type_long":"int","name":"offsetWithinBlock","comment":"offset within file block","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Read file header and initialize the user parameter and free buffer index lists.\n@throws IOException if an I\/O error occurs while reading file","static":false,"name":"readHeader","comment":"Read file header and initialize the user parameter and free buffer index lists.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs while reading file","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Store the user parameter and free buffer index lists and write the \n file header.\n@throws IOException if an I\/O error occurs while writing file","static":false,"name":"writeHeader","comment":"Store the user parameter and free buffer index lists and write the \n file header.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"if an I\/O error occurs while writing file","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build free index stack from file.","static":false,"name":"buildFreeIndexList","comment":"Build free index stack from file.","params":[{"type_long":"int","name":"firstFreeBufferIndex","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Update a storage block as free and link to the next free block.\n@param index block index of free block\n@param nextFreeIndex block index of next free block, a -1 should be\n specified to mark the end of the linked list.\n@throws IOException thrown if an IO error occurs","static":false,"name":"putFreeBlock","comment":"Update a storage block as free and link to the next free block.","params":[{"type_long":"int","name":"index","comment":"block index of free block","type_short":"int"},{"type_long":"int","name":"nextFreeIndex","comment":"block index of next free block, a -1 should be\n specified to mark the end of the linked list.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Generate a DataBuffer instance which corresponds to the specified block\n based upon LocalBufferFile block usage.\n@param block the buffer file block to be converted\n@return DataBuffer instance or null if head block.  If empty block\n DataBuffer will have null data","static":true,"name":"getDataBuffer","comment":"Generate a DataBuffer instance which corresponds to the specified block\n based upon LocalBufferFile block usage.","params":[{"type_long":"db.buffers.BufferFileBlock","name":"block","comment":"the buffer file block to be converted","type_short":"BufferFileBlock"}],"throws":[],"return":{"type_long":"db.buffers.DataBuffer","comment":"DataBuffer instance or null if head block.  If empty block\n DataBuffer will have null data","type_short":"DataBuffer"}},{"javadoc":"Generate a BufferFileBlock instance which corresponds to the specified DataBuffer\n based upon LocalBufferFile block usage.  This should generally not be used for writing\n empty blocks since they will not be properly linked which is normally handled during \n header flush which is performed by BufferFile close on files being written.\n@param buf the data buffer to be converted\n@param bufferSize data buffer size used for integrity check and generating empty buffer\n@return BufferFileBlock instance.","static":true,"name":"getBufferFileBlock","comment":"Generate a BufferFileBlock instance which corresponds to the specified DataBuffer\n based upon LocalBufferFile block usage.  This should generally not be used for writing\n empty blocks since they will not be properly linked which is normally handled during \n header flush which is performed by BufferFile close on files being written.","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"the data buffer to be converted","type_short":"DataBuffer"},{"type_long":"int","name":"bufferSize","comment":"data buffer size used for integrity check and generating empty buffer","type_short":"int"}],"throws":[],"return":{"type_long":"db.buffers.BufferFileBlock","comment":"BufferFileBlock instance.","type_short":"BufferFileBlock"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"","type_short":"DataBuffer"},{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"","type_short":"DataBuffer"}},{"javadoc":"","static":false,"name":"put","comment":"","params":[{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"","type_short":"DataBuffer"},{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getBufferSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getIndexCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Truncate the buffer file length to the specified index count.\n@param indexCount","static":false,"name":"truncate","comment":"Truncate the buffer file length to the specified index count.","params":[{"type_long":"int","name":"indexCount","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Write all unwritten data to the file prior to closing.\n@return true if flush was performed, false if not required.\n@throws IOException thrown if flush failed","static":false,"name":"flush","comment":"Write all unwritten data to the file prior to closing.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"thrown if flush failed","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if flush was performed, false if not required.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"dispose","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"finalize","comment":"","params":[],"throws":[{"type_long":"java.lang.Throwable","comment":"","type_short":"Throwable"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setReadOnly","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"@return true if this is a temporary buffer file","static":false,"name":"isTemporary","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a temporary buffer file","type_short":"boolean"}},{"javadoc":"@return true if buffer file is closed","static":false,"name":"isClosed","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if buffer file is closed","type_short":"boolean"}},{"javadoc":"","static":false,"name":"close","comment":"","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"delete","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Clone this buffer file to the specified file.  The file must not \n already exist.  If the operation is cancelled or an error occurs\n the file is not created.\n@param destinationFile destination file\n@param monitor progress monitor\n@throws IOException if IO error occurs.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"clone","comment":"Clone this buffer file to the specified file.  The file must not \n already exist.  If the operation is cancelled or an error occurs\n the file is not created.","params":[{"type_long":"java.io.File","name":"destinationFile","comment":"destination file","type_short":"File"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"progress monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if IO error occurs.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Obtain a direct stream to read all blocks of this buffer file\n@return input block stream\n@throws IOException","static":false,"name":"getInputBlockStream","comment":"Obtain a direct stream to read all blocks of this buffer file","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.InputBlockStream","comment":"input block stream","type_short":"InputBlockStream"}},{"javadoc":"Obtain a direct stream to write blocks to this buffer file\n@param blockCount number of blocks to be transferred\n@return output block stream\n@throws IOException","static":false,"name":"getOutputBlockStream","comment":"Obtain a direct stream to write blocks to this buffer file","params":[{"type_long":"int","name":"blockCount","comment":"number of blocks to be transferred","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.OutputBlockStream","comment":"output block stream","type_short":"OutputBlockStream"}},{"javadoc":"Factory method for generating the appropriate type of {@link InputBlockStream}\n for the specified read-only bufferFile.  Input stream may not supply header block in which case \n free list and file parameters may need to be set separately.\n@param bufferFile buffer file opened read-only\n@return input block stream object\n@throws IOException","static":true,"name":"getInputBlockStream","comment":"Factory method for generating the appropriate type of InputBlockStream\n for the specified read-only bufferFile.  Input stream may not supply header block in which case \n free list and file parameters may need to be set separately.","params":[{"type_long":"db.buffers.BufferFile","name":"bufferFile","comment":"buffer file opened read-only","type_short":"BufferFile"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.InputBlockStream","comment":"input block stream object","type_short":"InputBlockStream"}},{"javadoc":"Factory method for generating the appropriate type of {@link InputBlockStream}\n for the specified read-only bufferFile with an optional changeMap used\n to select which buffer should be transferred.  Input stream may not supply header block \n in which case free list and file parameters may need to be set separately.\n@param bufferFile buffer file opened read-only\n@return input block stream object\n@throws IOException","static":true,"name":"getInputBlockStream","comment":"Factory method for generating the appropriate type of InputBlockStream\n for the specified read-only bufferFile with an optional changeMap used\n to select which buffer should be transferred.  Input stream may not supply header block \n in which case free list and file parameters may need to be set separately.","params":[{"type_long":"db.buffers.BufferFile","name":"bufferFile","comment":"buffer file opened read-only","type_short":"BufferFile"},{"type_long":"db.buffers.ChangeMap","name":"changeMap","comment":"","type_short":"ChangeMap"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.InputBlockStream","comment":"input block stream object","type_short":"InputBlockStream"}},{"javadoc":"Factory method for generating the appropriate type of {@link OutputBlockStream}\n for the specified write-able bufferFile.\n@param bufferFile write-able buffer file\n@param blockCount number of blocks to be written.  This should be available from\n the corresponding {@link InputBlockStream}.\n@return output block stream object\n@throws IOException","static":true,"name":"getOutputBlockStream","comment":"Factory method for generating the appropriate type of OutputBlockStream\n for the specified write-able bufferFile.","params":[{"type_long":"db.buffers.BufferFile","name":"bufferFile","comment":"write-able buffer file","type_short":"BufferFile"},{"type_long":"int","name":"blockCount","comment":"number of blocks to be written.  This should be available from\n the corresponding InputBlockStream.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.OutputBlockStream","comment":"output block stream object","type_short":"OutputBlockStream"}},{"javadoc":"Copy the complete content of a specfied srcFile into a destFile\n excluding file ID.  Both files remain open.\n@param srcFile open buffer file\n@param destFile empty buffer file which is open for writing.\n@param changeMap optional change map which indicates those buffers which must be copied.\n Any buffer index outside the range of the change map will also be copied.\n@param monitor progress monitor\n@throws IOException if IO error occurs.\n@throws CancelledException if the monitor cancels the operation.","static":true,"name":"copyFile","comment":"Copy the complete content of a specfied srcFile into a destFile\n excluding file ID.  Both files remain open.","params":[{"type_long":"db.buffers.BufferFile","name":"srcFile","comment":"open buffer file","type_short":"BufferFile"},{"type_long":"db.buffers.BufferFile","name":"destFile","comment":"empty buffer file which is open for writing.","type_short":"BufferFile"},{"type_long":"db.buffers.ChangeMap","name":"changeMap","comment":"optional change map which indicates those buffers which must be copied.\n Any buffer index outside the range of the change map will also be copied.","type_short":"ChangeMap"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"progress monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if IO error occurs.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Perform a complete block stream transfer from in to out\n@param in input block stream\n@param out output block stream\n@param monitor progress and cancel monitor\n@throws CancelledException\n@throws IOException","static":true,"name":"completeBlockStreamTransfer","comment":"Perform a complete block stream transfer from in to out","params":[{"type_long":"db.buffers.InputBlockStream","name":"in","comment":"input block stream","type_short":"InputBlockStream"},{"type_long":"db.buffers.OutputBlockStream","name":"out","comment":"output block stream","type_short":"OutputBlockStream"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"progress and cancel monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Attempt to remove all pre-save files.\n Those still open by an existing process should \n not be removed by the operating system.\n@param dir data directory containing presave files\n@param beforeNow if not 0, file mod time must be less than the specified time","static":true,"name":"cleanupOldPreSaveFiles","comment":"Attempt to remove all pre-save files.\n Those still open by an existing process should \n not be removed by the operating system.","params":[{"type_long":"java.io.File","name":"dir","comment":"data directory containing presave files","type_short":"File"},{"type_long":"long","name":"beforeNow","comment":"if not 0, file mod time must be less than the specified time","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the recommended buffer size given a target buffer size.\n@param requestedBufferSize target buffer size\n@return recommended buffer size","static":true,"name":"getRecommendedBufferSize","comment":"Get the recommended buffer size given a target buffer size.","params":[{"type_long":"int","name":"requestedBufferSize","comment":"target buffer size","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"recommended buffer size","type_short":"int"}}],"name":"LocalBufferFile","comment":"LocalBufferFile implements a BufferFile as block-oriented\n random-access file.  This type of buffer file supports save-as but does\n not support the save operation.","fields":[{"type_long":"long","javadoc":"","static":true,"name":"MAGIC_NUMBER","comment":"","type_short":"long","constant_value":"3400271784588160042"},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"BUFFER_FILE_EXTENSION","comment":"","type_short":"String","constant_value":"\".gbf\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"PRESAVE_FILE_EXT","comment":"","type_short":"String","constant_value":"\".ps\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"PRESAVE_FILE_PREFIX","comment":"","type_short":"String","constant_value":"\"tmp\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"TEMP_FILE_EXT","comment":"","type_short":"String","constant_value":"\".tmp\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"STRING_ENCODING","comment":"","type_short":"String","constant_value":"\"UTF-8\""},{"type_long":"int","javadoc":"","static":true,"name":"MINIMUM_BLOCK_SIZE","comment":"","type_short":"int","constant_value":"128"},{"type_long":"java.util.Random","javadoc":"","static":true,"name":"random","comment":"","type_short":"Random","constant_value":null},{"type_long":"int","javadoc":"Current file header format version number.\n The third field of the file header indicates a \n format version which indicates how the header\n is formatted.","static":true,"name":"HEADER_FORMAT_VERSION","comment":"Current file header format version number.\n The third field of the file header indicates a \n format version which indicates how the header\n is formatted.","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"FILE_ID_OFFSET","comment":"","type_short":"int","constant_value":"8"},{"type_long":"int","javadoc":"","static":true,"name":"BUFFER_PREFIX_SIZE","comment":"","type_short":"int","constant_value":"5"},{"type_long":"int","javadoc":"","static":true,"name":"VER1_FIXED_HEADER_LENGTH","comment":"","type_short":"int","constant_value":"32"},{"type_long":"byte","javadoc":"","static":true,"name":"EMPTY_BUFFER","comment":"","type_short":"byte","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"MAX_BUFFER_INDEX","comment":"","type_short":"int","constant_value":"2147483646"},{"type_long":"java.util.Hashtable<java.lang.String,java.lang.Integer>","javadoc":"<code>userParms<\/code> contains application parameters which correspond to\n this buffer file.  This list is established for \n an existing buffer file when the readHeader is invoked.  For a non-temporary \n writable buffer file, this list is flushed to the file when either close or\n setReadOnly is invoked.","static":false,"name":"userParms","comment":"userParms contains application parameters which correspond to\n this buffer file.  This list is established for \n an existing buffer file when the readHeader is invoked.  For a non-temporary \n writable buffer file, this list is flushed to the file when either close or\n setReadOnly is invoked.","type_short":"Hashtable","constant_value":null},{"type_long":"int[]","javadoc":"<code>freeIndexes<\/code> contains those buffer indexes which are free\/empty\n and may be re-used in an update of this file.  This list is established for \n an existing buffer file when the readHeader is invoked.  For a non-temporary \n writable buffer file, this list is flushed to the file when either close or\n setReadOnly is invoked.","static":false,"name":"freeIndexes","comment":"freeIndexes contains those buffer indexes which are free\/empty\n and may be re-used in an update of this file.  This list is established for \n an existing buffer file when the readHeader is invoked.  For a non-temporary \n writable buffer file, this list is flushed to the file when either close or\n setReadOnly is invoked.","type_short":"int[]","constant_value":null},{"type_long":"java.io.File","javadoc":"<code>file<\/code> is the underlying storage file for this buffer file.","static":false,"name":"file","comment":"file is the underlying storage file for this buffer file.","type_short":"File","constant_value":null},{"type_long":"java.io.RandomAccessFile","javadoc":"<code>raf<\/code> is the random-access object for the underlying file.","static":false,"name":"raf","comment":"raf is the random-access object for the underlying file.","type_short":"RandomAccessFile","constant_value":null},{"type_long":"db.buffers.LocalBufferFile.LocalOutputBlockStream","javadoc":"<code>activeBlockStream<\/code> provides a handle to the active \n OutputBlockStream used to update file via raf.  This should be\n checked during {@link #close()} to guard against partially \n written file.  A LocalOutputBlockStream should only be used\n for files open for writing (i.e., !readOnly).","static":false,"name":"activeOutputBlockStream","comment":"activeBlockStream provides a handle to the active \n OutputBlockStream used to update file via raf.  This should be\n checked during #close() to guard against partially \n written file.  A LocalOutputBlockStream should only be used\n for files open for writing (i.e., !readOnly).","type_short":"LocalOutputBlockStream","constant_value":null},{"type_long":"boolean","javadoc":"When <code>temporary<\/code> is true and this file is writable (!readOnly)\n it will be deleted when disposed or closed.","static":false,"name":"temporary","comment":"When temporary is true and this file is writable (!readOnly)\n it will be deleted when disposed or closed.","type_short":"boolean","constant_value":null},{"type_long":"long","javadoc":"<code>fileId<\/code> corresponds to a random file ID assigned to this file.\n This file ID can be used as an integrity check when applying version files\n to a specific buffer file.","static":false,"name":"fileId","comment":"fileId corresponds to a random file ID assigned to this file.\n This file ID can be used as an integrity check when applying version files\n to a specific buffer file.","type_short":"long","constant_value":null},{"type_long":"boolean","javadoc":"If <code>readOnly<\/code> is true, this file may not be modified \n via the buffer put method.  \n A read-only file may be considered \"updateable\" if the canSave\n method returns true.  The term \"updateable\" means that a Save file\n can be obtained via the getSaveFile method.","static":false,"name":"readOnly","comment":"If readOnly is true, this file may not be modified \n via the buffer put method.  \n A read-only file may be considered \"updateable\" if the canSave\n method returns true.  The term \"updateable\" means that a Save file\n can be obtained via the getSaveFile method.","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"<code>blockSize<\/code> is the \"actual\" size of each block within this\n file. The <code>blockSize<\/code> equals the <code>bufferSize<\/code> plus\n a few bytes used for flags and to identify the user-level buffer ID.","static":false,"name":"blockSize","comment":"blockSize is the \"actual\" size of each block within this\n file. The blockSize equals the bufferSize plus\n a few bytes used for flags and to identify the user-level buffer ID.","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"<code>bufferSize<\/code> is the \"usable\" buffer space within each\n block of this file.","static":false,"name":"bufferSize","comment":"bufferSize is the \"usable\" buffer space within each\n block of this file.","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"<code>bufferCount<\/code> indicates the number of buffer which have been \n allocated within this file and directly reflects the size of the file.\n The value corresponds to the next buffer index which can be allocated once all\n free indexes have been utilized.  When an existing file is opened, this value\n is computed based upon the file length and the buffer size.","static":false,"name":"bufferCount","comment":"bufferCount indicates the number of buffer which have been \n allocated within this file and directly reflects the size of the file.\n The value corresponds to the next buffer index which can be allocated once all\n free indexes have been utilized.  When an existing file is opened, this value\n is computed based upon the file length and the buffer size.","type_short":"int","constant_value":null}]}
