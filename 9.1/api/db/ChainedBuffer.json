{"implements":["db.Buffer"],"javadoc":"<code>DBBuffer<\/code> provides storage for large data objects utilizing a common\n buffer management system.  Smaller data buffers are allocated and chained as needed.\n All instances of DBBuffer must be immediately discarded following an undo or redo on the \n associated DBHandle.\n <p>\n The largest supported chained buffer is about 2-GBytes.  This limit may be slightly smaller \n based upon the underlying database buffer size.\n <p>\n The buffer may consist of either a single Data Node or a series of Index Nodes \n which reference Data Nodes.\n <pre>\n Data Node (Non-indexed):\n   | 9 (1) | Obfuscation\/DataLength(4) | Data ...\n \n Data Node (Indexed):\n   | 9 (1) | Data ...\n \n Index Node:\n   | 8 (1) | Obfuscation\/DataLength(4) | NextIndexId(4) | DataBuffer1Id(4) | ... | DataBufferNId(4) |\n   Number of index entries computed based upon data length and buffer size.  The index for \n   the entire data space is divided among a series of Index Nodes which\n   are chained together using the NextIndexId field. Each Index Node identifies \n   Data Nodes which have been allocated by a DataBufferId.  A DataBufferId of -1 indicates an\n   non-allocated data node.  The DataLength field is only used in the first index buffer.\n   \n Obfuscation:\n   Data obfuscation is indicated by a '1' in the most-significant bit of the Obfuscation\/DataLength \n   field.\n <\/pre>\n Once a DBBuffer is deleted or appended to another DBBuffer, it becomes invalid and \n may no longer be used.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a new chained buffer with optional obfuscation and uninitialized data source.\n This method may only be invoked while a database transaction \n is in progress.\n@param size buffer size (0 < size <= 0x7fffffff)\n@param enableObfuscation true to enable xor-ing of stored data to facilitate data obfuscation.\n@param uninitializedDataSource optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.\n@param unintializedDataSourceOffset uninitialized data source offset which corresponds to\n this buffers contents.\n@param bufferMgr database buffer manager\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new chained buffer with optional obfuscation and uninitialized data source.\n This method may only be invoked while a database transaction \n is in progress.","params":[{"type_long":"int","name":"size","comment":"buffer size (0  size = 0x7fffffff)","type_short":"int"},{"type_long":"boolean","name":"enableObfuscation","comment":"true to enable xor-ing of stored data to facilitate data obfuscation.","type_short":"boolean"},{"type_long":"db.Buffer","name":"uninitializedDataSource","comment":"optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.","type_short":"Buffer"},{"type_long":"int","name":"unintializedDataSourceOffset","comment":"uninitialized data source offset which corresponds to\n this buffers contents.","type_short":"int"},{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new chained buffer with optional obfuscation.\n This method may only be invoked while a database transaction \n is in progress.\n@param size buffer size (0 < size <= 0x7fffffff)\n@param enableObfuscation true to enable xor-ing of stored data to facilitate data obfuscation.\n@param bufferMgr database buffer manager\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new chained buffer with optional obfuscation.\n This method may only be invoked while a database transaction \n is in progress.","params":[{"type_long":"int","name":"size","comment":"buffer size (0  size = 0x7fffffff)","type_short":"int"},{"type_long":"boolean","name":"enableObfuscation","comment":"true to enable xor-ing of stored data to facilitate data obfuscation.","type_short":"boolean"},{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new chained buffer.\n This method may only be invoked while a database transaction is in progress.\n@param size buffer size (0 < size <= 0x7fffffff)\n@param bufferMgr database buffer manager\n@throws IOException","static":false,"name":"<init>","comment":"Construct a new chained buffer.\n This method may only be invoked while a database transaction is in progress.","params":[{"type_long":"int","name":"size","comment":"buffer size (0  size = 0x7fffffff)","type_short":"int"},{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct an existing chained buffer.\n@param bufferMgr database buffer manager\n@param bufferId database buffer ID which corresponds to a stored ChainedBuffer\n@param uninitializedDataSource optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.\n@param unintializedDataSourceOffset uninitialized data source offset which corresponds to\n this buffers contents.\n@throws IOException","static":false,"name":"<init>","comment":"Construct an existing chained buffer.","params":[{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"},{"type_long":"int","name":"bufferId","comment":"database buffer ID which corresponds to a stored ChainedBuffer","type_short":"int"},{"type_long":"db.Buffer","name":"uninitializedDataSource","comment":"optional data source for uninitialized data.  This should be a \n read-only buffer which will always be used when re-instantiating the same stored ChainedBuffer.\n This should not be specified if buffer will be completely filled\/initialized.","type_short":"Buffer"},{"type_long":"int","name":"unintializedDataSourceOffset","comment":"uninitialized data source offset which corresponds to\n this buffers contents.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct an existing chained buffer.\n@param bufferMgr database buffer manager\n@param bufferId database buffer ID which corresponds to a stored ChainedBuffer","static":false,"name":"<init>","comment":"Construct an existing chained buffer.","params":[{"type_long":"db.buffers.BufferMgr","name":"bufferMgr","comment":"database buffer manager","type_short":"BufferMgr"},{"type_long":"int","name":"bufferId","comment":"database buffer ID which corresponds to a stored ChainedBuffer","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getObfuscationDataLengthFieldValue","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Generate the XOR value for the specified byteValue which is located at the\n specified bufferOffset.\n@param bufferOffset offset within a single chained buffer, valid values are in the \n range 0 to (dataSpace-1).\n@param byteValue\n@return ","static":false,"name":"xorMaskByte","comment":"Generate the XOR value for the specified byteValue which is located at the\n specified bufferOffset.","params":[{"type_long":"int","name":"bufferOffset","comment":"offset within a single chained buffer, valid values are in the \n range 0 to (dataSpace-1).","type_short":"int"},{"type_long":"byte","name":"byteValue","comment":"","type_short":"byte"}],"throws":[],"return":{"type_long":"byte","comment":"","type_short":"byte"}},{"javadoc":"Get an XOR obfuscation mask of the specified length in support of the \n short, int and long get\/put methods.\n@param bufferOffset offset within a single chained buffer, valid values are in the \n range 0 to (dataSpace-1).  The value (bufferOffset+len-1) must be less than dataSpace.\n@param len mask length (2, 4, or 8)\n@return ","static":false,"name":"getXorMask","comment":"Get an XOR obfuscation mask of the specified length in support of the \n short, int and long get\/put methods.","params":[{"type_long":"int","name":"bufferOffset","comment":"offset within a single chained buffer, valid values are in the \n range 0 to (dataSpace-1).  The value (bufferOffset+len-1) must be less than dataSpace.","type_short":"int"},{"type_long":"int","name":"len","comment":"mask length (2, 4, or 8)","type_short":"int"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"If this chained buffer was not completely filled\/initialized a dataSource may be used\n obtain the initial values when needed.  When an uninitialized area is written, any unwritten\n areas within the containing block(s) will be initialized from the uninitialized dataSource.\n The same uninitialized read-only dataSource used for a chained buffer should be re-applied\n anytime this chained buffer is re-instantiated.\n@param dataSource\n@param dataSourceOffset","static":false,"name":"setUnintializedDataSource","comment":"If this chained buffer was not completely filled\/initialized a dataSource may be used\n obtain the initial values when needed.  When an uninitialized area is written, any unwritten\n areas within the containing block(s) will be initialized from the uninitialized dataSource.\n The same uninitialized read-only dataSource used for a chained buffer should be re-applied\n anytime this chained buffer is re-instantiated.","params":[{"type_long":"db.Buffer","name":"dataSource","comment":"","type_short":"Buffer"},{"type_long":"int","name":"dataSourceOffset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return true if obfuscated data storage has been enabled","static":false,"name":"hasObfuscatedStorage","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if obfuscated data storage has been enabled","type_short":"boolean"}},{"javadoc":"Set the read-only state of this ChainedBuffer.  After invoking this method any\n attempt to alter this buffer will result in an UnsupportedOperation exception.","static":false,"name":"setReadOnly","comment":"Set the read-only state of this ChainedBuffer.  After invoking this method any\n attempt to alter this buffer will result in an UnsupportedOperation exception.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return the maximum number of buffers consumed by the storage of this DBBuffer object.\n The actual number may be less if data has not been written to the entire buffer.","static":false,"name":"getBufferCount","comment":"Return the maximum number of buffers consumed by the storage of this DBBuffer object.\n The actual number may be less if data has not been written to the entire buffer.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Set the new size for this DBBuffer object.\n@param size new size\n@param preserveData if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.\n@throws UnsupportedOperationException thrown if this ChainedBuffer utilizes an \n Uninitialized Data Source or is read-only\n@throws IOException thrown if an IO error occurs.\n@throws UnsupportedOperationException if read-only or uninitialized data source is used","static":false,"name":"setSize","comment":"Set the new size for this DBBuffer object.","params":[{"type_long":"int","name":"size","comment":"new size","type_short":"int"},{"type_long":"boolean","name":"preserveData","comment":"if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Increase the size of this DBBuffer object.\n@param newSize new size.\n@param preserveData if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.\n@throws IOException thrown if an IO error occurs.","static":false,"name":"grow","comment":"Increase the size of this DBBuffer object.","params":[{"type_long":"int","name":"newSize","comment":"new size.","type_short":"int"},{"type_long":"boolean","name":"preserveData","comment":"if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Attempt to shrink this DBBuffer object into a single data buffer.\n The current <code>size<\/code> field reflects the new small size.\n@param preserveData if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.\n@return true if successful, false if too big for single buffer.\n@throws IOException thrown if an IO error occurs.","static":false,"name":"shrinkToSingleBuffer","comment":"Attempt to shrink this DBBuffer object into a single data buffer.\n The current size field reflects the new small size.","params":[{"type_long":"boolean","name":"preserveData","comment":"if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs.","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"true if successful, false if too big for single buffer.","type_short":"boolean"}},{"javadoc":"Decrease the size of this DBBuffer object.\n@param newSize new size.\n@param preserveData if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.\n@throws IOException thrown if IO error occurs","static":false,"name":"shrink","comment":"Decrease the size of this DBBuffer object.","params":[{"type_long":"int","name":"newSize","comment":"new size.","type_short":"int"},{"type_long":"boolean","name":"preserveData","comment":"if true, existing data is preserved at the original offsets.  If false,\n no additional effort will be expended to preserve data.","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Split this DBBuffer object into two separate DBBuffers.  This DBBuffer remains\n valid but its new size is equal offset.  The newly created DBBuffer is \n returned.\n@param offset the split point.  The byte at this offset becomes the first\n byte within the new buffer.\n@return the new DBBuffer object.\n@throws UnsupportedOperationException thrown if this ChainedBuffer is read-only\n@throws ArrayIndexOutOfBoundsException if offset is invalid.\n@throws IOException thrown if an IO error occurs","static":false,"name":"split","comment":"Split this DBBuffer object into two separate DBBuffers.  This DBBuffer remains\n valid but its new size is equal offset.  The newly created DBBuffer is \n returned.","params":[{"type_long":"int","name":"offset","comment":"the split point.  The byte at this offset becomes the first\n byte within the new buffer.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"db.ChainedBuffer","comment":"the new DBBuffer object.","type_short":"ChainedBuffer"}},{"javadoc":"Append the contents of the specified dbBuf onto the end of this buffer.\n The size of this buffer increases by the size of dbBuf.  When the operation \n is complete, dbBuf object is no longer valid and must not be used.\n@param dbBuf the buffer to be appended to this buffer.\n@throws IOException thrown if an IO error occurs\n@throws UnsupportedOperationException if read-only, uninitialized data source is used,\n or both buffers do not have the same obfuscation enablement","static":false,"name":"append","comment":"Append the contents of the specified dbBuf onto the end of this buffer.\n The size of this buffer increases by the size of dbBuf.  When the operation \n is complete, dbBuf object is no longer valid and must not be used.","params":[{"type_long":"db.ChainedBuffer","name":"dbBuf","comment":"the buffer to be appended to this buffer.","type_short":"ChainedBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if an IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Append a new initialized index buffer to the index buffer provided.\n The index buffer provided is always released.\n@param indexBuffer the last index buffer.\n@return DataBuffer\n@throws IOException","static":false,"name":"appendIndexBuffer","comment":"Append a new initialized index buffer to the index buffer provided.\n The index buffer provided is always released.","params":[{"type_long":"db.buffers.DataBuffer","name":"indexBuffer","comment":"the last index buffer.","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"DataBuffer","type_short":"DataBuffer"}},{"javadoc":"Allocate in-memory index and compute buffer parameters for index mode.\n@param buffer sample buffer for computing data and index parameters.\n@return number of index entries","static":false,"name":"allocateIndex","comment":"Allocate in-memory index and compute buffer parameters for index mode.","params":[{"type_long":"db.buffers.DataBuffer","name":"buffer","comment":"sample buffer for computing data and index parameters.","type_short":"DataBuffer"}],"throws":[],"return":{"type_long":"int","comment":"number of index entries","type_short":"int"}},{"javadoc":"Create and initialize a new index for this DBBuffer.\n The entire index is allocated within the database (i.e., Index Nodes).  \n Data Nodes are only allocated as needed when data is written.\n@param indexBuffer first index buffer.  This buffer will be released\n prior to returning.\n@throws IOException thrown if IO error occurs","static":false,"name":"createIndex","comment":"Create and initialize a new index for this DBBuffer.\n The entire index is allocated within the database (i.e., Index Nodes).  \n Data Nodes are only allocated as needed when data is written.","params":[{"type_long":"db.buffers.DataBuffer","name":"indexBuffer","comment":"first index buffer.  This buffer will be released\n prior to returning.","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build the in-memory index for a previously stored DBBuffer.\n@param indexBuffer first index buffer.  This buffer will be released\n prior to returning.\n@throws IOException thrown if IO error occurs","static":false,"name":"buildIndex","comment":"Build the in-memory index for a previously stored DBBuffer.","params":[{"type_long":"db.buffers.DataBuffer","name":"indexBuffer","comment":"first index buffer.  This buffer will be released\n prior to returning.","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the first buffer ID associated with this chained buffer.  This DBBuffer\n may be reinstatiated using the returned buffer ID provided subsequent changes \n are not made.\n@return buffer ID","static":false,"name":"getId","comment":"Get the first buffer ID associated with this chained buffer.  This DBBuffer\n may be reinstatiated using the returned buffer ID provided subsequent changes \n are not made.","params":[],"throws":[],"return":{"type_long":"int","comment":"buffer ID","type_short":"int"}},{"javadoc":"Delete and release all underlying DataBuffers.","static":false,"name":"delete","comment":"Delete and release all underlying DataBuffers.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get byte data from the specified chained buffer.\n@param offset ChainedBuffer offset (needed for uninitialized buffer pass-through)\n@param index buffer index within chain\n@param bufferDataOffset data offset within specified buffer\n@param data destination byte array\n@param dataOffset destination array offset within data\n@param length number of bytes to read\n@return int actual number of byte read.\n This could be smaller than length if the end of buffer is \n encountered while reading data.\n@throws IOException thrown if IO error occurs","static":false,"name":"getBytes","comment":"Get byte data from the specified chained buffer.","params":[{"type_long":"int","name":"offset","comment":"ChainedBuffer offset (needed for uninitialized buffer pass-through)","type_short":"int"},{"type_long":"int","name":"index","comment":"buffer index within chain","type_short":"int"},{"type_long":"int","name":"bufferDataOffset","comment":"data offset within specified buffer","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"destination byte array","type_short":"byte[]"},{"type_long":"int","name":"dataOffset","comment":"destination array offset within data","type_short":"int"},{"type_long":"int","name":"length","comment":"number of bytes to read","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs","type_short":"IOException"}],"return":{"type_long":"int","comment":"int actual number of byte read.\n This could be smaller than length if the end of buffer is \n encountered while reading data.","type_short":"int"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"","type_short":"byte[]"},{"type_long":"int","name":"dataOffset","comment":"","type_short":"int"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"","type_short":"byte[]"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"","static":false,"name":"getByte","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte","comment":"","type_short":"byte"}},{"javadoc":"","static":false,"name":"getInt","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"getLong","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":false,"name":"getShort","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short","comment":"","type_short":"short"}},{"javadoc":"","static":false,"name":"length","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Fill the buffer over the specified range with a byte value.\n@param startOffset starting offset, inclusive\n@param endOffset ending offset, exclusive\n@param fillByte byte value","static":false,"name":"fill","comment":"Fill the buffer over the specified range with a byte value.","params":[{"type_long":"int","name":"startOffset","comment":"starting offset, inclusive","type_short":"int"},{"type_long":"int","name":"endOffset","comment":"ending offset, exclusive","type_short":"int"},{"type_long":"byte","name":"fillByte","comment":"byte value","type_short":"byte"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Put data into the specified chained buffer.  \n NOTE: The caller of this method is responsible for allocating the xorData byte array\n used for applying the obfuscation XOR mask.\n@param index index of within buffer chain\n@param bufferDataOffset data buffer offset\n@param data source byte array\n@param dataOffset source array offset within data\n@param length number of bytes to write\n@return int actual number of bytes written.  \n This could be smaller than length if the end of buffer is \n encountered while writing data.\n@throws IOException","static":false,"name":"putBytes","comment":"Put data into the specified chained buffer.  \n NOTE: The caller of this method is responsible for allocating the xorData byte array\n used for applying the obfuscation XOR mask.","params":[{"type_long":"int","name":"index","comment":"index of within buffer chain","type_short":"int"},{"type_long":"int","name":"bufferDataOffset","comment":"data buffer offset","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"source byte array","type_short":"byte[]"},{"type_long":"int","name":"dataOffset","comment":"source array offset within data","type_short":"int"},{"type_long":"int","name":"length","comment":"number of bytes to write","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"int actual number of bytes written.  \n This could be smaller than length if the end of buffer is \n encountered while writing data.","type_short":"int"}},{"javadoc":"Fill buffer with data provided by InputStream.  If \n stream is exhausted, the remainder of the buffer will be filled\n with 0's.\n@param in data source\n@throws IOException thrown if IO error occurs.","static":false,"name":"fill","comment":"Fill buffer with data provided by InputStream.  If \n stream is exhausted, the remainder of the buffer will be filled\n with 0's.","params":[{"type_long":"java.io.InputStream","name":"in","comment":"data source","type_short":"InputStream"}],"throws":[{"type_long":"java.io.IOException","comment":"thrown if IO error occurs.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"put","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"data","comment":"","type_short":"byte[]"},{"type_long":"int","name":"dataOffset","comment":"","type_short":"int"},{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"put","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte[]","name":"bytes","comment":"","type_short":"byte[]"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putByte","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"byte","name":"b","comment":"","type_short":"byte"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putInt","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"int","name":"v","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putLong","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"long","name":"v","comment":"","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"putShort","comment":"","params":[{"type_long":"int","name":"offset","comment":"","type_short":"int"},{"type_long":"short","name":"v","comment":"","type_short":"short"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get a data buffer.\n@param index index of within buffer chain\n@return requested data buffer.\n@throws IOException","static":false,"name":"getBuffer","comment":"Get a data buffer.","params":[{"type_long":"int","name":"index","comment":"index of within buffer chain","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"db.buffers.DataBuffer","comment":"requested data buffer.","type_short":"DataBuffer"}},{"javadoc":"Initialize specified DataBuffer which corresponds to the chain index.\n@param chainBufferIndex chain buffer index\n@param buf newly allocated database buffer\n@throws IOException","static":false,"name":"initializeAllocatedBuffer","comment":"Initialize specified DataBuffer which corresponds to the chain index.","params":[{"type_long":"int","name":"chainBufferIndex","comment":"chain buffer index","type_short":"int"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"newly allocated database buffer","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add a new data buffer as an indexed buffer.\n@param index buffer index.\n@param buf new data buffer.\n@throws IOException","static":false,"name":"addBuffer","comment":"Add a new data buffer as an indexed buffer.","params":[{"type_long":"int","name":"index","comment":"buffer index.","type_short":"int"},{"type_long":"db.buffers.DataBuffer","name":"buf","comment":"new data buffer.","type_short":"DataBuffer"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"ChainedBuffer","comment":"DBBuffer provides storage for large data objects utilizing a common\n buffer management system.  Smaller data buffers are allocated and chained as needed.\n All instances of DBBuffer must be immediately discarded following an undo or redo on the \n associated DBHandle.\n \n The largest supported chained buffer is about 2-GBytes.  This limit may be slightly smaller \n based upon the underlying database buffer size.\n \n The buffer may consist of either a single Data Node or a series of Index Nodes \n which reference Data Nodes.\n \n Data Node (Non-indexed):\n   | 9 (1) | Obfuscation\/DataLength(4) | Data ...\n \n Data Node (Indexed):\n   | 9 (1) | Data ...\n \n Index Node:\n   | 8 (1) | Obfuscation\/DataLength(4) | NextIndexId(4) | DataBuffer1Id(4) | ... | DataBufferNId(4) |\n   Number of index entries computed based upon data length and buffer size.  The index for \n   the entire data space is divided among a series of Index Nodes which\n   are chained together using the NextIndexId field. Each Index Node identifies \n   Data Nodes which have been allocated by a DataBufferId.  A DataBufferId of -1 indicates an\n   non-allocated data node.  The DataLength field is only used in the first index buffer.\n   \n Obfuscation:\n   Data obfuscation is indicated by a '1' in the most-significant bit of the Obfuscation\/DataLength \n   field.\n \n Once a DBBuffer is deleted or appended to another DBBuffer, it becomes invalid and \n may no longer be used.","fields":[{"type_long":"byte[]","javadoc":"","static":true,"name":"XOR_MASK_BYTES","comment":"","type_short":"byte[]","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"NODE_TYPE_SIZE","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"DATA_LENGTH_SIZE","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"ID_SIZE","comment":"","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"","static":true,"name":"NODE_TYPE_OFFSET","comment":"","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"DATA_LENGTH_OFFSET","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"NEXT_INDEX_ID_OFFSET","comment":"","type_short":"int","constant_value":"5"},{"type_long":"int","javadoc":"","static":true,"name":"INDEX_BASE_OFFSET","comment":"","type_short":"int","constant_value":"9"},{"type_long":"int","javadoc":"","static":true,"name":"DATA_BASE_OFFSET_NONINDEXED","comment":"","type_short":"int","constant_value":"5"},{"type_long":"int","javadoc":"","static":true,"name":"DATA_BASE_OFFSET_INDEXED","comment":"","type_short":"int","constant_value":"1"},{"type_long":"db.buffers.BufferMgr","javadoc":"","static":false,"name":"bufferMgr","comment":"","type_short":"BufferMgr","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"size","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"firstBufferId","comment":"","type_short":"int","constant_value":null},{"type_long":"byte[]","javadoc":"","static":false,"name":"xorData","comment":"","type_short":"byte[]","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"useXORMask","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"readOnly","comment":"","type_short":"boolean","constant_value":null},{"type_long":"db.Buffer","javadoc":"","static":false,"name":"uninitializedDataSource","comment":"","type_short":"Buffer","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"uninitializedDataSourceOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int[]","javadoc":"","static":false,"name":"indexBufferIdTable","comment":"","type_short":"int[]","constant_value":null},{"type_long":"int[]","javadoc":"","static":false,"name":"dataBufferIdTable","comment":"","type_short":"int[]","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"indexesPerBuffer","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"dataBaseOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"dataSpace","comment":"","type_short":"int","constant_value":null}]}
