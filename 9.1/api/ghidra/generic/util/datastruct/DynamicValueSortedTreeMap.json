{"implements":[],"javadoc":"A map that is sorted by value.\n \n This is an implementation of {@link Map} where entries are sorted by value, rather than by key.\n Such a tree may be useful as a priority queue where the cost of an entry may change over time.\n As such, the collections returned by {@link #entrySet()}, {@link #keySet()}, and\n {@link #values()} all implement {@link Deque}. The order of the entries will be updated on any\n call to {@link #put(Object, Object))}, or a call to {@link Collection#add(Object)} on the entry\n set. Additionally, if the values are mutable objects, whose costs may change, there is an\n {@link #update(Object)} method, which notifies the map that the given key may need to be\n repositioned. The associated collections also implement the {@link List} interface, providing\n fairly efficient implementations of {@link List#get(int)} and {@link List#indexOf(Object)}.\n Sequential access is best performed via {@link Collection#iterator()}, since this will use a\n linked list.\n \n The underlying implementation is currently an unbalanced binary tree whose nodes also comprise a\n doubly-linked list. Currently, it is not thread safe.\n@TODO Consider changing to an AVL tree implementation\n@TODO Consider implementing the {@link NavigableMap} interface\n@TODO Consider making the implementation thread-safe\n@param <K> the type of the keys\n@param <V> the type of the values","static":false,"extends":"java.util.AbstractMap","methods":[{"javadoc":"A convenience for null-safe comparison","static":true,"name":"eq","comment":"A convenience for null-safe comparison","params":[{"type_long":"java.lang.Object","name":"o1","comment":"","type_short":"Object"},{"type_long":"java.lang.Object","name":"o2","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Construct a dynamic value-sorted tree map using the values' natural ordering\n \n If the values do not have a natural ordering, you will eventually encounter a\n {@link ClassCastException}. This condition is not checked at construction.","static":false,"name":"<init>","comment":"Construct a dynamic value-sorted tree map using the values' natural ordering\n \n If the values do not have a natural ordering, you will eventually encounter a\n ClassCastException. This condition is not checked at construction.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a dynamic value-sorted tree map using a custom comparator to order the values\n@param comparator the comparator, providing a total ordering of the values","static":false,"name":"<init>","comment":"Construct a dynamic value-sorted tree map using a custom comparator to order the values","params":[{"type_long":"java.util.Comparator<V>","name":"comparator","comment":"the comparator, providing a total ordering of the values","type_short":"Comparator"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clear","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"containsKey","comment":"","params":[{"type_long":"java.lang.Object","name":"key","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"containsValue","comment":"","params":[{"type_long":"java.lang.Object","name":"value","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"{@inheritDoc}\n@see ValueSortedTreeMapEntrySet","static":false,"name":"entrySet","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.ValueSortedTreeMapEntrySet","comment":"","type_short":"ValueSortedTreeMapEntrySet"}},{"javadoc":"","static":false,"name":"get","comment":"","params":[{"type_long":"java.lang.Object","name":"key","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"V","comment":"","type_short":"V"}},{"javadoc":"","static":false,"name":"isEmpty","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Check if a node is correctly positioned relative to its immediate neighbors\n@param n the node\n@return true if the node need not be moved","static":false,"name":"isOrdered","comment":"Check if a node is correctly positioned relative to its immediate neighbors","params":[{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.Node","name":"n","comment":"the node","type_short":"Node"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the node need not be moved","type_short":"boolean"}},{"javadoc":"{@inheritDoc}\n@see ValueSortedTreeMapKeySet","static":false,"name":"keySet","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.ValueSortedTreeMapKeySet","comment":"","type_short":"ValueSortedTreeMapKeySet"}},{"javadoc":"","static":false,"name":"put","comment":"","params":[{"type_long":"K","name":"key","comment":"","type_short":"K"},{"type_long":"V","name":"value","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"V","comment":"","type_short":"V"}},{"javadoc":"","static":false,"name":"putAll","comment":"","params":[{"type_long":"java.util.Map<? extends K,? extends V>","name":"m","comment":"","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"remove","comment":"","params":[{"type_long":"java.lang.Object","name":"key","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"V","comment":"","type_short":"V"}},{"javadoc":"","static":false,"name":"size","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Notify the map of an external change to the cost of a key's associated value\n \n This is meant to update the entry's position after a change in cost. The position may not\n necessarily change, however, if the cost did not change significantly.\n@param key the key whose associated value has changed in cost\n@return true if the entry's position changed","static":false,"name":"update","comment":"Notify the map of an external change to the cost of a key's associated value\n \n This is meant to update the entry's position after a change in cost. The position may not\n necessarily change, however, if the cost did not change significantly.","params":[{"type_long":"K","name":"key","comment":"the key whose associated value has changed in cost","type_short":"K"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the entry's position changed","type_short":"boolean"}},{"javadoc":"Update a node's position\n \n This ought to be called any time the value of a node is modified, whether internall or\n externally. The only way we know of external changes is if the user calls\n {@link #update(Object)}.\n@param n the node whose position to check and update\n@return true if the node's position changed","static":false,"name":"updateNode","comment":"Update a node's position\n \n This ought to be called any time the value of a node is modified, whether internall or\n externally. The only way we know of external changes is if the user calls\n #update(Object).","params":[{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.Node","name":"n","comment":"the node whose position to check and update","type_short":"Node"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the node's position changed","type_short":"boolean"}},{"javadoc":"{@inheritDoc}\n@see ValueSortedTreeMapValues","static":false,"name":"values","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.ValueSortedTreeMapValues","comment":"","type_short":"ValueSortedTreeMapValues"}}],"name":"DynamicValueSortedTreeMap","comment":"A map that is sorted by value.\n \n This is an implementation of Map where entries are sorted by value, rather than by key.\n Such a tree may be useful as a priority queue where the cost of an entry may change over time.\n As such, the collections returned by #entrySet(), #keySet(), and\n #values() all implement Deque. The order of the entries will be updated on any\n call to }, or a call to Collection#add(Object) on the entry\n set. Additionally, if the values are mutable objects, whose costs may change, there is an\n #update(Object) method, which notifies the map that the given key may need to be\n repositioned. The associated collections also implement the List interface, providing\n fairly efficient implementations of List#get(int) and List#indexOf(Object).\n Sequential access is best performed via Collection#iterator(), since this will use a\n linked list.\n \n The underlying implementation is currently an unbalanced binary tree whose nodes also comprise a\n doubly-linked list. Currently, it is not thread safe.","fields":[{"type_long":"java.util.Comparator<V>","javadoc":"","static":false,"name":"comparator","comment":"","type_short":"Comparator","constant_value":null},{"type_long":"java.util.Map<K,ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.Node>","javadoc":"","static":false,"name":"nodeMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.ValueSortedTreeMapEntrySet","javadoc":"","static":false,"name":"entrySet","comment":"","type_short":"ValueSortedTreeMapEntrySet","constant_value":null},{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.ValueSortedTreeMapKeySet","javadoc":"","static":false,"name":"keySet","comment":"","type_short":"ValueSortedTreeMapKeySet","constant_value":null},{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.ValueSortedTreeMapValues","javadoc":"","static":false,"name":"values","comment":"","type_short":"ValueSortedTreeMapValues","constant_value":null},{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.Node","javadoc":"","static":false,"name":"root","comment":"","type_short":"Node","constant_value":null},{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.Node","javadoc":"","static":false,"name":"head","comment":"","type_short":"Node","constant_value":null},{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<K,V>.Node","javadoc":"","static":false,"name":"tail","comment":"","type_short":"Node","constant_value":null}]}
