{"implements":[],"javadoc":"This class is a flattened version of the Program API.\n <p>\n NOTE:\n <ol>\n \t<li>NO METHODS SHOULD EVER BE REMOVED FROM THIS CLASS.\n \t<li>NO METHOD SIGNATURES SHOULD EVER BE CHANGED IN THIS CLASS.\n <\/ol>\n <p>\n This class is used by GhidraScript.\n <p>\n Changing this class will break user scripts.\n <p>\n That is bad. Don't do that.\n <p>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a new flat program API.\n It will not be usable until the 'set' method has been called.","static":false,"name":"<init>","comment":"Constructs a new flat program API.\n It will not be usable until the 'set' method has been called.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new flat program API.\n@param program the program","static":false,"name":"<init>","comment":"Constructs a new flat program API.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new flat program API.\n@param program the program\n@param monitor the task monitor","static":false,"name":"<init>","comment":"Constructs a new flat program API.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program","type_short":"Program"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the current state.\n@param program the program\n@param monitor the task monitor","static":false,"name":"set","comment":"Sets the current state.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program","type_short":"Program"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets the current program.\n@return the program","static":false,"name":"getCurrentProgram","comment":"Gets the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"the program","type_short":"Program"}},{"javadoc":"Gets the current task monitor.\n@return the task monitor","static":false,"name":"getMonitor","comment":"Gets the current task monitor.","params":[],"throws":[],"return":{"type_long":"ghidra.util.task.TaskMonitor","comment":"the task monitor","type_short":"TaskMonitor"}},{"javadoc":"Starts a transaction on the current program.","static":false,"name":"start","comment":"Starts a transaction on the current program.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Ends the transactions on the current program.\n@param commit true if changes should be committed","static":false,"name":"end","comment":"Ends the transactions on the current program.","params":[{"type_long":"boolean","name":"commit","comment":"true if changes should be committed","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the path to the program's executable file.\n For example, <code>c:\\temp\\test.exe<\/code>.\n@return path to program's executable file","static":false,"name":"getProgramFile","comment":"Returns the path to the program's executable file.\n For example, c:\\temp\\test.exe.","params":[],"throws":[],"return":{"type_long":"java.io.File","comment":"path to program's executable file","type_short":"File"}},{"javadoc":"Start disassembling at the specified address.\n The disassembler will follow code flows.\n@param address the address to begin disassembling\n@return true if the program was successfully disassembled","static":false,"name":"disassemble","comment":"Start disassembling at the specified address.\n The disassembler will follow code flows.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to begin disassembling","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the program was successfully disassembled","type_short":"boolean"}},{"javadoc":"Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.\n@param program the program to analyze\n@deprecated the method {@link #analyzeAll} or {@link #analyzeChanges} should be invoked.\n These separate methods were created to clarify their true behavior since many times it is\n only necessary to analyze changes and not the entire program which can take much\n longer and affect more of the program than is necessary.","static":false,"name":"analyze","comment":"Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to analyze","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.\n@param program the program to analyze","static":false,"name":"analyzeAll","comment":"Starts auto-analysis on the specified program and performs complete analysis\n of the entire program.  This is usually only necessary if full analysis was never\n performed. This method will block until analysis completes.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to analyze","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Starts auto-analysis if not started and waits for pending analysis to complete.\n Only pending analysis on program changes is performed, including changes resulting\n from any analysis activity.  This method will block until analysis completes.\n NOTE: The auto-analysis manager will only detect program changes once it has been\n instantiated for a program (i.e, AutoAnalysisManager.getAnalysisManager(program) ).\n This is automatically done for the initial currentProgram, however, if a script is\n opening\/instantiating its own programs it may be necessary to do this prior to\n making changes to the program.\n@param program the program to analyze","static":false,"name":"analyzeChanges","comment":"Starts auto-analysis if not started and waits for pending analysis to complete.\n Only pending analysis on program changes is performed, including changes resulting\n from any analysis activity.  This method will block until analysis completes.\n NOTE: The auto-analysis manager will only detect program changes once it has been\n instantiated for a program (i.e, AutoAnalysisManager.getAnalysisManager(program) ).\n This is automatically done for the initial currentProgram, however, if a script is\n opening\/instantiating its own programs it may be necessary to do this prior to\n making changes to the program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to analyze","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears the code unit (instruction or data) defined at the address.\n@param address the address to clear the code unit\n@throws CancelledException","static":false,"name":"clearListing","comment":"Clears the code unit (instruction or data) defined at the address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to clear the code unit","type_short":"Address"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears the code units (instructions or data) in the specified range.\n@param start the start address\n@param end the end address\n@throws CancelledException","static":false,"name":"clearListing","comment":"Clears the code units (instructions or data) in the specified range.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end address","type_short":"Address"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears the code units (instructions or data) in the specified set\n@param set the set to clear\n@throws CancelledException","static":false,"name":"clearListing","comment":"Clears the code units (instructions or data) in the specified set","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"the set to clear","type_short":"AddressSetView"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears the listing in the specified address set.\n@param set the address set where to clear\n@param code true if code units should be cleared (instructions and defined data)\n@param symbols true if symbols should be cleared\n@param comments true if comments should be cleared\n@param properties true if properties should be cleared\n@param functions true if functions should be cleared\n@param registers true if registers should be cleared\n@param equates true if equates should be cleared\n@param userReferences true if user references should be cleared\n@param analysisReferences true if analysis references should be cleared\n@param importReferences true if import references should be cleared\n@param defaultReferences true if default references should be cleared\n@param bookmarks true if bookmarks should be cleared\n@return true if the address set was successfully cleared","static":false,"name":"clearListing","comment":"Clears the listing in the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"the address set where to clear","type_short":"AddressSetView"},{"type_long":"boolean","name":"code","comment":"true if code units should be cleared (instructions and defined data)","type_short":"boolean"},{"type_long":"boolean","name":"symbols","comment":"true if symbols should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"comments","comment":"true if comments should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"properties","comment":"true if properties should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"functions","comment":"true if functions should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"registers","comment":"true if registers should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"equates","comment":"true if equates should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"userReferences","comment":"true if user references should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"analysisReferences","comment":"true if analysis references should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"importReferences","comment":"true if import references should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"defaultReferences","comment":"true if default references should be cleared","type_short":"boolean"},{"type_long":"boolean","name":"bookmarks","comment":"true if bookmarks should be cleared","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the address set was successfully cleared","type_short":"boolean"}},{"javadoc":"Create a new memory block.\n If the input stream is null, then an uninitialized block will be created.\n@param name the name of the block\n@param start start address of the block\n@param input source of the data used to fill the block.\n@param length the size of the block\n@param overlay true will create an overlay, false will not\n@return the newly created memory block","static":false,"name":"createMemoryBlock","comment":"Create a new memory block.\n If the input stream is null, then an uninitialized block will be created.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the block","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start address of the block","type_short":"Address"},{"type_long":"java.io.InputStream","name":"input","comment":"source of the data used to fill the block.","type_short":"InputStream"},{"type_long":"long","name":"length","comment":"the size of the block","type_short":"long"},{"type_long":"boolean","name":"overlay","comment":"true will create an overlay, false will not","type_short":"boolean"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"the newly created memory block","type_short":"MemoryBlock"}},{"javadoc":"Create a new memory block.\n@param name the name of the block\n@param start start address of the block\n@param bytes the bytes of the memory block\n@param overlay true will create an overlay, false will not\n@return the newly created memory block","static":false,"name":"createMemoryBlock","comment":"Create a new memory block.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the block","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"start address of the block","type_short":"Address"},{"type_long":"byte[]","name":"bytes","comment":"the bytes of the memory block","type_short":"byte[]"},{"type_long":"boolean","name":"overlay","comment":"true will create an overlay, false will not","type_short":"boolean"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"the newly created memory block","type_short":"MemoryBlock"}},{"javadoc":"Returns the first memory block with the specified name.\n NOTE: if more than block exists with the same name, the first\n block with that name will be returned.\n@param name the name of the requested block\n@return the the memory block with the specified name","static":false,"name":"getMemoryBlock","comment":"Returns the first memory block with the specified name.\n NOTE: if more than block exists with the same name, the first\n block with that name will be returned.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the requested block","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"the the memory block with the specified name","type_short":"MemoryBlock"}},{"javadoc":"Returns the memory block containing the specified address,\n or null if no memory block contains the address.\n@param address the address\n@return the memory block containing the specified address","static":false,"name":"getMemoryBlock","comment":"Returns the memory block containing the specified address,\n or null if no memory block contains the address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"the memory block containing the specified address","type_short":"MemoryBlock"}},{"javadoc":"Returns an array containing all the memory blocks\n in the current program.\n@return an array containing all the memory blocks","static":false,"name":"getMemoryBlocks","comment":"Returns an array containing all the memory blocks\n in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock[]","comment":"an array containing all the memory blocks","type_short":"ghidra.program.model.mem.MemoryBlock[]"}},{"javadoc":"Remove the memory block.\n NOTE: ALL ANNOTATION (disassembly, comments, etc) defined in this\n memory block will also be removed!\n@param block the block to be removed","static":false,"name":"removeMemoryBlock","comment":"Remove the memory block.\n NOTE: ALL ANNOTATION (disassembly, comments, etc) defined in this\n memory block will also be removed!","params":[{"type_long":"ghidra.program.model.mem.MemoryBlock","name":"block","comment":"the block to be removed","type_short":"MemoryBlock"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a label at the specified address in the global namespace.\n If makePrimary==true, then the new label is made primary.\n@param address the address to create the symbol\n@param name the name of the symbol\n@param makePrimary true if the symbol should be made primary\n@return the newly created symbol","static":false,"name":"createLabel","comment":"Creates a label at the specified address in the global namespace.\n If makePrimary==true, then the new label is made primary.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the symbol","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol","type_short":"String"},{"type_long":"boolean","name":"makePrimary","comment":"true if the symbol should be made primary","type_short":"boolean"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the newly created symbol","type_short":"Symbol"}},{"javadoc":"@deprecated use {@link #createLabel(Address, String, boolean)} instead.\n Deprecated in Ghidra 7.4","static":false,"name":"createSymbol","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"boolean","name":"makePrimary","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Creates a label at the specified address in the global namespace.\n If makePrimary==true, then the new label is made primary.\n If makeUnique==true, then if the name is a duplicate, the address\n will be concatenated to name to make it unique.\n@param address the address to create the symbol\n@param name the name of the symbol\n@param makePrimary true if the symbol should be made primary\n@param sourceType the source type.\n@return the newly created symbol","static":false,"name":"createLabel","comment":"Creates a label at the specified address in the global namespace.\n If makePrimary==true, then the new label is made primary.\n If makeUnique==true, then if the name is a duplicate, the address\n will be concatenated to name to make it unique.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the symbol","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol","type_short":"String"},{"type_long":"boolean","name":"makePrimary","comment":"true if the symbol should be made primary","type_short":"boolean"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"sourceType","comment":"the source type.","type_short":"SourceType"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the newly created symbol","type_short":"Symbol"}},{"javadoc":"@deprecated use {@link #createLabel(Address, String, boolean, SourceType)} instead. Deprecated in Ghidra 7.4","static":false,"name":"createSymbol","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"boolean","name":"makePrimary","comment":"","type_short":"boolean"},{"type_long":"boolean","name":"makeUnique","comment":"","type_short":"boolean"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"sourceType","comment":"","type_short":"SourceType"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Adds an entry point at the specified address.\n@param address address to create entry point","static":false,"name":"addEntryPoint","comment":"Adds an entry point at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"address to create entry point","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the entry point at the specified address.\n@param address address of entry point to remove","static":false,"name":"removeEntryPoint","comment":"Removes the entry point at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"address of entry point to remove","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Deletes the symbol with the specified name at the specified address.\n@param address the address of the symbol to delete\n@param name the name of the symbol to delete\n@return true if the symbol was deleted","static":false,"name":"removeSymbol","comment":"Deletes the symbol with the specified name at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the symbol to delete","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to delete","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the symbol was deleted","type_short":"boolean"}},{"javadoc":"Sets a PLATE comment at the specified address\n@param address the address to set the PLATE comment\n@param comment the PLATE comment\n@return true if the PLATE comment was successfully set","static":false,"name":"setPlateComment","comment":"Sets a PLATE comment at the specified address","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the PLATE comment","type_short":"Address"},{"type_long":"java.lang.String","name":"comment","comment":"the PLATE comment","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the PLATE comment was successfully set","type_short":"boolean"}},{"javadoc":"Sets a PRE comment at the specified address\n@param address the address to set the PRE comment\n@param comment the PRE comment\n@return true if the PRE comment was successfully set","static":false,"name":"setPreComment","comment":"Sets a PRE comment at the specified address","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the PRE comment","type_short":"Address"},{"type_long":"java.lang.String","name":"comment","comment":"the PRE comment","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the PRE comment was successfully set","type_short":"boolean"}},{"javadoc":"Sets a POST comment at the specified address\n@param address the address to set the POST comment\n@param comment the POST comment\n@return true if the POST comment was successfully set","static":false,"name":"setPostComment","comment":"Sets a POST comment at the specified address","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the POST comment","type_short":"Address"},{"type_long":"java.lang.String","name":"comment","comment":"the POST comment","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the POST comment was successfully set","type_short":"boolean"}},{"javadoc":"Sets a EOL comment at the specified address\n@param address the address to set the EOL comment\n@param comment the EOL comment\n@return true if the EOL comment was successfully set","static":false,"name":"setEOLComment","comment":"Sets a EOL comment at the specified address","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the EOL comment","type_short":"Address"},{"type_long":"java.lang.String","name":"comment","comment":"the EOL comment","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the EOL comment was successfully set","type_short":"boolean"}},{"javadoc":"Returns the PLATE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link #getPlateCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the PLATE comment at the specified address or null\n if one does not exist\n@see #getPlateCommentAsRendered(Address)","static":false,"name":"getPlateComment","comment":"Returns the PLATE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling #getPlateCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to get the comment","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the PLATE comment at the specified address or null\n if one does not exist","type_short":"String"}},{"javadoc":"Returns the PRE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link #getPreCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the PRE comment at the specified address or null\n if one does not exist\n@see #getPreCommentAsRendered(Address)","static":false,"name":"getPreComment","comment":"Returns the PRE comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling #getPreCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to get the comment","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the PRE comment at the specified address or null\n if one does not exist","type_short":"String"}},{"javadoc":"Returns the POST comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link #getPostCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the POST comment at the specified address or null\n if one does not exist\n@see #getPostCommentAsRendered(Address)","static":false,"name":"getPostComment","comment":"Returns the POST comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling #getPostCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to get the comment","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the POST comment at the specified address or null\n if one does not exist","type_short":"String"}},{"javadoc":"Returns the EOL comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling {@link #getEOLCommentAsRendered(Address)} will\n return the text of the comment as it is rendered in the display.\n@param address the address to get the comment\n@return the EOL comment at the specified address or null\n if one does not exist\n@see #getEOLCommentAsRendered(Address)","static":false,"name":"getEOLComment","comment":"Returns the EOL comment at the specified address.  The comment returned is the raw text\n of the comment.  Contrastingly, calling #getEOLCommentAsRendered(Address) will\n return the text of the comment as it is rendered in the display.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to get the comment","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the EOL comment at the specified address or null\n if one does not exist","type_short":"String"}},{"javadoc":"Finds the first occurrence of the byte\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.\n@param start the address to start searching\n@param value the byte to search for\n@return the first address where the byte was found","static":false,"name":"find","comment":"Finds the first occurrence of the byte\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the address to start searching","type_short":"Address"},{"type_long":"byte","name":"value","comment":"the byte to search for","type_short":"byte"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the first address where the byte was found","type_short":"Address"}},{"javadoc":"Finds the first occurrence of the byte array sequence\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.\n@param start the address to start searching\n@param values the byte array sequence to search for\n@return the first address where the byte was found, or\n null if the bytes were not found","static":false,"name":"find","comment":"Finds the first occurrence of the byte array sequence\n starting from the address. If the start address\n is null, then the find will start from the minimum address\n of the program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the address to start searching","type_short":"Address"},{"type_long":"byte[]","name":"values","comment":"the byte array sequence to search for","type_short":"byte[]"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the first address where the byte was found, or\n null if the bytes were not found","type_short":"Address"}},{"javadoc":"Finds the first occurrence of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n <p>\n The <tt>byteString<\/tt> may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n <pre>\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n <\/pre>\n@param start the address to start searching.  If null, then the start of the program\n        will be used.\n@param byteString the byte pattern for which to search\n@return the first address where the byte was found, or null if the bytes were not found\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String, int)","static":false,"name":"findBytes","comment":"Finds the first occurrence of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the address to start searching.  If null, then the start of the program\n        will be used.","type_short":"Address"},{"type_long":"java.lang.String","name":"byteString","comment":"the byte pattern for which to search","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the first address where the byte was found, or null if the bytes were not found","type_short":"Address"}},{"javadoc":"Finds the first <matchLimit> occurrences of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n <p>\n The <tt>byteString<\/tt> may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n <pre>\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n <\/pre>\n@param start the address to start searching.  If null, then the start of the program\n        will be used.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)","static":false,"name":"findBytes","comment":"Finds the first  occurrences of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the address to start searching.  If null, then the start of the program\n        will be used.","type_short":"Address"},{"type_long":"java.lang.String","name":"byteString","comment":"the byte pattern for which to search","type_short":"String"},{"type_long":"int","name":"matchLimit","comment":"The number of matches to which the search should be restricted","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address[]","comment":"the start addresses that contain byte patterns that match the given byteString","type_short":"ghidra.program.model.address.Address[]"}},{"javadoc":"Finds the first <matchLimit> occurrences of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n <p>\n The <tt>byteString<\/tt> may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n <pre>\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n <\/pre>\n@param start the address to start searching.  If null, then the start of the program\n        will be used.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@param alignment byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary.\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)","static":false,"name":"findBytes","comment":"Finds the first  occurrences of the byte array sequence that matches the given byte string,\n starting from the address. If the start address is null, then the find will start\n from the minimum address of the program.\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the address to start searching.  If null, then the start of the program\n        will be used.","type_short":"Address"},{"type_long":"java.lang.String","name":"byteString","comment":"the byte pattern for which to search","type_short":"String"},{"type_long":"int","name":"matchLimit","comment":"The number of matches to which the search should be restricted","type_short":"int"},{"type_long":"int","name":"alignment","comment":"byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address[]","comment":"the start addresses that contain byte patterns that match the given byteString","type_short":"ghidra.program.model.address.Address[]"}},{"javadoc":"Finds a byte pattern within an addressSet.\n\n Note: The ranges within the addressSet are NOT treated as a contiguous set when searching\n <p>\n The <tt>byteString<\/tt> may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n <pre>\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n <\/pre>\n@param set the addressSet specifying which addresses to search.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@param alignment byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary.\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)","static":false,"name":"findBytes","comment":"Finds a byte pattern within an addressSet.\n\n Note: The ranges within the addressSet are NOT treated as a contiguous set when searching\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"the addressSet specifying which addresses to search.","type_short":"AddressSetView"},{"type_long":"java.lang.String","name":"byteString","comment":"the byte pattern for which to search","type_short":"String"},{"type_long":"int","name":"matchLimit","comment":"The number of matches to which the search should be restricted","type_short":"int"},{"type_long":"int","name":"alignment","comment":"byte alignment to use for search starts. For example, a value of\n    1 searches from every byte.  A value of 2 only matches runs that begin on a even\n    address boundary.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address[]","comment":"the start addresses that contain byte patterns that match the given byteString","type_short":"ghidra.program.model.address.Address[]"}},{"javadoc":"Finds a byte pattern within an addressSet.\n\n Note: When searchAcrossAddressGaps is set to true, the ranges within the addressSet are\n treated as a contiguous set when searching.\n\n <p>\n The <tt>byteString<\/tt> may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n <pre>\n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n <\/pre>\n@param set the addressSet specifying which addresses to search.\n@param byteString the byte pattern for which to search\n@param matchLimit The number of matches to which the search should be restricted\n@param alignment byte alignment to use for search starts. For example, a value of\n        1 searches from every byte.  A value of 2 only matches runs that begin on a even\n        address boundary.\n@param searchAcrossAddressGaps when set to 'true' searches for matches across the gaps\n        of each addressRange contained in the addresSet.\n@return the start addresses that contain byte patterns that match the given byteString\n@throws IllegalArgumentException if the byteString is not a valid regular expression\n@see #findBytes(Address, String)","static":false,"name":"findBytes","comment":"Finds a byte pattern within an addressSet.\n\n Note: When searchAcrossAddressGaps is set to true, the ranges within the addressSet are\n treated as a contiguous set when searching.\n\n \n The byteString may contain regular expressions.  The following\n highlights some example search strings (note the use of double backslashes (\"\\\\\")):\n \n             \"\\\\x80\" - A basic search pattern for a byte value of 0x80\n \"\\\\x50.{0,10}\\\\x55\" - A regular expression string that searches for the byte 0x50\n                       followed by 0-10 occurrences of any byte value, followed\n                       by the byte 0x55\n ","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"the addressSet specifying which addresses to search.","type_short":"AddressSetView"},{"type_long":"java.lang.String","name":"byteString","comment":"the byte pattern for which to search","type_short":"String"},{"type_long":"int","name":"matchLimit","comment":"The number of matches to which the search should be restricted","type_short":"int"},{"type_long":"int","name":"alignment","comment":"byte alignment to use for search starts. For example, a value of\n        1 searches from every byte.  A value of 2 only matches runs that begin on a even\n        address boundary.","type_short":"int"},{"type_long":"boolean","name":"searchAcrossAddressGaps","comment":"when set to 'true' searches for matches across the gaps\n        of each addressRange contained in the addresSet.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address[]","comment":"the start addresses that contain byte patterns that match the given byteString","type_short":"ghidra.program.model.address.Address[]"}},{"javadoc":"Finds the first occurrence of 'text' in the program listing.\n The search order is defined as:\n <ol>\n <li>PLATE comments<\/li>\n <li>PRE comments<\/li>\n <li>labels<\/li>\n <li>code unit mnemonics and operands<\/li>\n <li>EOL comments<\/li>\n <li>repeatable comments<\/li>\n <li>POST comments<\/li>\n <\/ol>\n@param text the text to search for\n@return the first address where the 'text' was found, or null\n  if the text was not found","static":false,"name":"find","comment":"Finds the first occurrence of 'text' in the program listing.\n The search order is defined as:\n \n PLATE comments\n PRE comments\n labels\n code unit mnemonics and operands\n EOL comments\n repeatable comments\n POST comments\n ","params":[{"type_long":"java.lang.String","name":"text","comment":"the text to search for","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the first address where the 'text' was found, or null\n  if the text was not found","type_short":"Address"}},{"javadoc":"Search for sequences of Ascii strings in program memory.  See {@link AsciiCharSetRecognizer}\n to see exactly what chars are considered ASCII for purposes of this search.\n@param addressSet The address set to search. Use null to search all memory;\n@param minimumStringLength The smallest number of chars in a sequence to be considered a \"string\".\n@param alignment specifies any alignment requirements for the start of the string.  An alignment\n of 1, means the string can start at any address.  An alignment of 2 means the string must\n start on an even address and so on.  Only allowed values are 1,2, and 4.\n@param requireNullTermination If true, only strings that end in a null will be returned.\n@param includeAllCharWidths if true, UTF16 and UTF32 size strings will be included in addition to UTF8.\n@return a list of \"FoundString\" objects which contain the addresses, length, and type of possible strings.","static":false,"name":"findStrings","comment":"Search for sequences of Ascii strings in program memory.  See AsciiCharSetRecognizer\n to see exactly what chars are considered ASCII for purposes of this search.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addressSet","comment":"The address set to search. Use null to search all memory;","type_short":"AddressSetView"},{"type_long":"int","name":"minimumStringLength","comment":"The smallest number of chars in a sequence to be considered a \"string\".","type_short":"int"},{"type_long":"int","name":"alignment","comment":"specifies any alignment requirements for the start of the string.  An alignment\n of 1, means the string can start at any address.  An alignment of 2 means the string must\n start on an even address and so on.  Only allowed values are 1,2, and 4.","type_short":"int"},{"type_long":"boolean","name":"requireNullTermination","comment":"If true, only strings that end in a null will be returned.","type_short":"boolean"},{"type_long":"boolean","name":"includeAllCharWidths","comment":"if true, UTF16 and UTF32 size strings will be included in addition to UTF8.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.util.string.FoundString>","comment":"a list of \"FoundString\" objects which contain the addresses, length, and type of possible strings.","type_short":"List"}},{"javadoc":"Search for sequences of Pascal Ascii strings in program memory.  See {@link AsciiCharSetRecognizer}\n to see exactly what chars are considered ASCII for purposes of this search.\n@param addressSet The address set to search. Use null to search all memory;\n@param minimumStringLength The smallest number of chars in a sequence to be considered a \"string\".\n@param alignment specifies any alignment requirements for the start of the string.  An alignment\n of 1, means the string can start at any address.  An alignment of 2 means the string must\n start on an even address and so on.  Only allowed values are 1,2, and 4.\n@param includePascalUnicode if true, UTF16 size strings will be included in addition to UTF8.\n@return a list of \"FoundString\" objects which contain the addresses, length, and type of possible strings.","static":false,"name":"findPascalStrings","comment":"Search for sequences of Pascal Ascii strings in program memory.  See AsciiCharSetRecognizer\n to see exactly what chars are considered ASCII for purposes of this search.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addressSet","comment":"The address set to search. Use null to search all memory;","type_short":"AddressSetView"},{"type_long":"int","name":"minimumStringLength","comment":"The smallest number of chars in a sequence to be considered a \"string\".","type_short":"int"},{"type_long":"int","name":"alignment","comment":"specifies any alignment requirements for the start of the string.  An alignment\n of 1, means the string can start at any address.  An alignment of 2 means the string must\n start on an even address and so on.  Only allowed values are 1,2, and 4.","type_short":"int"},{"type_long":"boolean","name":"includePascalUnicode","comment":"if true, UTF16 size strings will be included in addition to UTF8.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.util.string.FoundString>","comment":"a list of \"FoundString\" objects which contain the addresses, length, and type of possible strings.","type_short":"List"}},{"javadoc":"Creates a function at entry point with the specified name\n@param entryPoint the entry point of the function\n@param name the name of the function or null for a default function\n@return the new function or null if the function was not created","static":false,"name":"createFunction","comment":"Creates a function at entry point with the specified name","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"the entry point of the function","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the name of the function or null for a default function","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the new function or null if the function was not created","type_short":"Function"}},{"javadoc":"Removes the function from the current program.\n@param function the function to remove","static":false,"name":"removeFunction","comment":"Removes the function from the current program.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"the function to remove","type_short":"Function"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the function with the given entry point.\n@param entryPoint the entry point of the function to remove","static":false,"name":"removeFunctionAt","comment":"Removes the function with the given entry point.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"the entry point of the function to remove","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the function with the specified entry point, or\n null if no function exists.\n@param entryPoint the function entry point address\n@return the function with the specified entry point, or\n null if no function exists","static":false,"name":"getFunctionAt","comment":"Returns the function with the specified entry point, or\n null if no function exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"the function entry point address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function with the specified entry point, or\n null if no function exists","type_short":"Function"}},{"javadoc":"Returns the function containing the specified address.\n@param address the address\n@return the function containing the specified address","static":false,"name":"getFunctionContaining","comment":"Returns the function containing the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function containing the specified address","type_short":"Function"}},{"javadoc":"Returns the function defined before the specified function in address order.\n@param function the function\n@return the function defined before the specified function","static":false,"name":"getFunctionBefore","comment":"Returns the function defined before the specified function in address order.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"the function","type_short":"Function"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function defined before the specified function","type_short":"Function"}},{"javadoc":"Returns the function defined before the specified address.\n@param address the address\n@return the function defined before the specified address","static":false,"name":"getFunctionBefore","comment":"Returns the function defined before the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function defined before the specified address","type_short":"Function"}},{"javadoc":"Returns the function defined before the specified function in address order.\n@param function the function\n@return the function defined before the specified function","static":false,"name":"getFunctionAfter","comment":"Returns the function defined before the specified function in address order.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"the function","type_short":"Function"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function defined before the specified function","type_short":"Function"}},{"javadoc":"Returns the function defined after the specified address.\n@param address the address\n@return the function defined after the specified address","static":false,"name":"getFunctionAfter","comment":"Returns the function defined after the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function defined after the specified address","type_short":"Function"}},{"javadoc":"Returns the function with the specified name, or\n null if no function exists. (Now returns the first one it finds with that name)\n@param name the name of the function\n@return the function with the specified name, or\n null if no function exists\n@deprecated this method makes no sense in the new world order where function  names\n \t\t\t   no longer have to be unique. Use {@link #getGlobalFunctions(String)}\n \t\t\t   Deprecated in Ghidra 7.4","static":false,"name":"getFunction","comment":"Returns the function with the specified name, or\n null if no function exists. (Now returns the first one it finds with that name)","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the function","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function with the specified name, or\n null if no function exists","type_short":"Function"}},{"javadoc":"Returns a list of all functions in the global namespace with the given name.\n@param name the name of the function\n@return the function with the specified name, or","static":false,"name":"getGlobalFunctions","comment":"Returns a list of all functions in the global namespace with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the function","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.listing.Function>","comment":"the function with the specified name, or","type_short":"List"}},{"javadoc":"Returns the first function in the current program.\n@return the first function in the current program","static":false,"name":"getFirstFunction","comment":"Returns the first function in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the first function in the current program","type_short":"Function"}},{"javadoc":"Returns the last function in the current program.\n@return the last function in the current program","static":false,"name":"getLastFunction","comment":"Returns the last function in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the last function in the current program","type_short":"Function"}},{"javadoc":"Returns the first instruction in the current program.\n@return the first instruction in the current program","static":false,"name":"getFirstInstruction","comment":"Returns the first instruction in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the first instruction in the current program","type_short":"Instruction"}},{"javadoc":"Returns the first instruction in the function.\n@return the first instruction in the function","static":false,"name":"getFirstInstruction","comment":"Returns the first instruction in the function.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"","type_short":"Function"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the first instruction in the function","type_short":"Instruction"}},{"javadoc":"Returns the last instruction in the current program.\n@return the last instruction in the current program","static":false,"name":"getLastInstruction","comment":"Returns the last instruction in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the last instruction in the current program","type_short":"Instruction"}},{"javadoc":"Returns the instruction at the specified address or null if no instruction exists.\n@param address the instruction address\n@return the instruction at the specified address or null if no instruction exists","static":false,"name":"getInstructionAt","comment":"Returns the instruction at the specified address or null if no instruction exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the instruction address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the instruction at the specified address or null if no instruction exists","type_short":"Instruction"}},{"javadoc":"Returns the instruction containing the specified address or null if no instruction exists.\n@param address the instruction address\n@return the instruction containing the specified address or null if no instruction exists","static":false,"name":"getInstructionContaining","comment":"Returns the instruction containing the specified address or null if no instruction exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the instruction address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the instruction containing the specified address or null if no instruction exists","type_short":"Instruction"}},{"javadoc":"Returns the instruction defined before the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param instruction the instruction\n@return the instruction defined before the specified instruction or null if no instruction exists","static":false,"name":"getInstructionBefore","comment":"Returns the instruction defined before the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the instruction defined before the specified instruction or null if no instruction exists","type_short":"Instruction"}},{"javadoc":"Returns the instruction defined before the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param instruction the instruction\n@return the instruction defined before the specified address or null if no instruction exists","static":false,"name":"getInstructionBefore","comment":"Returns the instruction defined before the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the instruction defined before the specified address or null if no instruction exists","type_short":"Instruction"}},{"javadoc":"Returns the instruction defined after the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param instruction the instruction\n@return the instruction defined after the specified instruction or null if no instruction exists","static":false,"name":"getInstructionAfter","comment":"Returns the instruction defined after the specified instruction or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the instruction defined after the specified instruction or null if no instruction exists","type_short":"Instruction"}},{"javadoc":"Returns the instruction defined after the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.\n@param instruction the instruction\n@return the instruction defined after the specified address or null if no instruction exists","static":false,"name":"getInstructionAfter","comment":"Returns the instruction defined after the specified address or null\n if no instruction exists.\n The instruction that is returned does not have to be contiguous.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the instruction defined after the specified address or null if no instruction exists","type_short":"Instruction"}},{"javadoc":"Returns the first defined data in the current program.\n@return the first defined data in the current program","static":false,"name":"getFirstData","comment":"Returns the first defined data in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the first defined data in the current program","type_short":"Data"}},{"javadoc":"Returns the last defined data in the current program.\n@return the last defined data in the current program","static":false,"name":"getLastData","comment":"Returns the last defined data in the current program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the last defined data in the current program","type_short":"Data"}},{"javadoc":"Returns the defined data at the specified address or null if no data exists.\n@param address the data address\n@return the data at the specified address or null if no data exists","static":false,"name":"getDataAt","comment":"Returns the defined data at the specified address or null if no data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the data at the specified address or null if no data exists","type_short":"Data"}},{"javadoc":"Returns the defined data containing the specified address or null if no data exists.\n@param address the data address\n@return the defined data containing the specified address or null if no data exists","static":false,"name":"getDataContaining","comment":"Returns the defined data containing the specified address or null if no data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the defined data containing the specified address or null if no data exists","type_short":"Data"}},{"javadoc":"Returns the defined data before the specified data or null if no data exists.\n@param address the data address\n@return the defined data before the specified data or null if no data exists","static":false,"name":"getDataBefore","comment":"Returns the defined data before the specified data or null if no data exists.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"","type_short":"Data"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the defined data before the specified data or null if no data exists","type_short":"Data"}},{"javadoc":"Returns the defined data before the specified address or null if no data exists.\n@param address the data address\n@return the defined data before the specified address or null if no data exists","static":false,"name":"getDataBefore","comment":"Returns the defined data before the specified address or null if no data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the defined data before the specified address or null if no data exists","type_short":"Data"}},{"javadoc":"Returns the defined data after the specified data or null if no data exists.\n@param address the data address\n@return the defined data after the specified data or null if no data exists","static":false,"name":"getDataAfter","comment":"Returns the defined data after the specified data or null if no data exists.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"","type_short":"Data"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the defined data after the specified data or null if no data exists","type_short":"Data"}},{"javadoc":"Returns the defined data after the specified address or null if no data exists.\n@param address the data address\n@return the defined data after the specified address or null if no data exists","static":false,"name":"getDataAfter","comment":"Returns the defined data after the specified address or null if no data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the defined data after the specified address or null if no data exists","type_short":"Data"}},{"javadoc":"Returns the undefined data at the specified address or null if no undefined data exists.\n@param address the undefined data address\n@return the undefined data at the specified address or null if no undefined data exists","static":false,"name":"getUndefinedDataAt","comment":"Returns the undefined data at the specified address or null if no undefined data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the undefined data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the undefined data at the specified address or null if no undefined data exists","type_short":"Data"}},{"javadoc":"Returns the undefined data before the specified address or null if no undefined data exists.\n@param address the undefined data address\n@return the undefined data before the specified address or null if no undefined data exists","static":false,"name":"getUndefinedDataBefore","comment":"Returns the undefined data before the specified address or null if no undefined data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the undefined data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the undefined data before the specified address or null if no undefined data exists","type_short":"Data"}},{"javadoc":"Returns the undefined data after the specified address or null if no undefined data exists.\n@param address the undefined data address\n@return the undefined data after the specified address or null if no undefined data exists","static":false,"name":"getUndefinedDataAfter","comment":"Returns the undefined data after the specified address or null if no undefined data exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the undefined data address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the undefined data after the specified address or null if no undefined data exists","type_short":"Data"}},{"javadoc":"Returns the symbol with the specified address and name, or\n null if no symbol exists.\n@param address the symbol address\n@param name the symbol name\n@return the symbol with the specified address and name, or\n null if no symbol exists\n@deprecated Since the same label name can be at the same address if in a different namespace,\n this method is ambiguous. Use {@link #getSymbolAt(Address, String, Namespace)} instead.","static":false,"name":"getSymbolAt","comment":"Returns the symbol with the specified address and name, or\n null if no symbol exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the symbol address","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the symbol name","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the symbol with the specified address and name, or\n null if no symbol exists","type_short":"Symbol"}},{"javadoc":"Returns the symbol with the specified address, name, and namespace\n@param address the symbol address\n@param name the symbol name\n@param namespace the parent namespace for the symbol.\n@return the symbol with the specified address, name, and namespace, or\n null if no symbol exists","static":false,"name":"getSymbolAt","comment":"Returns the symbol with the specified address, name, and namespace","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the symbol address","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the symbol name","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the parent namespace for the symbol.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the symbol with the specified address, name, and namespace, or\n null if no symbol exists","type_short":"Symbol"}},{"javadoc":"Returns the next non-default primary symbol defined\n after the given symbol.\n@param symbol the symbol to use as a starting point\n@return the next non-default primary symbol","static":false,"name":"getSymbolAfter","comment":"Returns the next non-default primary symbol defined\n after the given symbol.","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"symbol","comment":"the symbol to use as a starting point","type_short":"Symbol"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the next non-default primary symbol","type_short":"Symbol"}},{"javadoc":"Returns the next non-default primary symbol defined\n after the given address.\n@param address the address to use as a starting point\n@return the next non-default primary symbol","static":false,"name":"getSymbolAfter","comment":"Returns the next non-default primary symbol defined\n after the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to use as a starting point","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the next non-default primary symbol","type_short":"Symbol"}},{"javadoc":"Returns the previous non-default primary symbol defined\n before the given symbol.\n@param symbol the symbol to use as a starting point\n@return the previous non-default primary symbol","static":false,"name":"getSymbolBefore","comment":"Returns the previous non-default primary symbol defined\n before the given symbol.","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"symbol","comment":"the symbol to use as a starting point","type_short":"Symbol"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the previous non-default primary symbol","type_short":"Symbol"}},{"javadoc":"Returns the previous non-default primary symbol defined\n after the previous address.\n@param symbol the symbol to use as a starting point\n@return the next non-default primary symbol","static":false,"name":"getSymbolBefore","comment":"Returns the previous non-default primary symbol defined\n after the previous address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the next non-default primary symbol","type_short":"Symbol"}},{"javadoc":"Returns the PRIMARY symbol at the specified address, or\n null if no symbol exists.\n@param address the symbol address\n@return the PRIMARY symbol at the specified address, or\n null if no symbol exists","static":false,"name":"getSymbolAt","comment":"Returns the PRIMARY symbol at the specified address, or\n null if no symbol exists.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the symbol address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the PRIMARY symbol at the specified address, or\n null if no symbol exists","type_short":"Symbol"}},{"javadoc":"Returns the symbol with the given name in the given namespace if there is only one.\n Pass <code>null<\/code> for namespace to indicate the global namespace.\n@param name the name of the symbol\n@param namespace the parent namespace, or null for global namespace\n@return the symbol with the given name in the given namespace\n@throws IllegalStateException if there is more than one symbol with that name.\n@deprecated use {@link #getSymbols(String, Namespace)}","static":false,"name":"getSymbol","comment":"Returns the symbol with the given name in the given namespace if there is only one.\n Pass null for namespace to indicate the global namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the parent namespace, or null for global namespace","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the symbol with the given name in the given namespace","type_short":"Symbol"}},{"javadoc":"Returns a list of all the symbols with the given name in the given namespace.\n@param name the name of the symbols to retrieve.\n@param namespace the namespace containing the symbols, or null for the global namespace.\n@return a list of all the symbols with the given name in the given namespace.","static":false,"name":"getSymbols","comment":"Returns a list of all the symbols with the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbols to retrieve.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace containing the symbols, or null for the global namespace.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"a list of all the symbols with the given name in the given namespace.","type_short":"List"}},{"javadoc":"Returns the non-function namespace with the given name contained inside the\n specified parent namespace.\n Pass <code>null<\/code> for namespace to indicate the global namespace.\n@param parent the parent namespace, or null for global namespace\n@param namespaceName the requested namespace's name\n@return the namespace with the given name or null if not found","static":false,"name":"getNamespace","comment":"Returns the non-function namespace with the given name contained inside the\n specified parent namespace.\n Pass null for namespace to indicate the global namespace.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"parent","comment":"the parent namespace, or null for global namespace","type_short":"Namespace"},{"type_long":"java.lang.String","name":"namespaceName","comment":"the requested namespace's name","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"the namespace with the given name or null if not found","type_short":"Namespace"}},{"javadoc":"Creates a fragment in the root folder of the default program tree.\n@param fragmentName the name of the fragment\n@param start the start address\n@param end the end address (NOT INCLUSIVE)\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program\n@deprecated This method is deprecated because it did not allow you to include the\n largest possible address.  Instead use the one that takes a start address and a length.","static":false,"name":"createFragment","comment":"Creates a fragment in the root folder of the default program tree.","params":[{"type_long":"java.lang.String","name":"fragmentName","comment":"the name of the fragment","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end address (NOT INCLUSIVE)","type_short":"Address"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the given fragment name already exists","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"if any address in the fragment would be outside of the program","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.program.model.listing.ProgramFragment","comment":"the newly created fragment","type_short":"ProgramFragment"}},{"javadoc":"Creates a fragment in the root folder of the default program tree.\n@param fragmentName the name of the fragment\n@param start the start address\n@param length the length of the fragment\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program","static":false,"name":"createFragment","comment":"Creates a fragment in the root folder of the default program tree.","params":[{"type_long":"java.lang.String","name":"fragmentName","comment":"the name of the fragment","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address","type_short":"Address"},{"type_long":"long","name":"length","comment":"the length of the fragment","type_short":"long"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the given fragment name already exists","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"if any address in the fragment would be outside of the program","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.program.model.listing.ProgramFragment","comment":"the newly created fragment","type_short":"ProgramFragment"}},{"javadoc":"Creates a fragment in the given folder of the default program tree.\n@param module the parent module (or folder)\n@param fragmentName the name of the fragment\n@param start the start address\n@param end the end address (NOT INCLUSIVE)\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program\n@deprecated This method is deprecated because it did not allow you to include the\n largest possible address.  Instead use the one that takes a start address and a length.","static":false,"name":"createFragment","comment":"Creates a fragment in the given folder of the default program tree.","params":[{"type_long":"ghidra.program.model.listing.ProgramModule","name":"module","comment":"the parent module (or folder)","type_short":"ProgramModule"},{"type_long":"java.lang.String","name":"fragmentName","comment":"the name of the fragment","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the end address (NOT INCLUSIVE)","type_short":"Address"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the given fragment name already exists","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"if any address in the fragment would be outside of the program","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.program.model.listing.ProgramFragment","comment":"the newly created fragment","type_short":"ProgramFragment"}},{"javadoc":"Creates a fragment in the given folder of the default program tree.\n@param module the parent module (or folder)\n@param fragmentName the name of the fragment\n@param start the start address\n@param length the length of the fragment\n@return the newly created fragment\n@throws DuplicateNameException if the given fragment name already exists\n@throws NotFoundException if any address in the fragment would be outside of the program","static":false,"name":"createFragment","comment":"Creates a fragment in the given folder of the default program tree.","params":[{"type_long":"ghidra.program.model.listing.ProgramModule","name":"module","comment":"the parent module (or folder)","type_short":"ProgramModule"},{"type_long":"java.lang.String","name":"fragmentName","comment":"the name of the fragment","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address","type_short":"Address"},{"type_long":"long","name":"length","comment":"the length of the fragment","type_short":"long"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the given fragment name already exists","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.NotFoundException","comment":"if any address in the fragment would be outside of the program","type_short":"NotFoundException"}],"return":{"type_long":"ghidra.program.model.listing.ProgramFragment","comment":"the newly created fragment","type_short":"ProgramFragment"}},{"javadoc":"Returns the fragment with the specified name\n defined in the given module.\n@param module the parent module\n@param fragmentName the fragment name\n@return the fragment or null if one does not exist","static":false,"name":"getFragment","comment":"Returns the fragment with the specified name\n defined in the given module.","params":[{"type_long":"ghidra.program.model.listing.ProgramModule","name":"module","comment":"the parent module","type_short":"ProgramModule"},{"type_long":"java.lang.String","name":"fragmentName","comment":"the fragment name","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.ProgramFragment","comment":"the fragment or null if one does not exist","type_short":"ProgramFragment"}},{"javadoc":"Creates a new mutable address set.\n@return a new mutable address set","static":false,"name":"createAddressSet","comment":"Creates a new mutable address set.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"a new mutable address set","type_short":"AddressSet"}},{"javadoc":"","static":false,"name":"getAddressFactory","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressFactory","comment":"","type_short":"AddressFactory"}},{"javadoc":"Searches through the datatype manager of the current program and\n returns an array of datatypes that match the specified name.\n The datatype manager supports datatypes of the same name in different categories.\n A zero-length array indicates that no datatypes with the specified name exist.\n@param name the name of the desired datatype\n@return an array of datatypes that match the specified name","static":false,"name":"getDataTypes","comment":"Searches through the datatype manager of the current program and\n returns an array of datatypes that match the specified name.\n The datatype manager supports datatypes of the same name in different categories.\n A zero-length array indicates that no datatypes with the specified name exist.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the desired datatype","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType[]","comment":"an array of datatypes that match the specified name","type_short":"ghidra.program.model.data.DataType[]"}},{"javadoc":"Creates a new defined Data object at the given address.\n@param address the address at which to create a new Data object.\n@param datatype the Data Type that describes the type of Data object to create.\n@return the newly created Data object","static":false,"name":"createData","comment":"Creates a new defined Data object at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address at which to create a new Data object.","type_short":"Address"},{"type_long":"ghidra.program.model.data.DataType","name":"datatype","comment":"the Data Type that describes the type of Data object to create.","type_short":"DataType"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a byte datatype at the given address.\n@param address the address to create the byte\n@return the newly created Data object","static":false,"name":"createByte","comment":"Creates a byte datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the byte","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a word datatype at the given address.\n@param address the address to create the word\n@return the newly created Data object","static":false,"name":"createWord","comment":"Creates a word datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the word","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a dword datatype at the given address.\n@param address the address to create the dword\n@return the newly created Data object","static":false,"name":"createDWord","comment":"Creates a dword datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the dword","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a list of dword datatypes starting at the given address.\n@param start the start address to create the dwords\n@param count the number of dwords to create","static":false,"name":"createDwords","comment":"Creates a list of dword datatypes starting at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the start address to create the dwords","type_short":"Address"},{"type_long":"int","name":"count","comment":"the number of dwords to create","type_short":"int"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a qword datatype at the given address.\n@param address the address to create the qword\n@return the newly created Data object","static":false,"name":"createQWord","comment":"Creates a qword datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the qword","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a float datatype at the given address.\n@param address the address to create the float\n@return the newly created Data object","static":false,"name":"createFloat","comment":"Creates a float datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the float","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a double datatype at the given address.\n@param address the address to create the double\n@return the newly created Data object","static":false,"name":"createDouble","comment":"Creates a double datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the double","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a char datatype at the given address.\n@param address the address to create the char\n@return the newly created Data object","static":false,"name":"createChar","comment":"Creates a char datatype at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the char","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Creates a null terminated ascii string starting\n at the specified address.\n@param address the address to create the string\n@return the newly created Data object","static":false,"name":"createAsciiString","comment":"Creates a null terminated ascii string starting\n at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the string","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Create an ASCII string at the specified address.\n@param address\n@param length length of string (a value of 0 or negative will force use\n of dynamic null terminated string)\n@return string data created\n@throws CodeUnitInsertionException\n@throws DataTypeConflictException","static":false,"name":"createAsciiString","comment":"Create an ASCII string at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"int","name":"length","comment":"length of string (a value of 0 or negative will force use\n of dynamic null terminated string)","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.util.CodeUnitInsertionException","comment":"","type_short":"CodeUnitInsertionException"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"string data created","type_short":"Data"}},{"javadoc":"Creates a null terminated unicode string starting\n at the specified address.\n@param address the address to create the string\n@return the newly created Data object\n@throws Exception","static":false,"name":"createUnicodeString","comment":"Creates a null terminated unicode string starting\n at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the string","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.listing.Data","comment":"the newly created Data object","type_short":"Data"}},{"javadoc":"Removes the given data from the current program.\n@param data the data to remove","static":false,"name":"removeData","comment":"Removes the given data from the current program.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data to remove","type_short":"Data"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the data containing the given address from the current program.\n@param address the address to remove data","static":false,"name":"removeDataAt","comment":"Removes the data containing the given address from the current program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to remove data","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the given instruction from the current program.\n@param instruction the instruction to remove","static":false,"name":"removeInstruction","comment":"Removes the given instruction from the current program.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction to remove","type_short":"Instruction"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the instruction containing the given address from the current program.\n@param address the address to remove instruction","static":false,"name":"removeInstructionAt","comment":"Removes the instruction containing the given address from the current program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to remove instruction","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a cross reference (XREF).\n@param from the source address of the reference\n@param to the destination address of the reference\n@param opIndex the operand index (-1 indicates the mnemonic)\n@param type the flow type\n@return the newly created reference\n@see ghidra.program.model.symbol.FlowType\n@see ghidra.program.model.symbol.Reference","static":false,"name":"addInstructionXref","comment":"Adds a cross reference (XREF).","params":[{"type_long":"ghidra.program.model.address.Address","name":"from","comment":"the source address of the reference","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"to","comment":"the destination address of the reference","type_short":"Address"},{"type_long":"int","name":"opIndex","comment":"the operand index (-1 indicates the mnemonic)","type_short":"int"},{"type_long":"ghidra.program.model.symbol.FlowType","name":"type","comment":"the flow type","type_short":"FlowType"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created reference","type_short":"Reference"}},{"javadoc":"Returns a new address with the specified offset in the default address space.\n@param offset the offset for the new address\n@return a new address with the specified offset in the default address space","static":false,"name":"toAddr","comment":"Returns a new address with the specified offset in the default address space.","params":[{"type_long":"int","name":"offset","comment":"the offset for the new address","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"a new address with the specified offset in the default address space","type_short":"Address"}},{"javadoc":"Returns a new address with the specified offset in the default address space.\n@param offset the offset for the new address\n@return a new address with the specified offset in the default address space","static":false,"name":"toAddr","comment":"Returns a new address with the specified offset in the default address space.","params":[{"type_long":"long","name":"offset","comment":"the offset for the new address","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"a new address with the specified offset in the default address space","type_short":"Address"}},{"javadoc":"Returns a new address inside the specified program as indicated by the string.\n@param p the program to use for determining the address\n@param s string representation of the address desired\n@return the address. Otherwise, return null if the string fails to evaluate\n to a legitimate address","static":false,"name":"toAddr","comment":"Returns a new address inside the specified program as indicated by the string.","params":[{"type_long":"java.lang.String","name":"addressString","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the address. Otherwise, return null if the string fails to evaluate\n to a legitimate address","type_short":"Address"}},{"javadoc":"Returns the 'byte' value at the specified address in memory.\n@param address the address\n@return the 'byte' value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable","static":false,"name":"getByte","comment":"Returns the 'byte' value at the specified address in memory.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the memory is not readable","type_short":"MemoryAccessException"}],"return":{"type_long":"byte","comment":"the 'byte' value at the specified address in memory","type_short":"byte"}},{"javadoc":"Reads length number of bytes starting at the specified address.\n Note: this could be inefficient if length is large\n@param address the address to start reading\n@param length the number of bytes to read\n@return an array of bytes\n@throws MemoryAccessException if memory does not exist or is uninitialized\n@see ghidra.program.model.mem.Memory","static":false,"name":"getBytes","comment":"Reads length number of bytes starting at the specified address.\n Note: this could be inefficient if length is large","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to start reading","type_short":"Address"},{"type_long":"int","name":"length","comment":"the number of bytes to read","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"byte[]","comment":"an array of bytes","type_short":"byte[]"}},{"javadoc":"Sets the 'byte' value at the specified address.\n@param address the address to set the 'byte'\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setByte","comment":"Sets the 'byte' value at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the 'byte'","type_short":"Address"},{"type_long":"byte","name":"value","comment":"the value to set","type_short":"byte"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the 'byte' values starting at the specified address.\n@param address the address to set the bytes\n@param second the values to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setBytes","comment":"Sets the 'byte' values starting at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the bytes","type_short":"Address"},{"type_long":"byte[]","name":"values","comment":"","type_short":"byte[]"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the 'short' value at the specified address in memory.\n@param address the address\n@return the 'short' value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable","static":false,"name":"getShort","comment":"Returns the 'short' value at the specified address in memory.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the memory is not readable","type_short":"MemoryAccessException"}],"return":{"type_long":"short","comment":"the 'short' value at the specified address in memory","type_short":"short"}},{"javadoc":"Sets the 'short' value at the specified address.\n@param address the address to set the 'short'\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setShort","comment":"Sets the 'short' value at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the 'short'","type_short":"Address"},{"type_long":"short","name":"value","comment":"the value to set","type_short":"short"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the 'integer' value at the specified address in memory.\n@param address the address\n@return the 'integer' value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable","static":false,"name":"getInt","comment":"Returns the 'integer' value at the specified address in memory.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the memory is not readable","type_short":"MemoryAccessException"}],"return":{"type_long":"int","comment":"the 'integer' value at the specified address in memory","type_short":"int"}},{"javadoc":"Sets the 'integer' value at the specified address.\n@param address the address to set the 'integer'\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setInt","comment":"Sets the 'integer' value at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the 'integer'","type_short":"Address"},{"type_long":"int","name":"value","comment":"the value to set","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the 'long' value at the specified address in memory.\n@param address the address\n@return the 'long' value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable","static":false,"name":"getLong","comment":"Returns the 'long' value at the specified address in memory.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the memory is not readable","type_short":"MemoryAccessException"}],"return":{"type_long":"long","comment":"the 'long' value at the specified address in memory","type_short":"long"}},{"javadoc":"Sets the 'long' value at the specified address.\n@param address the address to set the 'long'\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setLong","comment":"Sets the 'long' value at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the 'long'","type_short":"Address"},{"type_long":"long","name":"value","comment":"the value to set","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the 'float' value at the specified address in memory.\n@param address the address\n@return the 'float' value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable","static":false,"name":"getFloat","comment":"Returns the 'float' value at the specified address in memory.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the memory is not readable","type_short":"MemoryAccessException"}],"return":{"type_long":"float","comment":"the 'float' value at the specified address in memory","type_short":"float"}},{"javadoc":"Sets the 'float' value at the specified address.\n@param address the address to set the 'float'\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setFloat","comment":"Sets the 'float' value at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the 'float'","type_short":"Address"},{"type_long":"float","name":"value","comment":"the value to set","type_short":"float"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the 'double' value at the specified address in memory.\n@param address the address\n@return the 'double' value at the specified address in memory\n@throws MemoryAccessException if the memory is not readable","static":false,"name":"getDouble","comment":"Returns the 'double' value at the specified address in memory.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if the memory is not readable","type_short":"MemoryAccessException"}],"return":{"type_long":"double","comment":"the 'double' value at the specified address in memory","type_short":"double"}},{"javadoc":"Sets the 'double' value at the specified address.\n@param address the address to set the 'double'\n@param value the value to set\n@throws MemoryAccessException if memory does not exist or is uninitialized","static":false,"name":"setDouble","comment":"Sets the 'double' value at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to set the 'double'","type_short":"Address"},{"type_long":"double","name":"value","comment":"the value to set","type_short":"double"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if memory does not exist or is uninitialized","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns an array of the references FROM the given address.\n@param address the from address of the references\n@return an array of the references FROM the given address","static":false,"name":"getReferencesFrom","comment":"Returns an array of the references FROM the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the from address of the references","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference[]","comment":"an array of the references FROM the given address","type_short":"ghidra.program.model.symbol.Reference[]"}},{"javadoc":"Returns an array of the references TO the given address.\n Note: If more than 4096 references exists to this address,\n only the first 4096 will be returned.\n If you need to access all the references, please\n refer to the method <code>ReferenceManager::getReferencesTo(Address)<\/code>.\n@param address the from address of the references\n@return an array of the references TO the given address","static":false,"name":"getReferencesTo","comment":"Returns an array of the references TO the given address.\n Note: If more than 4096 references exists to this address,\n only the first 4096 will be returned.\n If you need to access all the references, please\n refer to the method ReferenceManager::getReferencesTo(Address).","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the from address of the references","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference[]","comment":"an array of the references TO the given address","type_short":"ghidra.program.model.symbol.Reference[]"}},{"javadoc":"Returns the reference from the instruction to the given address.\n@param instruction the instruction\n@param toAddress the destination address\n@return the reference from the instruction to the given address","static":false,"name":"getReference","comment":"Returns the reference from the instruction to the given address.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"ghidra.program.model.address.Address","name":"toAddress","comment":"the destination address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the reference from the instruction to the given address","type_short":"Reference"}},{"javadoc":"Returns the reference from the data to the given address.\n@param data the data\n@param toAddress the destination address\n@return the reference from the data to the given address","static":false,"name":"getReference","comment":"Returns the reference from the data to the given address.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data","type_short":"Data"},{"type_long":"ghidra.program.model.address.Address","name":"toAddress","comment":"the destination address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the reference from the data to the given address","type_short":"Reference"}},{"javadoc":"Creates a memory reference from the given instruction.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param toAddress the TO address\n@param flowType the flow type of the reference\n@return the newly created memory reference","static":false,"name":"createMemoryReference","comment":"Creates a memory reference from the given instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index on the instruction","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"toAddress","comment":"the TO address","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.RefType","name":"flowType","comment":"the flow type of the reference","type_short":"RefType"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created memory reference","type_short":"Reference"}},{"javadoc":"Creates a memory reference from the given data.\n@param data the data\n@param toAddress the TO address\n@param dataRefType the type of the reference\n@return the newly created memory reference","static":false,"name":"createMemoryReference","comment":"Creates a memory reference from the given data.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data","type_short":"Data"},{"type_long":"ghidra.program.model.address.Address","name":"toAddress","comment":"the TO address","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.RefType","name":"dataRefType","comment":"the type of the reference","type_short":"RefType"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created memory reference","type_short":"Reference"}},{"javadoc":"Creates an external reference from the given instruction.\n For instructions with flow, the FlowType will be assumed, otherwise\n {@link RefType#DATA} will be assumed.  To specify the appropriate\n RefType use the alternate form of this method.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param libraryName the name of the library being referred\n@param externalLabel the name of function in the library being referred\n@param externalAddr the address of the function in the library being referred\n@return the newly created external reference\n@throws Exception if an exception occurs","static":false,"name":"createExternalReference","comment":"Creates an external reference from the given instruction.\n For instructions with flow, the FlowType will be assumed, otherwise\n RefType#DATA will be assumed.  To specify the appropriate\n RefType use the alternate form of this method.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index on the instruction","type_short":"int"},{"type_long":"java.lang.String","name":"libraryName","comment":"the name of the library being referred","type_short":"String"},{"type_long":"java.lang.String","name":"externalLabel","comment":"the name of function in the library being referred","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"externalAddr","comment":"the address of the function in the library being referred","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"if an exception occurs","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created external reference","type_short":"Reference"}},{"javadoc":"Creates an external reference from the given instruction.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param libraryName the name of the library being referred\n@param externalLabel the name of function in the library being referred\n@param externalAddr the address of the function in the library being referred\n@param refType the appropriate external reference type (e.g., DATA, COMPUTED_CALL, etc.)\n@return the newly created external reference\n@throws Exception if an exception occurs","static":false,"name":"createExternalReference","comment":"Creates an external reference from the given instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index on the instruction","type_short":"int"},{"type_long":"java.lang.String","name":"libraryName","comment":"the name of the library being referred","type_short":"String"},{"type_long":"java.lang.String","name":"externalLabel","comment":"the name of function in the library being referred","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"externalAddr","comment":"the address of the function in the library being referred","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"the appropriate external reference type (e.g., DATA, COMPUTED_CALL, etc.)","type_short":"RefType"}],"throws":[{"type_long":"java.lang.Exception","comment":"if an exception occurs","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created external reference","type_short":"Reference"}},{"javadoc":"Creates an external reference from the given data.  The reference type {@link RefType#DATA}\n will be used.\n@param data the data\n@param libraryName the name of the library being referred\n@param externalLabel the name of function in the library being referred\n@param externalAddr the address of the function in the library being referred\n@return the newly created external reference\n@throws Exception if an exception occurs","static":false,"name":"createExternalReference","comment":"Creates an external reference from the given data.  The reference type RefType#DATA\n will be used.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data","type_short":"Data"},{"type_long":"java.lang.String","name":"libraryName","comment":"the name of the library being referred","type_short":"String"},{"type_long":"java.lang.String","name":"externalLabel","comment":"the name of function in the library being referred","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"externalAddr","comment":"the address of the function in the library being referred","type_short":"Address"}],"throws":[{"type_long":"java.lang.Exception","comment":"if an exception occurs","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created external reference","type_short":"Reference"}},{"javadoc":"Create a stack reference from the given instruction\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param stackOffset the stack offset of the reference\n@param isWrite true if the reference is WRITE access or false if the\n reference is READ access\n@return the newly created stack reference","static":false,"name":"createStackReference","comment":"Create a stack reference from the given instruction","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index on the instruction","type_short":"int"},{"type_long":"int","name":"stackOffset","comment":"the stack offset of the reference","type_short":"int"},{"type_long":"boolean","name":"isWrite","comment":"true if the reference is WRITE access or false if the\n reference is READ access","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the newly created stack reference","type_short":"Reference"}},{"javadoc":"Removes the given reference.\n@param reference the reference to remove","static":false,"name":"removeReference","comment":"Removes the given reference.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"reference","comment":"the reference to remove","type_short":"Reference"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the given reference as primary.\n@param reference the reference to mark as primary","static":false,"name":"setReferencePrimary","comment":"Sets the given reference as primary.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"reference","comment":"the reference to mark as primary","type_short":"Reference"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the given reference as primary.\n@param reference the reference\n@param primary true if primary, false not primary","static":false,"name":"setReferencePrimary","comment":"Sets the given reference as primary.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"reference","comment":"the reference","type_short":"Reference"},{"type_long":"boolean","name":"primary","comment":"true if primary, false not primary","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a new equate on the scalar value\n at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index on the instruction\n@param equateName the name of the equate\n@return the newly created equate\n@throws Exception if a scalar does not exist of the specified\n operand index of the instruction","static":false,"name":"createEquate","comment":"Creates a new equate on the scalar value\n at the operand index of the instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index on the instruction","type_short":"int"},{"type_long":"java.lang.String","name":"equateName","comment":"the name of the equate","type_short":"String"}],"throws":[{"type_long":"java.lang.Exception","comment":"if a scalar does not exist of the specified\n operand index of the instruction","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Equate","comment":"the newly created equate","type_short":"Equate"}},{"javadoc":"Creates a new equate on the scalar value\n at the value of the data.\n@param data the data\n@param equateName the name of the equate\n@return the newly created equate\n@throws InvalidInputException if a scalar does not exist on the data","static":false,"name":"createEquate","comment":"Creates a new equate on the scalar value\n at the value of the data.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data","type_short":"Data"},{"type_long":"java.lang.String","name":"equateName","comment":"the name of the equate","type_short":"String"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.symbol.Equate","comment":"the newly created equate","type_short":"Equate"}},{"javadoc":"Returns the equate defined at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index\n@return the equate defined at the operand index of the instruction\n@deprecated this form of getEquate is not supported and will throw a UnsupportedOperationException","static":false,"name":"getEquate","comment":"Returns the equate defined at the operand index of the instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Equate","comment":"the equate defined at the operand index of the instruction","type_short":"Equate"}},{"javadoc":"Returns the equate defined at the operand index of the instruction with the given value.\n@param instruction the instruction\n@param operandIndex the operand index\n@param value scalar equate value\n@return the equate defined at the operand index of the instruction","static":false,"name":"getEquate","comment":"Returns the equate defined at the operand index of the instruction with the given value.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index","type_short":"int"},{"type_long":"long","name":"value","comment":"scalar equate value","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Equate","comment":"the equate defined at the operand index of the instruction","type_short":"Equate"}},{"javadoc":"Returns the equates defined at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index\n@return the equate defined at the operand index of the instruction","static":false,"name":"getEquates","comment":"Returns the equates defined at the operand index of the instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index","type_short":"int"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Equate>","comment":"the equate defined at the operand index of the instruction","type_short":"List"}},{"javadoc":"Returns the equate defined on the data.\n@param data the data\n@return the equate defined on the data","static":false,"name":"getEquate","comment":"Returns the equate defined on the data.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data","type_short":"Data"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Equate","comment":"the equate defined on the data","type_short":"Equate"}},{"javadoc":"Removes the equate defined at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index\n@deprecated this form of getEquate is not supported and will throw a UnsupportedOperationException","static":false,"name":"removeEquate","comment":"Removes the equate defined at the operand index of the instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the equate defined at the operand index of the instruction with the given value.\n@param instruction the instruction\n@param operandIndex the operand index\n@param value scalar value corresponding to equate","static":false,"name":"removeEquate","comment":"Removes the equate defined at the operand index of the instruction with the given value.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index","type_short":"int"},{"type_long":"long","name":"value","comment":"scalar value corresponding to equate","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the equates defined at the operand index of the instruction.\n@param instruction the instruction\n@param operandIndex the operand index\n@param second scalar value corresponding to equate","static":false,"name":"removeEquates","comment":"Removes the equates defined at the operand index of the instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction","type_short":"Instruction"},{"type_long":"int","name":"operandIndex","comment":"the operand index","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the equate defined on the data.\n@param data the data","static":false,"name":"removeEquate","comment":"Removes the equate defined on the data.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"the data","type_short":"Data"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a NOTE book mark at the specified address.\n NOTE: if a NOTE book mark already exists at the\n address with same category, it will be replaced.\n@param address the address to create the book mark\n@param category the book mark category (it can be null)\n@param note the book mark text\n@return the newly created book mark","static":false,"name":"createBookmark","comment":"Creates a NOTE book mark at the specified address.\n NOTE: if a NOTE book mark already exists at the\n address with same category, it will be replaced.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to create the book mark","type_short":"Address"},{"type_long":"java.lang.String","name":"category","comment":"the book mark category (it can be null)","type_short":"String"},{"type_long":"java.lang.String","name":"note","comment":"the book mark text","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Bookmark","comment":"the newly created book mark","type_short":"Bookmark"}},{"javadoc":"Returns all of the NOTE book marks defined at the specified address.\n@param address the address to retrieve the book mark\n@return the book marks at the specified address","static":false,"name":"getBookmarks","comment":"Returns all of the NOTE book marks defined at the specified address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to retrieve the book mark","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Bookmark[]","comment":"the book marks at the specified address","type_short":"ghidra.program.model.listing.Bookmark[]"}},{"javadoc":"Removes the specified book mark.\n@param bookmark the book mark to remove","static":false,"name":"removeBookmark","comment":"Removes the specified book mark.","params":[{"type_long":"ghidra.program.model.listing.Bookmark","name":"bookmark","comment":"the book mark to remove","type_short":"Bookmark"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Opens a Data Type Archive\n@param archiveFile the archive file to open\n@param readOnly should file be opened read only","static":false,"name":"openDataTypeArchive","comment":"Opens a Data Type Archive","params":[{"type_long":"java.io.File","name":"archiveFile","comment":"the archive file to open","type_short":"File"},{"type_long":"boolean","name":"readOnly","comment":"should file be opened read only","type_short":"boolean"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"ghidra.program.model.data.FileDataTypeManager","comment":"","type_short":"FileDataTypeManager"}},{"javadoc":"Saves the changes to the specified program.\n If the program does not already exist in the current project\n then it will be saved into the root folder.\n If a program already exists with the specified\n name, then a time stamp will be appended to the name to make it unique.\n@param program the program to save\n@throws Exception","static":false,"name":"saveProgram","comment":"Saves the changes to the specified program.\n If the program does not already exist in the current project\n then it will be saved into the root folder.\n If a program already exists with the specified\n name, then a time stamp will be appended to the name to make it unique.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to save","type_short":"Program"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Saves changes to the specified program.\n <p>\n If the program does not already exist in the current project\n then it will be saved into a project folder path specified by the path parameter.\n <p>\n If path is NULL, the program will be saved into the root folder.  If parts of the path are\n missing, they will be created if possible.\n <p>\n If a program already exists with the specified name, then a time stamp will be appended \n to the name to make it unique.\n <p>\n@param program the program to save\n@param path list of string path elements (starting at the root of the project) that specify \n the project folder to save the program info.  Example: { \"folder1\", \"subfolder2\", \"finalfolder\" }\n@throws Exception","static":false,"name":"saveProgram","comment":"Saves changes to the specified program.\n \n If the program does not already exist in the current project\n then it will be saved into a project folder path specified by the path parameter.\n \n If path is NULL, the program will be saved into the root folder.  If parts of the path are\n missing, they will be created if possible.\n \n If a program already exists with the specified name, then a time stamp will be appended \n to the name to make it unique.\n ","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to save","type_short":"Program"},{"type_long":"java.util.List<java.lang.String>","name":"path","comment":"list of string path elements (starting at the root of the project) that specify \n the project folder to save the program info.  Example: { \"folder1\", \"subfolder2\", \"finalfolder\" }","type_short":"List"}],"throws":[{"type_long":"java.lang.Exception","comment":"","type_short":"Exception"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This method looks up the current project and returns\n the root domain folder.\n@return the root domain folder of the current project","static":false,"name":"getProjectRootFolder","comment":"This method looks up the current project and returns\n the root domain folder.","params":[],"throws":[],"return":{"type_long":"ghidra.framework.model.DomainFolder","comment":"the root domain folder of the current project","type_short":"DomainFolder"}},{"javadoc":"@param type\n@param text\n@return ","static":false,"name":"findComment","comment":"","params":[{"type_long":"int","name":"type","comment":"","type_short":"int"},{"type_long":"java.lang.String","name":"text","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}}],"name":"FlatProgramAPI","comment":"This class is a flattened version of the Program API.\n \n NOTE:\n \n \tNO METHODS SHOULD EVER BE REMOVED FROM THIS CLASS.\n \tNO METHOD SIGNATURES SHOULD EVER BE CHANGED IN THIS CLASS.\n \n \n This class is used by GhidraScript.\n \n Changing this class will break user scripts.\n \n That is bad. Don't do that.\n ","fields":[{"type_long":"int","javadoc":"","static":true,"name":"MAX_REFERENCES_TO","comment":"","type_short":"int","constant_value":"4096"},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"currentProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.util.task.TaskMonitor","javadoc":"","static":false,"name":"monitor","comment":"","type_short":"TaskMonitor","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"transactionID","comment":"","type_short":"int","constant_value":null}]}
