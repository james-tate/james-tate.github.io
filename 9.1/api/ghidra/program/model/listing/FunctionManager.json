{"implements":[],"javadoc":"","static":false,"methods":[{"javadoc":"","static":false,"name":"getProgram","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"Gets the names associated with each of the current calling conventions associated with this\n program. Within the exception of \"unknown\", all of these calling convention names should have\n a PrototypeModel.\n@return the calling convention names.","static":false,"name":"getCallingConventionNames","comment":"Gets the names associated with each of the current calling conventions associated with this\n program. Within the exception of \"unknown\", all of these calling convention names should have\n a PrototypeModel.","params":[],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"the calling convention names.","type_short":"List"}},{"javadoc":"Gets the default calling convention's prototype model in this program.\n@return the default calling convention prototype model or null.","static":false,"name":"getDefaultCallingConvention","comment":"Gets the default calling convention's prototype model in this program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.PrototypeModel","comment":"the default calling convention prototype model or null.","type_short":"PrototypeModel"}},{"javadoc":"Gets the prototype model of the calling convention with the specified name in this program.\n@return the named function calling convention prototype model or null.","static":false,"name":"getCallingConvention","comment":"Gets the prototype model of the calling convention with the specified name in this program.","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.PrototypeModel","comment":"the named function calling convention prototype model or null.","type_short":"PrototypeModel"}},{"javadoc":"Gets all the calling convention prototype models in this program that have names.\n@return the function calling convention prototype models.","static":false,"name":"getCallingConventions","comment":"Gets all the calling convention prototype models in this program that have names.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.PrototypeModel[]","comment":"the function calling convention prototype models.","type_short":"ghidra.program.model.lang.PrototypeModel[]"}},{"javadoc":"Create a function with the given body at entry point within the global namespace.\n@param name the name of the new function or null for default name\n@param entryPoint entry point of function\n@param body addresses contained in the function body\n@param source the source of this function\n@return new function or null if one or more functions overlap the specified body address set.\n@throws InvalidInputException if the name has invalid characters\n@throws DuplicateNameException if a function with the given name already exists\n@throws OverlappingFunctionException if the address set of the body overlaps an existing\n             function","static":false,"name":"createFunction","comment":"Create a function with the given body at entry point within the global namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the new function or null for default name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"entry point of function","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"addresses contained in the function body","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this function","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the name has invalid characters","type_short":"InvalidInputException"},{"type_long":"ghidra.program.database.function.OverlappingFunctionException","comment":"if the address set of the body overlaps an existing\n             function","type_short":"OverlappingFunctionException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"new function or null if one or more functions overlap the specified body address set.","type_short":"Function"}},{"javadoc":"Create a function with the given body at entry point.\n@param name the name of the new function or null for default name\n@param nameSpace the nameSpace in which to create the function\n@param entryPoint entry point of function\n@param body addresses contained in the function body\n@param source the source of this function\n@return new function or null if one or more functions overlap the specified body address set.\n@throws InvalidInputException if the name has invalid characters\n@throws DuplicateNameException if a function with the given name already exists\n@throws OverlappingFunctionException if the address set of the body overlaps an existing\n             function","static":false,"name":"createFunction","comment":"Create a function with the given body at entry point.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the new function or null for default name","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"nameSpace","comment":"the nameSpace in which to create the function","type_short":"Namespace"},{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"entry point of function","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"addresses contained in the function body","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this function","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the name has invalid characters","type_short":"InvalidInputException"},{"type_long":"ghidra.program.database.function.OverlappingFunctionException","comment":"if the address set of the body overlaps an existing\n             function","type_short":"OverlappingFunctionException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"new function or null if one or more functions overlap the specified body address set.","type_short":"Function"}},{"javadoc":"Create a thunk function with the given body at entry point.\n@param name the name of the new function or null for default name\n@param nameSpace the nameSpace in which to create the function\n@param entryPoint entry point of function\n@param body addresses contained in the function body\n@param thunkedFunction referenced function (required is creating a thunk function)\n@param source the source of this function\n@return new function or null if one or more functions overlap the specified body address set.\n@throws OverlappingFunctionException if the address set of the body overlaps an existing\n             function","static":false,"name":"createThunkFunction","comment":"Create a thunk function with the given body at entry point.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the new function or null for default name","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"nameSpace","comment":"the nameSpace in which to create the function","type_short":"Namespace"},{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"entry point of function","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"addresses contained in the function body","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.listing.Function","name":"thunkedFunction","comment":"referenced function (required is creating a thunk function)","type_short":"Function"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this function","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.program.database.function.OverlappingFunctionException","comment":"if the address set of the body overlaps an existing\n             function","type_short":"OverlappingFunctionException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"new function or null if one or more functions overlap the specified body address set.","type_short":"Function"}},{"javadoc":"Returns the total number of functions in the program including external functions.","static":false,"name":"getFunctionCount","comment":"Returns the total number of functions in the program including external functions.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Remove a function defined at entryPoint.","static":false,"name":"removeFunction","comment":"Remove a function defined at entryPoint.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get the function at entryPoint.\n@return null if there is no function at entryPoint.","static":false,"name":"getFunctionAt","comment":"Get the function at entryPoint.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"null if there is no function at entryPoint.","type_short":"Function"}},{"javadoc":"Get the function which resides at the specified address or is referenced from the specified\n address.\n@param address function address or address of pointer to a function.\n@return referenced function or null","static":false,"name":"getReferencedFunction","comment":"Get the function which resides at the specified address or is referenced from the specified\n address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"function address or address of pointer to a function.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"referenced function or null","type_short":"Function"}},{"javadoc":"Get a function containing an address.\n@param addr address within the function\n@return function containing this address, null otherwise","static":false,"name":"getFunctionContaining","comment":"Get a function containing an address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address within the function","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"function containing this address, null otherwise","type_short":"Function"}},{"javadoc":"Returns an iterator over all non-external functions in address (entry point) order.\n@param forward true means to iterate in ascending address order","static":false,"name":"getFunctions","comment":"Returns an iterator over all non-external functions in address (entry point) order.","params":[{"type_long":"boolean","name":"forward","comment":"true means to iterate in ascending address order","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"","type_short":"FunctionIterator"}},{"javadoc":"Get an iterator over non-external functions starting at an address and ordered by entry\n address.\n@param start starting address\n@param forward true means to iterate in ascending address order\n@return an iterator over functions.","static":false,"name":"getFunctions","comment":"Get an iterator over non-external functions starting at an address and ordered by entry\n address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"starting address","type_short":"Address"},{"type_long":"boolean","name":"foward","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"an iterator over functions.","type_short":"FunctionIterator"}},{"javadoc":"Get an iterator over functions with entry points in the specified address set. Function are\n ordered based upon entry address.\n@param asv address set to iterate over\n@param forward true means to iterate in ascending address order\n@return an iterator over functions.","static":false,"name":"getFunctions","comment":"Get an iterator over functions with entry points in the specified address set. Function are\n ordered based upon entry address.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"asv","comment":"address set to iterate over","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"true means to iterate in ascending address order","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"an iterator over functions.","type_short":"FunctionIterator"}},{"javadoc":"Returns an iterator over all REAL functions in address (entry point) order (real functions\n have instructions, and aren't stubs).\n@param forward true means to iterate in ascending address order","static":false,"name":"getFunctionsNoStubs","comment":"Returns an iterator over all REAL functions in address (entry point) order (real functions\n have instructions, and aren't stubs).","params":[{"type_long":"boolean","name":"forward","comment":"true means to iterate in ascending address order","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"","type_short":"FunctionIterator"}},{"javadoc":"Get an iterator over REAL functions starting at an address and ordered by entry address (real\n functions have instructions, and aren't stubs).\n@param start starting address\n@param forward true means to iterate in ascending address order\n@return an iterator over functions.","static":false,"name":"getFunctionsNoStubs","comment":"Get an iterator over REAL functions starting at an address and ordered by entry address (real\n functions have instructions, and aren't stubs).","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"starting address","type_short":"Address"},{"type_long":"boolean","name":"foward","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"an iterator over functions.","type_short":"FunctionIterator"}},{"javadoc":"Get an iterator over REAL functions with entry points in the specified address set (real\n functions have instructions, and aren't stubs). Functions are ordered based upon entry\n address.\n@param asv address set to iterate over\n@param forward true means to iterate in ascending address order\n@return an iterator over functions.","static":false,"name":"getFunctionsNoStubs","comment":"Get an iterator over REAL functions with entry points in the specified address set (real\n functions have instructions, and aren't stubs). Functions are ordered based upon entry\n address.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"asv","comment":"address set to iterate over","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"true means to iterate in ascending address order","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"an iterator over functions.","type_short":"FunctionIterator"}},{"javadoc":"Get an iterator over all external functions. Functions returned have no particular order.\n@return an iterator over external functions","static":false,"name":"getExternalFunctions","comment":"Get an iterator over all external functions. Functions returned have no particular order.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.FunctionIterator","comment":"an iterator over external functions","type_short":"FunctionIterator"}},{"javadoc":"Check if this address contains a function.\n@param addr address to check\n@return true if this address is contained in a function.","static":false,"name":"isInFunction","comment":"Check if this address contains a function.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to check","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this address is contained in a function.","type_short":"boolean"}},{"javadoc":"@see ghidra.program.database.ManagerDB#moveAddressRange(ghidra.program.model.address.Address,\n      ghidra.program.model.address.Address, long, ghidra.util.task.TaskMonitor)","static":false,"name":"moveAddressRange","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"","type_short":"Address"},{"type_long":"long","name":"length","comment":"","type_short":"long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.program.database.ManagerDB#deleteAddressRange(ghidra.program.model.address.Address,\n      ghidra.program.model.address.Address, ghidra.util.task.TaskMonitor)","static":false,"name":"deleteAddressRange","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"endAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.program.database.ManagerDB#setProgram(ghidra.program.database.ProgramDB)","static":false,"name":"setProgram","comment":"","params":[{"type_long":"ghidra.program.database.ProgramDB","name":"program","comment":"","type_short":"ProgramDB"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@param currentRevision TODO\n@see ghidra.program.database.ManagerDB#programReady(int, int, ghidra.util.task.TaskMonitor)","static":false,"name":"programReady","comment":"","params":[{"type_long":"int","name":"openMode","comment":"","type_short":"int"},{"type_long":"int","name":"currentRevision","comment":"TODO","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"invalidateCache","comment":"","params":[{"type_long":"boolean","name":"all","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return an iterator over functions that overlap the given address set.\n@param set address set of interest\n@return iterator over Functions","static":false,"name":"getFunctionsOverlapping","comment":"Return an iterator over functions that overlap the given address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"address set of interest","type_short":"AddressSetView"}],"throws":[],"return":{"type_long":"java.util.Iterator<ghidra.program.model.listing.Function>","comment":"iterator over Functions","type_short":"Iterator"}},{"javadoc":"Attempts to determine which if any of the local functions variables are referenced by the\n specified reference. In utilizing the firstUseOffset scoping model, negative offsets\n (relative to the functions entry) are shifted beyond the maximum positive offset within the\n function. While this does not account for the actual instruction flow, it is hopefully\n accurate enough for most situations.\n@param instrAddr\n@param storageAddr\n@param size varnode size in bytes (1 is assumed if value <= 0)\n@param isRead\n@return referenced variable or null if one not found","static":false,"name":"getReferencedVariable","comment":"Attempts to determine which if any of the local functions variables are referenced by the\n specified reference. In utilizing the firstUseOffset scoping model, negative offsets\n (relative to the functions entry) are shifted beyond the maximum positive offset within the\n function. While this does not account for the actual instruction flow, it is hopefully\n accurate enough for most situations.","params":[{"type_long":"ghidra.program.model.address.Address","name":"instrAddr","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"storageAddr","comment":"","type_short":"Address"},{"type_long":"int","name":"size","comment":"varnode size in bytes (1 is assumed if value = 0)","type_short":"int"},{"type_long":"boolean","name":"isRead","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Variable","comment":"referenced variable or null if one not found","type_short":"Variable"}},{"javadoc":"Get a Function object by its key\n@param key function symbol key\n@return function object or null if not found","static":false,"name":"getFunction","comment":"Get a Function object by its key","params":[{"type_long":"long","name":"key","comment":"function symbol key","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"function object or null if not found","type_short":"Function"}}],"name":"FunctionManager","comment":"","fields":[]}
