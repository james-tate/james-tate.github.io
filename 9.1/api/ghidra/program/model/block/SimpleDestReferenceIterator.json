{"implements":["ghidra.program.model.block.CodeBlockReferenceIterator"],"javadoc":"This iterator is implemented by getting the flows from the instruction\n  and iterating over those flows (plus the fallthrough).  This is probably\n  not the most efficient method.  An linked-list of references has to be created each\n  time we want to get the destinations from a block.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct an Iterator over Destination blocks for a CodeBlock.\n External references are ignored.\n@param block block to get destination blocks for.  This should be a\n block obtained from SimpleBlockModel.\n@param followIndirectFlows indirect references will only be included if true\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"<init>","comment":"Construct an Iterator over Destination blocks for a CodeBlock.\n External references are ignored.","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"block to get destination blocks for.  This should be a\n block obtained from SimpleBlockModel.","type_short":"CodeBlock"},{"type_long":"boolean","name":"followIndirectFlows","comment":"indirect references will only be included if true","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockReferenceIterator#next()","static":false,"name":"next","comment":"","params":[],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockReference","comment":"","type_short":"CodeBlockReference"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockReferenceIterator#hasNext()","static":false,"name":"hasNext","comment":"","params":[],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get number of destination references flowing out of this block.\n All Calls from this block, and all external FlowType block references\n from this block are ignored.\n@param block code block to get the number of destination references from.\n@param followIndirectFlows indirect references will only be included if true\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.\n@deprecated this method should be avoided since it repeats the work of the iterator","static":true,"name":"getNumDestinations","comment":"Get number of destination references flowing out of this block.\n All Calls from this block, and all external FlowType block references\n from this block are ignored.","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"code block to get the number of destination references from.","type_short":"CodeBlock"},{"type_long":"boolean","name":"followIndirectFlows","comment":"indirect references will only be included if true","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Count and queue all destination references flowing out of this block.\n All Calls from this block, and all external FlowType block references\n from this block are counted.\n@param block code block to get the number of destination references from.\n@param blockRefQueue the CodeBlockReference queue, may be null\n@param followIndirectFlows indirect references will only be included if true\n@param includeExternals externals will be included if true\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":true,"name":"getDestinations","comment":"Count and queue all destination references flowing out of this block.\n All Calls from this block, and all external FlowType block references\n from this block are counted.","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"code block to get the number of destination references from.","type_short":"CodeBlock"},{"type_long":"java.util.LinkedList<ghidra.program.model.block.CodeBlockReferenceImpl>","name":"blockRefQueue","comment":"the CodeBlockReference queue, may be null","type_short":"LinkedList"},{"type_long":"boolean","name":"followIndirectFlows","comment":"indirect references will only be included if true","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Process a data reference for possible indirection.  Update block reference queue \n with indirect block references.\n@param blockRefQueue the CodeBlockReference queue, may be null\n@param srcBlock referent\/source block\n@param srcRef possible indirect reference from srcBlock (is not verified)\n@param indirectFlowType reference type to assign to indirect references discovered\n@param includeExternals externals will be included if true\n@param monitor task monitor which allows user to cancel operation.\n@return number of references found, 0 if memRef does not correspond to a pointer.\n@throws CancelledException if the monitor cancels the operation.","static":true,"name":"followIndirection","comment":"Process a data reference for possible indirection.  Update block reference queue \n with indirect block references.","params":[{"type_long":"java.util.LinkedList<ghidra.program.model.block.CodeBlockReferenceImpl>","name":"blockRefQueue","comment":"the CodeBlockReference queue, may be null","type_short":"LinkedList"},{"type_long":"boolean","name":"includeExternals","comment":"externals will be included if true","type_short":"boolean"},{"type_long":"ghidra.program.model.block.CodeBlock","name":"srcBlock","comment":"referent\/source block","type_short":"CodeBlock"},{"type_long":"ghidra.program.model.symbol.Reference","name":"srcRef","comment":"possible indirect reference from srcBlock (is not verified)","type_short":"Reference"},{"type_long":"ghidra.program.model.symbol.FlowType","name":"indirectFlowType","comment":"reference type to assign to indirect references discovered","type_short":"FlowType"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"number of references found, 0 if memRef does not correspond to a pointer.","type_short":"int"}},{"javadoc":"Create a new block reference and add it to the queue.\n@param blockRefQueue the CodeBlockReference queue, may be null\n@param srcBlock referent\/source block\n@param fromAddr reference source address\n@param toAddr reference destination address\n@param flowType reference flow type\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":true,"name":"queueDestReference","comment":"Create a new block reference and add it to the queue.","params":[{"type_long":"java.util.LinkedList<ghidra.program.model.block.CodeBlockReferenceImpl>","name":"blockRefQueue","comment":"the CodeBlockReference queue, may be null","type_short":"LinkedList"},{"type_long":"ghidra.program.model.block.CodeBlock","name":"srcBlock","comment":"referent\/source block","type_short":"CodeBlock"},{"type_long":"ghidra.program.model.address.Address","name":"fromAddr","comment":"reference source address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"toAddr","comment":"reference destination address","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.FlowType","name":"flowType","comment":"reference flow type","type_short":"FlowType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"SimpleDestReferenceIterator","comment":"This iterator is implemented by getting the flows from the instruction\n  and iterating over those flows (plus the fallthrough).  This is probably\n  not the most efficient method.  An linked-list of references has to be created each\n  time we want to get the destinations from a block.","fields":[{"type_long":"java.util.LinkedList<ghidra.program.model.block.CodeBlockReferenceImpl>","javadoc":"","static":false,"name":"blockRefQueue","comment":"","type_short":"LinkedList","constant_value":null},{"type_long":"ghidra.util.task.TaskMonitor","javadoc":"","static":false,"name":"monitor","comment":"","type_short":"TaskMonitor","constant_value":null}]}
