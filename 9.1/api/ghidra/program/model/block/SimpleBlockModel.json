{"implements":["ghidra.program.model.block.CodeBlockModel"],"javadoc":"This BlockModel implements the simple block model.\n\n Each Codeblock is made up of contiguous instructions in address order.\n\n  Blocks satisfy the following:<ol>\n   <li>Any instruction with a label starts a block.\n   <li>Each instruction that could cause program control flow to change is the\n       last instruction of a Codeblock.\n   <li>All other instructions are \"NOP\" fallthroughs, meaning\n      after execution the program counter will be at\n      the instruction immediately following.\n   <li>Any instruction that is unreachable and has no label is also considered the start\n       of a block.\n <\/ol>\n So a CodeBlock in this model consists of contiguous code that has zero or\n more nonflow fallthrough instructions followed by a single flow instruction.\n Each block may or may not have a label at the first instruction, but may not\n have a label at any other instruction contained in the block.\n\n This model does not implement the pure simple block model\n because unreachable code is still considered a block.\n \n This model handles delay slot instructions with the following \n assumptions:<ol>\n <li>A delayed instruction is always corresponds to a change in\n     flow and terminates a block.  The delay slot instructions\n     following this instruction are always included with the\n     block.  Therefor, delay slot instructions will always fall\n     at the bottom of a simple block.\n <li>The delay slot depth of the delayed instruction will always\n     correspond to the number of delay slot instructions immediately\n     following the instruction. The model may not behave properly if\n     the disassembled code violates this assumption.\n <\/ol>\n@see ghidra.program.model.block.CodeBlockModel","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a SimpleBlockModel on a program.\n Externals will be excluded.\n@param program program to create blocks from.","static":false,"name":"<init>","comment":"Construct a SimpleBlockModel on a program.\n Externals will be excluded.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"program to create blocks from.","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a SimpleBlockModel on a program.\n@param program program to create blocks from.\n@param includeExternals externals will be included if true","static":false,"name":"<init>","comment":"Construct a SimpleBlockModel on a program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"program to create blocks from.","type_short":"Program"},{"type_long":"boolean","name":"includeExternals","comment":"externals will be included if true","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the code\/data block starting at this address.\n@param addr\n@param monitor task monitor which allows user to cancel operation.\n@return null if there is no codeblock starting at the address\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getCodeBlockAt","comment":"Get the code\/data block starting at this address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"null if there is no codeblock starting at the address","type_short":"CodeBlock"}},{"javadoc":"Get the basic code block starting at the specified instruction.\n@param instr first instruction of basic block\n@param monitor task monitor which allows user to cancel operation.\n@return null if there is no codeblock starting at the specified instruction\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getCodeBlockAt","comment":"Get the basic code block starting at the specified instruction.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"first instruction of basic block","type_short":"Instruction"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"null if there is no codeblock starting at the specified instruction","type_short":"CodeBlock"}},{"javadoc":"Examine an instruction for out-bound flows which qualify it\n as an end-of-block.\n@param instr\n@return true if end-of-block flow exists from specified instruction.","static":false,"name":"hasEndOfBlockFlow","comment":"Examine an instruction for out-bound flows which qualify it\n as an end-of-block.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"true if end-of-block flow exists from specified instruction.","type_short":"boolean"}},{"javadoc":"Create a new block over an address range with a single entry-point.\n@param start the first address which is also the only entry-point.\n@param end the last address.\n@return CodeBlock","static":false,"name":"createSimpleDataBlock","comment":"Create a new block over an address range with a single entry-point.","params":[{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"the first address which is also the only entry-point.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"the last address.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"CodeBlock","type_short":"CodeBlock"}},{"javadoc":"Create a new block over an address range with one or more entry-points.\n@param entryPts an array of entry-point addresses for the block.\n@param begin the first address in the range.\n@param end last address in the range.\n@return CodeBlock","static":false,"name":"createSimpleBlock","comment":"Create a new block over an address range with one or more entry-points.","params":[{"type_long":"ghidra.program.model.address.Address[]","name":"entryPts","comment":"an array of entry-point addresses for the block.","type_short":"ghidra.program.model.address.Address[]"},{"type_long":"ghidra.program.model.address.Address","name":"begin","comment":"the first address in the range.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"end","comment":"last address in the range.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"CodeBlock","type_short":"CodeBlock"}},{"javadoc":"","static":false,"name":"createSimpleExtBlock","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"extAddr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"","type_short":"CodeBlock"}},{"javadoc":"Get all the Code Blocks containing the address.\n@param addr Address to find a containing block.\n@param monitor task monitor which allows user to cancel operation.\n@return A SimpleBlock if any block contains the address\n        empty array otherwise.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getCodeBlocksContaining","comment":"Get all the Code Blocks containing the address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"Address to find a containing block.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlock[]","comment":"A SimpleBlock if any block contains the address\n        empty array otherwise.","type_short":"ghidra.program.model.block.CodeBlock[]"}},{"javadoc":"Get the First Code Block that contains the address.\n@param addr Address to find a containing block.\n@param monitor task monitor which allows user to cancel operation.\n@return A SimpleBlock if any block contains the address.\n        null otherwise.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getFirstCodeBlockContaining","comment":"Get the First Code Block that contains the address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"Address to find a containing block.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"A SimpleBlock if any block contains the address.\n        null otherwise.","type_short":"CodeBlock"}},{"javadoc":"Get an iterator over the code blocks in the entire program.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getCodeBlocks","comment":"Get an iterator over the code blocks in the entire program.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockIterator","comment":"","type_short":"CodeBlockIterator"}},{"javadoc":"Get an iterator over CodeBlocks which overlap the specified address set.\n@param addrSet an address set within program\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getCodeBlocksContaining","comment":"Get an iterator over CodeBlocks which overlap the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"an address set within program","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockIterator","comment":"","type_short":"CodeBlockIterator"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockModel#getProgram()","static":false,"name":"getProgram","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"","type_short":"Program"}},{"javadoc":"Returns the program listing associated with this model.\n@return the program listing associated with this model","static":false,"name":"getListing","comment":"Returns the program listing associated with this model.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Listing","comment":"the program listing associated with this model","type_short":"Listing"}},{"javadoc":"Check if the instruction at the address is\n the start of a basic block.\n@param addr Address to check\n@return true - if the address starts a basic block\n         false - otherwise","static":false,"name":"isBlockStart","comment":"Check if the instruction at the address is\n the start of a basic block.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"Address to check","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true - if the address starts a basic block\n         false - otherwise","type_short":"boolean"}},{"javadoc":"Check if the instruction starts a Simple block.\n@param instruction instruction to test if it starts a block\n@return true if this instruction is the start of a simple block.","static":false,"name":"isBlockStart","comment":"Check if the instruction starts a Simple block.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"instruction to test if it starts a block","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this instruction is the start of a simple block.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isBlockStart","comment":"","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.address.Address","name":"fallFrom","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockModel#getName(ghidra.program.model.block.CodeBlock)","static":false,"name":"getName","comment":"","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"","type_short":"CodeBlock"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Return in general how things flow out of this node.\n If there are any abnormal ways to flow out of this node,\n (ie: jump, call, etc...) then the flow type of the node\n takes on that type.\n\n If there are multiple unique ways out of the node, then we\n should return FlowType.UNKNOWN (or FlowType.MULTIFLOW ?).\n\n Fallthrough is returned if that is the only way out.\n\n If this block really has no valid instructions, it can't flow,\n so FlowType.INVALID is returned.\n@return flow type of this node","static":false,"name":"getFlowType","comment":"Return in general how things flow out of this node.\n If there are any abnormal ways to flow out of this node,\n (ie: jump, call, etc...) then the flow type of the node\n takes on that type.\n\n If there are multiple unique ways out of the node, then we\n should return FlowType.UNKNOWN (or FlowType.MULTIFLOW ?).\n\n Fallthrough is returned if that is the only way out.\n\n If this block really has no valid instructions, it can't flow,\n so FlowType.INVALID is returned.","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"","type_short":"CodeBlock"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.FlowType","comment":"flow type of this node","type_short":"FlowType"}},{"javadoc":"Get an iterator over source blocks flowing into this block.\n@param block code block to get the source iterator for.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getSources","comment":"Get an iterator over source blocks flowing into this block.","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"code block to get the source iterator for.","type_short":"CodeBlock"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockReferenceIterator","comment":"","type_short":"CodeBlockReferenceIterator"}},{"javadoc":"Get number of source blocks flowing into this block\n@param block code block to get the source iterator for.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.\n@deprecated this method should be avoided since it repeats the work of the getSources iterator","static":false,"name":"getNumSources","comment":"Get number of source blocks flowing into this block","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"code block to get the source iterator for.","type_short":"CodeBlock"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get an iterator over destination blocks flowing from this block.\n@param block code block to get the destination block iterator for.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"getDestinations","comment":"Get an iterator over destination blocks flowing from this block.","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"code block to get the destination block iterator for.","type_short":"CodeBlock"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlockReferenceIterator","comment":"","type_short":"CodeBlockReferenceIterator"}},{"javadoc":"Get number of destination blocks flowing out of this block\n@param block code block to get the destination block iterator for.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.\n@deprecated this method should be avoided since it repeats the work of the getDestinations iterator","static":false,"name":"getNumDestinations","comment":"Get number of destination blocks flowing out of this block","params":[{"type_long":"ghidra.program.model.block.CodeBlock","name":"block","comment":"code block to get the destination block iterator for.","type_short":"CodeBlock"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockModel#getBasicBlockModel()","static":false,"name":"getBasicBlockModel","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.block.CodeBlockModel","comment":"","type_short":"CodeBlockModel"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockModel#getName()","static":false,"name":"getName","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockModel#allowsBlockOverlap()","static":false,"name":"allowsBlockOverlap","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"externalsIncluded","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"SimpleBlockModel","comment":"This BlockModel implements the simple block model.\n\n Each Codeblock is made up of contiguous instructions in address order.\n\n  Blocks satisfy the following:\n   Any instruction with a label starts a block.\n   Each instruction that could cause program control flow to change is the\n       last instruction of a Codeblock.\n   All other instructions are \"NOP\" fallthroughs, meaning\n      after execution the program counter will be at\n      the instruction immediately following.\n   Any instruction that is unreachable and has no label is also considered the start\n       of a block.\n \n So a CodeBlock in this model consists of contiguous code that has zero or\n more nonflow fallthrough instructions followed by a single flow instruction.\n Each block may or may not have a label at the first instruction, but may not\n have a label at any other instruction contained in the block.\n\n This model does not implement the pure simple block model\n because unreachable code is still considered a block.\n \n This model handles delay slot instructions with the following \n assumptions:\n A delayed instruction is always corresponds to a change in\n     flow and terminates a block.  The delay slot instructions\n     following this instruction are always included with the\n     block.  Therefor, delay slot instructions will always fall\n     at the bottom of a simple block.\n The delay slot depth of the delayed instruction will always\n     correspond to the number of delay slot instructions immediately\n     following the instruction. The model may not behave properly if\n     the disassembled code violates this assumption.\n ","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"NAME","comment":"","type_short":"String","constant_value":"\"Simple Block\""},{"type_long":"ghidra.program.model.block.CodeBlock[]","javadoc":"","static":true,"name":"emptyArray","comment":"","type_short":"ghidra.program.model.block.CodeBlock[]","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"program","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Listing","javadoc":"","static":false,"name":"listing","comment":"","type_short":"Listing","constant_value":null},{"type_long":"ghidra.program.model.symbol.ReferenceManager","javadoc":"","static":false,"name":"referenceMgr","comment":"","type_short":"ReferenceManager","constant_value":null},{"type_long":"ghidra.program.model.address.AddressObjectMap","javadoc":"","static":false,"name":"foundBlockMap","comment":"","type_short":"AddressObjectMap","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"includeExternals","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":true,"name":"followIndirectFlows","comment":"","type_short":"boolean","constant_value":"true"}]}
