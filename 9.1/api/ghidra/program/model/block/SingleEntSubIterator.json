{"implements":["ghidra.program.model.block.CodeBlockIterator"],"javadoc":"<CODE>SingleEntSubIterator<\/CODE> is an implementation of\n <CODE>CodeBlockIterator<\/CODE> capable of iterating in\n the forward direction over subroutine code blocks.\n This iterator supports subroutine models which allow only one\n called\/source entry point within a subroutine and may\n share code with other subroutines produced by the same model.\n All entry points must be accounted for within M-Model subroutines.\n\n NOTE: This iterator only supports OverlapCodeSubModel block models\n and extensions.\n\n NOTE: If the containing M-model subroutine has two entry points, say\n A and B, such that the code traversed from A is identical to the code traversed\n by B (due to a cycle), then this iterator will include it twice rather than\n skipping over the identical address set.  This is because the iterator works by\n iterating through M-model subroutines, and wherever M-model subroutines have\n n > 1 multiple entry points, the iterator produces an O-model subroutine\n for every one of the entry points.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Creates a new iterator that will iterate over the entire\n program starting from its current minimum address.\n@param model the BlockModel the iterator will use in its operations.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"<init>","comment":"Creates a new iterator that will iterate over the entire\n program starting from its current minimum address.","params":[{"type_long":"ghidra.program.model.block.OverlapCodeSubModel","name":"model","comment":"the BlockModel the iterator will use in its operations.","type_short":"OverlapCodeSubModel"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a new iterator that will iterate over the\n program within a given address range set. All blocks which \n overlap the address set will be returned.\n <P>\n@param model the BlockModel the iterator will use in its operations.\n@param set the address range set which the iterator is to be\n               restricted to.\n@param monitor task monitor which allows user to cancel operation.\n@throws CancelledException if the monitor cancels the operation.","static":false,"name":"<init>","comment":"Creates a new iterator that will iterate over the\n program within a given address range set. All blocks which \n overlap the address set will be returned.\n ","params":[{"type_long":"ghidra.program.model.block.OverlapCodeSubModel","name":"model","comment":"the BlockModel the iterator will use in its operations.","type_short":"OverlapCodeSubModel"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"the address range set which the iterator is to be\n               restricted to.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor which allows user to cancel operation.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor cancels the operation.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockIterator#hasNext()","static":false,"name":"hasNext","comment":"","params":[],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"@see ghidra.program.model.block.CodeBlockIterator#next()","static":false,"name":"next","comment":"","params":[],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.block.CodeBlock","comment":"","type_short":"CodeBlock"}}],"name":"SingleEntSubIterator","comment":"SingleEntSubIterator is an implementation of\n CodeBlockIterator capable of iterating in\n the forward direction over subroutine code blocks.\n This iterator supports subroutine models which allow only one\n called\/source entry point within a subroutine and may\n share code with other subroutines produced by the same model.\n All entry points must be accounted for within M-Model subroutines.\n\n NOTE: This iterator only supports OverlapCodeSubModel block models\n and extensions.\n\n NOTE: If the containing M-model subroutine has two entry points, say\n A and B, such that the code traversed from A is identical to the code traversed\n by B (due to a cycle), then this iterator will include it twice rather than\n skipping over the identical address set.  This is because the iterator works by\n iterating through M-model subroutines, and wherever M-model subroutines have\n n  1 multiple entry points, the iterator produces an O-model subroutine\n for every one of the entry points.","fields":[{"type_long":"ghidra.program.model.block.CodeBlock","javadoc":"","static":false,"name":"nextSub","comment":"","type_short":"CodeBlock","constant_value":null},{"type_long":"ghidra.program.model.address.AddressSetView","javadoc":"","static":false,"name":"addrSet","comment":"","type_short":"AddressSetView","constant_value":null},{"type_long":"ghidra.program.model.block.OverlapCodeSubModel","javadoc":"","static":false,"name":"model","comment":"","type_short":"OverlapCodeSubModel","constant_value":null},{"type_long":"java.util.LinkedList<ghidra.program.model.block.CodeBlock>","javadoc":"","static":false,"name":"subList","comment":"","type_short":"LinkedList","constant_value":null},{"type_long":"ghidra.program.model.block.CodeBlockIterator","javadoc":"","static":false,"name":"modelMIter","comment":"","type_short":"CodeBlockIterator","constant_value":null},{"type_long":"ghidra.util.task.TaskMonitor","javadoc":"","static":false,"name":"monitor","comment":"","type_short":"TaskMonitor","constant_value":null}]}
