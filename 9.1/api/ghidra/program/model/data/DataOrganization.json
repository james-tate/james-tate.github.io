{"implements":[],"javadoc":"","static":false,"methods":[{"javadoc":"@return true if data stored big-endian byte order","static":false,"name":"isBigEndian","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if data stored big-endian byte order","type_short":"boolean"}},{"javadoc":"@return the size of a pointer data type in bytes.","static":false,"name":"getPointerSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a pointer data type in bytes.","type_short":"int"}},{"javadoc":"Shift amount affects interpretation of in-memory pointer values only\n and will also be reflected within instruction pcode.  A value of zero indicates\n that shifted-pointers are not supported.\n@return the left shift amount for shifted-pointers.","static":false,"name":"getPointerShift","comment":"Shift amount affects interpretation of in-memory pointer values only\n and will also be reflected within instruction pcode.  A value of zero indicates\n that shifted-pointers are not supported.","params":[],"throws":[],"return":{"type_long":"int","comment":"the left shift amount for shifted-pointers.","type_short":"int"}},{"javadoc":"@return true if the \"char\" type is signed","static":false,"name":"isSignedChar","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if the \"char\" type is signed","type_short":"boolean"}},{"javadoc":"@return the size of a char (char) primitive data type in bytes.","static":false,"name":"getCharSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a char (char) primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a wide-char (wchar_t) primitive data type in bytes.","static":false,"name":"getWideCharSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a wide-char (wchar_t) primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a short primitive data type in bytes.","static":false,"name":"getShortSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a short primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a int primitive data type in bytes.","static":false,"name":"getIntegerSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a int primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a long primitive data type in bytes.","static":false,"name":"getLongSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a long primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a long long primitive data type in bytes.","static":false,"name":"getLongLongSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a long long primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a float primitive data type in bytes.","static":false,"name":"getFloatSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a float primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a double primitive data type in bytes.","static":false,"name":"getDoubleSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a double primitive data type in bytes.","type_short":"int"}},{"javadoc":"@return the size of a long double primitive data type in bytes.","static":false,"name":"getLongDoubleSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the size of a long double primitive data type in bytes.","type_short":"int"}},{"javadoc":"Gets the maximum alignment value that is allowed by this data organization. When getting\n an alignment for any data type it will not exceed this value. If NO_MAXIMUM_ALIGNMENT\n is returned, the data organization isn't specifically limited.\n@return the absolute maximum alignment or NO_MAXIMUM_ALIGNMENT","static":false,"name":"getAbsoluteMaxAlignment","comment":"Gets the maximum alignment value that is allowed by this data organization. When getting\n an alignment for any data type it will not exceed this value. If NO_MAXIMUM_ALIGNMENT\n is returned, the data organization isn't specifically limited.","params":[],"throws":[],"return":{"type_long":"int","comment":"the absolute maximum alignment or NO_MAXIMUM_ALIGNMENT","type_short":"int"}},{"javadoc":"Gets the maximum useful alignment for the target machine\n@return the machine alignment","static":false,"name":"getMachineAlignment","comment":"Gets the maximum useful alignment for the target machine","params":[],"throws":[],"return":{"type_long":"int","comment":"the machine alignment","type_short":"int"}},{"javadoc":"Gets the default alignment to be used for any data type that isn't a \n structure, union, array, pointer, type definition, and whose size isn't in the \n size\/alignment map.\n@return the default alignment to be used if no other alignment can be \n determined for a data type.","static":false,"name":"getDefaultAlignment","comment":"Gets the default alignment to be used for any data type that isn't a \n structure, union, array, pointer, type definition, and whose size isn't in the \n size\/alignment map.","params":[],"throws":[],"return":{"type_long":"int","comment":"the default alignment to be used if no other alignment can be \n determined for a data type.","type_short":"int"}},{"javadoc":"Gets the default alignment to be used for a pointer that doesn't have size.\n@return the default alignment for a pointer","static":false,"name":"getDefaultPointerAlignment","comment":"Gets the default alignment to be used for a pointer that doesn't have size.","params":[],"throws":[],"return":{"type_long":"int","comment":"the default alignment for a pointer","type_short":"int"}},{"javadoc":"Gets the alignment that is defined for a data type of the indicated size if one is defined.\n@param size the size of the data type\n@return the alignment of the data type.\n@throws NoValueException if there isn't an alignment defined for the indicated size.","static":false,"name":"getSizeAlignment","comment":"Gets the alignment that is defined for a data type of the indicated size if one is defined.","params":[{"type_long":"int","name":"size","comment":"the size of the data type","type_short":"int"}],"throws":[{"type_long":"ghidra.util.exception.NoValueException","comment":"if there isn't an alignment defined for the indicated size.","type_short":"NoValueException"}],"return":{"type_long":"int","comment":"the alignment of the data type.","type_short":"int"}},{"javadoc":"Get the composite bitfield packing information associated with this data organization.\n@return composite bitfield packing information","static":false,"name":"getBitFieldPacking","comment":"Get the composite bitfield packing information associated with this data organization.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.BitFieldPacking","comment":"composite bitfield packing information","type_short":"BitFieldPacking"}},{"javadoc":"Remove all entries from the size alignment map","static":false,"name":"clearSizeAlignmentMap","comment":"Remove all entries from the size alignment map","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets the number of sizes that have an alignment specified.\n@return the number of sizes with an alignment mapped to them.","static":false,"name":"getSizeAlignmentCount","comment":"Gets the number of sizes that have an alignment specified.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of sizes with an alignment mapped to them.","type_short":"int"}},{"javadoc":"Gets the sizes that have an alignment specified.\n@return the sizes with alignments mapped to them.","static":false,"name":"getSizes","comment":"Gets the sizes that have an alignment specified.","params":[],"throws":[],"return":{"type_long":"int[]","comment":"the sizes with alignments mapped to them.","type_short":"int[]"}},{"javadoc":"Returns the best fitting integer C-type whose size is less-than-or-equal\n to the specified size.  \"long long\" will be returned for any size larger\n than \"long long\";\n@param size integer size\n@param signed if false the unsigned modifier will be prepended.\n@return the best fitting","static":false,"name":"getIntegerCTypeApproximation","comment":"Returns the best fitting integer C-type whose size is less-than-or-equal\n to the specified size.  \"long long\" will be returned for any size larger\n than \"long long\";","params":[{"type_long":"int","name":"size","comment":"integer size","type_short":"int"},{"type_long":"boolean","name":"signed","comment":"if false the unsigned modifier will be prepended.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the best fitting","type_short":"String"}},{"javadoc":"Determines the alignment value for the indicated data type. (i.e. how the data type gets\n aligned within other data types.)  NOTE: the alignment of bitfields is dependent upon packing\n rules which must be considered at the composite level.\n@param dataType the data type\n@param dtSize the data type's size or component size\n@return the alignment","static":false,"name":"getAlignment","comment":"Determines the alignment value for the indicated data type. (i.e. how the data type gets\n aligned within other data types.)  NOTE: the alignment of bitfields is dependent upon packing\n rules which must be considered at the composite level.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the data type","type_short":"DataType"},{"type_long":"int","name":"dtSize","comment":"the data type's size or component size","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the alignment","type_short":"int"}},{"javadoc":"","static":false,"name":"isForcingAlignment","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getForcedAlignment","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Determines the offset where the specified data type should be placed to be properly aligned.\n@param minimumOffset the minimum allowable offset where the data type can be placed.\n@param dataType the data type\n@param dtSize the data type's size\n@return the aligned offset for the data type","static":false,"name":"getAlignmentOffset","comment":"Determines the offset where the specified data type should be placed to be properly aligned.","params":[{"type_long":"int","name":"minimumOffset","comment":"the minimum allowable offset where the data type can be placed.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the data type","type_short":"DataType"},{"type_long":"int","name":"dtSize","comment":"the data type's size","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the aligned offset for the data type","type_short":"int"}}],"name":"DataOrganization","comment":"","fields":[{"type_long":"int","javadoc":"","static":true,"name":"NO_MAXIMUM_ALIGNMENT","comment":"","type_short":"int","constant_value":"0"}]}
