{"implements":["ghidra.program.model.data.Composite"],"javadoc":"The structure interface.\n <p>\n NOTE: Structures containing only a flexible array will report a length of 1\n which will result in improper code unit sizing since we are unable to support a \n defined data of length 0.\n <p>\n NOTE: The use of zero-length bitfields within unaligned structures is discouraged since\n they have no real affect and are easily misplaced.  Their use should be reserved for \n aligned\/packed structures.","static":false,"methods":[{"javadoc":"Returns the component of this structure with the indicated ordinal.\n If the specified ordinal equals {@link #getNumComponents()} the defined \n flexible array component will be returned, otherwise an out of bounds\n exception will be thrown. Use of {@link #getFlexibleArrayComponent()} is preferred \n for obtaining this special trailing component.\n@param ordinal the component's ordinal (zero based).\n@return the data type component.\n@throws ArrayIndexOutOfBoundsException if the ordinal is out of bounds","static":false,"name":"getComponent","comment":"Returns the component of this structure with the indicated ordinal.\n If the specified ordinal equals #getNumComponents() the defined \n flexible array component will be returned, otherwise an out of bounds\n exception will be thrown. Use of #getFlexibleArrayComponent() is preferred \n for obtaining this special trailing component.","params":[{"type_long":"int","name":"ordinal","comment":"the component's ordinal (zero based).","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the data type component.","type_short":"DataTypeComponent"}},{"javadoc":"Gets the immediate child component that contains the byte\n at the given offset.  If the specified offset corresponds to \n a bit-field,the first bit-field component containing the offset\n will be returned.\n@param offset the byte offset into this data type\n@return the immediate child component.","static":false,"name":"getComponentAt","comment":"Gets the immediate child component that contains the byte\n at the given offset.  If the specified offset corresponds to \n a bit-field,the first bit-field component containing the offset\n will be returned.","params":[{"type_long":"int","name":"offset","comment":"the byte offset into this data type","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the immediate child component.","type_short":"DataTypeComponent"}},{"javadoc":"Returns the primitive Data Type that is at this offset.  This is useful\n for prototypes that have components that are made up of other components\n If the specified offset corresponds to \n a bit-field,the BitFieldDataType of the first bit-field component containing \n the offset will be returned.\n@param offset the byte offset into this data type.\n@return the primitive data type at the offset.","static":false,"name":"getDataTypeAt","comment":"Returns the primitive Data Type that is at this offset.  This is useful\n for prototypes that have components that are made up of other components\n If the specified offset corresponds to \n a bit-field,the BitFieldDataType of the first bit-field component containing \n the offset will be returned.","params":[{"type_long":"int","name":"offset","comment":"the byte offset into this data type.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the primitive data type at the offset.","type_short":"DataTypeComponent"}},{"javadoc":"Inserts a new bitfield at the specified ordinal position in this structure. \n Within aligned structures the specified byteWidth and bitOffset will be \n ignored since packing will occur at the specified ordinal position.\n The resulting component length and bitfield details will reflect the use\n of minimal storage sizing.\n <p>\n For unaligned structures, a component shift will only occur if the bitfield placement \n conflicts with another component.  If no conflict occurs, the bitfield will be placed \n at the specified location consuming any DEFAULT components as needed.  When a conflict \n does occur a shift will be performed at the ordinal position based upon the specified \n byteWidth.  When located onto existing bitfields they will be packed together \n provided they do not conflict, otherwise the conflict rule above applies.\n <p>\n Supported aligned packing starts with bit-0 (lsb) of the first byte for little-endian, and \n with bit-7 (msb) of the first byte for big-endian.  This is the default behavior for most\n compilers.  Insertion behavior may not work as expected if packing rules differ from this.\n@param ordinal the ordinal where the new datatype is to be inserted.\n@param byteWidth the storage allocation unit width which contains the bitfield.  Must be large\n enough to contain the \"effective bit size\" and corresponding bitOffset.  The actual \n component size used will be recomputed during insertion.\n@param bitOffset corresponds to the bitfield left-shift amount with the storage \n unit when viewed as big-endian.  The final offset may be reduced based upon\n the minimal storage size determined during insertion.\n@param baseDataType the bitfield base datatype (certain restrictions apply).\n@param bitSize the declared bitfield size in bits.  The effective bit size may be\n adjusted based upon the specified baseDataType.\n@param componentName the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the bitfield component created whose associated data type will\n be BitFieldDataType.\n@throws InvalidDataTypeException if the specified baseDataType is\n not a valid base type for bitfields.\n@throws ArrayIndexOutOfBoundsException if ordinal is less than 0 or greater than the \n current number of components.","static":false,"name":"insertBitField","comment":"Inserts a new bitfield at the specified ordinal position in this structure. \n Within aligned structures the specified byteWidth and bitOffset will be \n ignored since packing will occur at the specified ordinal position.\n The resulting component length and bitfield details will reflect the use\n of minimal storage sizing.\n \n For unaligned structures, a component shift will only occur if the bitfield placement \n conflicts with another component.  If no conflict occurs, the bitfield will be placed \n at the specified location consuming any DEFAULT components as needed.  When a conflict \n does occur a shift will be performed at the ordinal position based upon the specified \n byteWidth.  When located onto existing bitfields they will be packed together \n provided they do not conflict, otherwise the conflict rule above applies.\n \n Supported aligned packing starts with bit-0 (lsb) of the first byte for little-endian, and \n with bit-7 (msb) of the first byte for big-endian.  This is the default behavior for most\n compilers.  Insertion behavior may not work as expected if packing rules differ from this.","params":[{"type_long":"int","name":"ordinal","comment":"the ordinal where the new datatype is to be inserted.","type_short":"int"},{"type_long":"int","name":"byteWidth","comment":"the storage allocation unit width which contains the bitfield.  Must be large\n enough to contain the \"effective bit size\" and corresponding bitOffset.  The actual \n component size used will be recomputed during insertion.","type_short":"int"},{"type_long":"int","name":"bitOffset","comment":"corresponds to the bitfield left-shift amount with the storage \n unit when viewed as big-endian.  The final offset may be reduced based upon\n the minimal storage size determined during insertion.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"baseDataType","comment":"the bitfield base datatype (certain restrictions apply).","type_short":"DataType"},{"type_long":"int","name":"bitSize","comment":"the declared bitfield size in bits.  The effective bit size may be\n adjusted based upon the specified baseDataType.","type_short":"int"},{"type_long":"java.lang.String","name":"componentName","comment":"the field name to associate with this component.","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the comment to associate with this component.","type_short":"String"}],"throws":[{"type_long":"ghidra.program.model.data.InvalidDataTypeException","comment":"if the specified baseDataType is\n not a valid base type for bitfields.","type_short":"InvalidDataTypeException"},{"type_long":"java.lang.ArrayIndexOutOfBoundsException","comment":"if ordinal is less than 0 or greater than the \n current number of components.","type_short":"ArrayIndexOutOfBoundsException"}],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the bitfield component created whose associated data type will\n be BitFieldDataType.","type_short":"DataTypeComponent"}},{"javadoc":"Inserts a new bitfield at the specified location in this composite.  \n This method is intended to be used with unaligned structures where \n the bitfield will be precisely placed.  Within an aligned structure the specified\n byteOffset, byteWidth and bitOffset will be used to identify the appropriate ordinal\n but may not be preserved. The component length will be computed \n based upon the specified parameters and will be reduced from byteWidth to \n its minimal size for the new component.\n <p>\n For unaligned mode, a component shift will only occur if the bitfield placement \n conflicts with another component.  If no conflict occurs, the bitfield will be placed \n at the specified location consuming any DEFAULT components as needed.  When a conflict \n does occur a shift will be performed at the point of conflict based upon the specified \n byteWidth.  When located onto existing bitfields they will be packed together \n provided they do not conflict, otherwise the conflict rule above applies.\n <p>\n Supported packing for little-endian fills lsb first, whereas big-endian fills msb first.\n Insertion behavior may not work as expected if packing rules differ from this.\n <p>\n Zero length bitfields may be inserted although they have no real affect for \n unaligned structures.  Only the resulting byte offset within the structure \n is of significance in determining its' ordinal placement.\n <p>\n@param byteOffset the first byte offset within this structure which corresponds to the\n first byte of the specified storage unit identified by its byteWidth.\n@param byteWidth the storage unit width which contains the bitfield.  Must be large\n enough to contain the specified bitSize and corresponding bitOffset.  The actual \n component size used will be recomputed during insertion.\n@param bitOffset corresponds to the bitfield left-shift amount with the storage \n unit when viewed as big-endian.  The final offset may be reduced based upon\n the minimal storage size determined during insertion.\n@param baseDataType the bitfield base datatype (certain restrictions apply).\n@param componentName the field name to associate with this component.\n@param bitSize the bitfield size in bits.  A bitSize of 0 may be specified \n although its name will be ignored.\n@param comment the comment to associate with this component.\n@return the componentDataType created whose associated data type will\n be BitFieldDataType.\n@throws InvalidDataTypeException if the specified data type is\n not a valid base type for bitfields.","static":false,"name":"insertBitFieldAt","comment":"Inserts a new bitfield at the specified location in this composite.  \n This method is intended to be used with unaligned structures where \n the bitfield will be precisely placed.  Within an aligned structure the specified\n byteOffset, byteWidth and bitOffset will be used to identify the appropriate ordinal\n but may not be preserved. The component length will be computed \n based upon the specified parameters and will be reduced from byteWidth to \n its minimal size for the new component.\n \n For unaligned mode, a component shift will only occur if the bitfield placement \n conflicts with another component.  If no conflict occurs, the bitfield will be placed \n at the specified location consuming any DEFAULT components as needed.  When a conflict \n does occur a shift will be performed at the point of conflict based upon the specified \n byteWidth.  When located onto existing bitfields they will be packed together \n provided they do not conflict, otherwise the conflict rule above applies.\n \n Supported packing for little-endian fills lsb first, whereas big-endian fills msb first.\n Insertion behavior may not work as expected if packing rules differ from this.\n \n Zero length bitfields may be inserted although they have no real affect for \n unaligned structures.  Only the resulting byte offset within the structure \n is of significance in determining its' ordinal placement.\n ","params":[{"type_long":"int","name":"byteOffset","comment":"the first byte offset within this structure which corresponds to the\n first byte of the specified storage unit identified by its byteWidth.","type_short":"int"},{"type_long":"int","name":"byteWidth","comment":"the storage unit width which contains the bitfield.  Must be large\n enough to contain the specified bitSize and corresponding bitOffset.  The actual \n component size used will be recomputed during insertion.","type_short":"int"},{"type_long":"int","name":"bitOffset","comment":"corresponds to the bitfield left-shift amount with the storage \n unit when viewed as big-endian.  The final offset may be reduced based upon\n the minimal storage size determined during insertion.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"baseDataType","comment":"the bitfield base datatype (certain restrictions apply).","type_short":"DataType"},{"type_long":"int","name":"bitSize","comment":"the bitfield size in bits.  A bitSize of 0 may be specified \n although its name will be ignored.","type_short":"int"},{"type_long":"java.lang.String","name":"componentName","comment":"the field name to associate with this component.","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the comment to associate with this component.","type_short":"String"}],"throws":[{"type_long":"ghidra.program.model.data.InvalidDataTypeException","comment":"if the specified data type is\n not a valid base type for bitfields.","type_short":"InvalidDataTypeException"}],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the componentDataType created whose associated data type will\n be BitFieldDataType.","type_short":"DataTypeComponent"}},{"javadoc":"Inserts a new datatype at the specified offset into this structure.  \n Inserting a component will causing any conflicting component\n to shift down to the extent necessary to avoid a conflict.\n@param offset the byte offset into the structure where the new datatype is to be inserted.\n@param dataType the datatype to insert.\n@param length the length to associate with the dataType.\n For fixed length types a length &lt;= 0 will use the length of the resolved dataType.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not \n allowed to be inserted into this composite data type or an invalid length\n is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency.","static":false,"name":"insertAtOffset","comment":"Inserts a new datatype at the specified offset into this structure.  \n Inserting a component will causing any conflicting component\n to shift down to the extent necessary to avoid a conflict.","params":[{"type_long":"int","name":"offset","comment":"the byte offset into the structure where the new datatype is to be inserted.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the datatype to insert.","type_short":"DataType"},{"type_long":"int","name":"length","comment":"the length to associate with the dataType.\n For fixed length types a length = 0 will use the length of the resolved dataType.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the componentDataType created.","type_short":"DataTypeComponent"}},{"javadoc":"Inserts a new datatype at the specified offset into this structure.\n Inserting a component will causing any conflicting component\n to shift down to the extent necessary to avoid a conflict.\n@param offset the byte offset into the structure where the new datatype is to be inserted.\n@param dataType the datatype to insert.\n@param length the length to associate with the dataType.\n For fixed length types a length &lt;= 0 will use the length of the resolved dataType.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the componentDataType created.\n@throws IllegalArgumentException if the specified data type is not \n allowed to be inserted into this composite data type or an invalid length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to insert dt1 to dt2 since this would cause a cyclic dependency.","static":false,"name":"insertAtOffset","comment":"Inserts a new datatype at the specified offset into this structure.\n Inserting a component will causing any conflicting component\n to shift down to the extent necessary to avoid a conflict.","params":[{"type_long":"int","name":"offset","comment":"the byte offset into the structure where the new datatype is to be inserted.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the datatype to insert.","type_short":"DataType"},{"type_long":"int","name":"length","comment":"the length to associate with the dataType.\n For fixed length types a length = 0 will use the length of the resolved dataType.","type_short":"int"},{"type_long":"java.lang.String","name":"name","comment":"the field name to associate with this component.","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the comment to associate with this component.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the componentDataType created.","type_short":"DataTypeComponent"}},{"javadoc":"Deletes the component containing the specified offset in this structure.  If the offset\n corresponds to a bit-field, all bit-fields whose base type group contains the offset will \n be removed.\n@param offset the byte offset into the structure where the datatype is to be deleted.","static":false,"name":"deleteAtOffset","comment":"Deletes the component containing the specified offset in this structure.  If the offset\n corresponds to a bit-field, all bit-fields whose base type group contains the offset will \n be removed.","params":[{"type_long":"int","name":"offset","comment":"the byte offset into the structure where the datatype is to be deleted.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Remove all components from this structure, effectively setting the\n length to zero.","static":false,"name":"deleteAll","comment":"Remove all components from this structure, effectively setting the\n length to zero.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears the defined component at the given component index.  Clearing a \n component causes a defined component to be replaced with a number of\n undefined dataTypes to offset the removal of the defined dataType.\n@param index the index of the component to clear.\n@throws ArrayIndexOutOfBoundsException if component ordinal is out of bounds","static":false,"name":"clearComponent","comment":"Clears the defined component at the given component index.  Clearing a \n component causes a defined component to be replaced with a number of\n undefined dataTypes to offset the removal of the defined dataType.","params":[{"type_long":"int","name":"index","comment":"the index of the component to clear.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the component at the given component index with a new component\n of the indicated data type.\n@param index the index where the datatype is to be replaced.\n@param dataType the datatype to insert.\n@param length the length of the dataType to insert.\n For fixed length types a length &lt;= 0 will use the length of the resolved dataType.\n@return the new componentDataType at the index.\n@throws IllegalArgumentException if the specified data type is not \n allowed to replace a component in this composite data type or an invalid\n length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to replace a dt2 component with dt1 since this would cause a cyclic \n dependency.  In addition, any attempt to replace an existing bit-field\n component or specify a {@link BitFieldDatatype} will produce this error.\n@throws ArrayIndexOutOfBoundsException if component index is out of bounds","static":false,"name":"replace","comment":"Replaces the component at the given component index with a new component\n of the indicated data type.","params":[{"type_long":"int","name":"index","comment":"the index where the datatype is to be replaced.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the datatype to insert.","type_short":"DataType"},{"type_long":"int","name":"length","comment":"the length of the dataType to insert.\n For fixed length types a length = 0 will use the length of the resolved dataType.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the new componentDataType at the index.","type_short":"DataTypeComponent"}},{"javadoc":"Replaces the component at the given component index with a new component\n of the indicated data type.\n@param index the index where the datatype is to be replaced.\n@param dataType the datatype to insert.\n@param length the length to associate with the dataType.\n For fixed length types a length &lt;= 0 will use the length of the resolved dataType.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the new componentDataType at the index.\n@throws IllegalArgumentException if the specified data type is not \n allowed to replace a component in this composite data type or an invalid\n length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to replace a dt2 component with dt1 since this would cause a cyclic \n dependency.  In addition, any attempt to replace an existing bit-field\n component or specify a {@link BitFieldDatatype} will produce this error.\n@throws ArrayIndexOutOfBoundsException if component index is out of bounds","static":false,"name":"replace","comment":"Replaces the component at the given component index with a new component\n of the indicated data type.","params":[{"type_long":"int","name":"index","comment":"the index where the datatype is to be replaced.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the datatype to insert.","type_short":"DataType"},{"type_long":"int","name":"length","comment":"the length to associate with the dataType.\n For fixed length types a length = 0 will use the length of the resolved dataType.","type_short":"int"},{"type_long":"java.lang.String","name":"name","comment":"the field name to associate with this component.","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the comment to associate with this component.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the new componentDataType at the index.","type_short":"DataTypeComponent"}},{"javadoc":"Replaces the component at the specified byte offset with a new component\n of the indicated data type.   If the offset corresponds to a bit-field, all bit-fields \n at that offset will be removed and replaced by the specified component.  Keep in mind\n bit-field or any component removal must clear sufficient space for an unaligned \n structure to complete the replacement.\n@param offset the byte offset into the structure where the datatype is \n to be replaced.\n@param dataType the datatype to insert.\n@param length the length to associate with the dataType.\n For fixed length types a length &lt;= 0 will use the length of the resolved dataType.\n@param name the field name to associate with this component.\n@param comment the comment to associate with this component.\n@return the new componentDataType at the index.\n@throws IllegalArgumentException if the specified data type is not \n allowed to replace a component in this composite data type or an invalid \n length is specified.\n For example, suppose dt1 contains dt2. Therefore it is not valid\n to replace a dt2 component with dt1 since this would cause a cyclic \n dependency.  In addition, any attempt to replace an existing bit-field\n component or specify a {@link BitFieldDatatype} will produce this error.","static":false,"name":"replaceAtOffset","comment":"Replaces the component at the specified byte offset with a new component\n of the indicated data type.   If the offset corresponds to a bit-field, all bit-fields \n at that offset will be removed and replaced by the specified component.  Keep in mind\n bit-field or any component removal must clear sufficient space for an unaligned \n structure to complete the replacement.","params":[{"type_long":"int","name":"offset","comment":"the byte offset into the structure where the datatype is \n to be replaced.","type_short":"int"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"the datatype to insert.","type_short":"DataType"},{"type_long":"int","name":"length","comment":"the length to associate with the dataType.\n For fixed length types a length = 0 will use the length of the resolved dataType.","type_short":"int"},{"type_long":"java.lang.String","name":"name","comment":"the field name to associate with this component.","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"the comment to associate with this component.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"the new componentDataType at the index.","type_short":"DataTypeComponent"}},{"javadoc":"Returns a list of all components that make up this data type excluding any trailing\n flexible array component if present.\n@return an array containing the components","static":false,"name":"getComponents","comment":"Returns a list of all components that make up this data type excluding any trailing\n flexible array component if present.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent[]","comment":"an array containing the components","type_short":"ghidra.program.model.data.DataTypeComponent[]"}},{"javadoc":"Returns the list of components that are defined. (As opposed to \"filler\"\n undefined bytes.).  Any trailing flexible array component will be omitted.","static":false,"name":"getDefinedComponents","comment":"Returns the list of components that are defined. (As opposed to \"filler\"\n undefined bytes.).  Any trailing flexible array component will be omitted.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent[]","comment":"","type_short":"ghidra.program.model.data.DataTypeComponent[]"}},{"javadoc":"Determine if a trailing flexible array component has been defined.\n@return true if trailing flexible array component has been defined.","static":false,"name":"hasFlexibleArrayComponent","comment":"Determine if a trailing flexible array component has been defined.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if trailing flexible array component has been defined.","type_short":"boolean"}},{"javadoc":"Get the optional trailing flexible array component associated with this structure.\n@return optional trailing flexible array component associated with this structure or null\n if not present.","static":false,"name":"getFlexibleArrayComponent","comment":"Get the optional trailing flexible array component associated with this structure.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"optional trailing flexible array component associated with this structure or null\n if not present.","type_short":"DataTypeComponent"}},{"javadoc":"Set the optional trailing flexible array component associated with this structure.\n@param flexType the flexible array dataType (example: for 'char[0]' the type 'char' should be specified)\n@param name component field name or null for default name\n@param comment component comment\n@return updated flexible array component","static":false,"name":"setFlexibleArrayComponent","comment":"Set the optional trailing flexible array component associated with this structure.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"flexType","comment":"the flexible array dataType (example: for 'char[0]' the type 'char' should be specified)","type_short":"DataType"},{"type_long":"java.lang.String","name":"name","comment":"component field name or null for default name","type_short":"String"},{"type_long":"java.lang.String","name":"comment","comment":"component comment","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataTypeComponent","comment":"updated flexible array component","type_short":"DataTypeComponent"}},{"javadoc":"Remove the optional trailing flexible array component associated with this structure.","static":false,"name":"clearFlexibleArrayComponent","comment":"Remove the optional trailing flexible array component associated with this structure.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets the number of component data types in this data type excluding any trailing flexible\n array component if present.\n@return the number of components that make up this data prototype","static":false,"name":"getNumComponents","comment":"Gets the number of component data types in this data type excluding any trailing flexible\n array component if present.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of components that make up this data prototype","type_short":"int"}},{"javadoc":"Returns the number of non-undefined components in this composite. For example, say\n a structure has an int (4 bytes) at offset 0 and another int at offset 8.  This structure\n would have 6 total components (one for each undefined between the two ints), but only\n 2 defined components. Any trailing flexible array component will not be included in this count.\n@return the number of non-undefined components in this composite","static":false,"name":"getNumDefinedComponents","comment":"Returns the number of non-undefined components in this composite. For example, say\n a structure has an int (4 bytes) at offset 0 and another int at offset 8.  This structure\n would have 6 total components (one for each undefined between the two ints), but only\n 2 defined components. Any trailing flexible array component will not be included in this count.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of non-undefined components in this composite","type_short":"int"}},{"javadoc":"Increases the size of the structure by the given amount by adding undefined datatypes\n at the end of the structure.\n@param amount the amount by which to grow the structure.\n@throws IllegalArgumentException if amount < 1","static":false,"name":"growStructure","comment":"Increases the size of the structure by the given amount by adding undefined datatypes\n at the end of the structure.","params":[{"type_long":"int","name":"amount","comment":"the amount by which to grow the structure.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"pack","comment":"","params":[{"type_long":"int","name":"maxAlignment","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"Structure","comment":"The structure interface.\n \n NOTE: Structures containing only a flexible array will report a length of 1\n which will result in improper code unit sizing since we are unable to support a \n defined data of length 0.\n \n NOTE: The use of zero-length bitfields within unaligned structures is discouraged since\n they have no real affect and are easily misplaced.  Their use should be reserved for \n aligned\/packed structures.","fields":[]}
