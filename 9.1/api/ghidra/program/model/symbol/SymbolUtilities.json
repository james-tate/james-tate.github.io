{"implements":[],"javadoc":"Class with static methods to deal with symbol strings.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"getDynamicDataTypePrefixes","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<java.lang.String>","comment":"","type_short":"List"}},{"javadoc":"","static":true,"name":"getOrdinalValue","comment":"","params":[{"type_long":"java.lang.String","name":"symbolName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Check for invalid characters\n (space, colon, asterisk, plus, bracket)\n in labels.\n@param str the string to be checked for invalid characters.\n@return boolean true if no invalid chars","static":true,"name":"containsInvalidChars","comment":"Check for invalid characters\n (space, colon, asterisk, plus, bracket)\n in labels.","params":[{"type_long":"java.lang.String","name":"str","comment":"the string to be checked for invalid characters.","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"boolean true if no invalid chars","type_short":"boolean"}},{"javadoc":"Generates a default function name for a given address.\n@param addr the entry point of the function.\n@return the default generated name for the function.","static":true,"name":"getDefaultFunctionName","comment":"Generates a default function name for a given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the entry point of the function.","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the default generated name for the function.","type_short":"String"}},{"javadoc":"Returns true if the specified name is reserved as a default external name.\n@param name\n@param addrFactory\n@return true if the specified name is reserved as a default external name.","static":true,"name":"isReservedExternalDefaultName","comment":"Returns true if the specified name is reserved as a default external name.","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.address.AddressFactory","name":"addrFactory","comment":"","type_short":"AddressFactory"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the specified name is reserved as a default external name.","type_short":"boolean"}},{"javadoc":"Generates a default external name for an external function\n@param addr the memory address referred to by the external.\n@return the default generated name for the external.","static":true,"name":"getDefaultExternalFunctionName","comment":"Generates a default external name for an external function","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the memory address referred to by the external.","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the default generated name for the external.","type_short":"String"}},{"javadoc":"Generates a default external name for a given external data\/code location.\n@param addr the memory address referred to by the external.\n@param dt data type associated with the specified external memory address\n@return the default generated name for the external.","static":true,"name":"getDefaultExternalName","comment":"Generates a default external name for a given external data\/code location.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the memory address referred to by the external.","type_short":"Address"},{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"data type associated with the specified external memory address","type_short":"DataType"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the default generated name for the external.","type_short":"String"}},{"javadoc":"Returns true if the given name could match a default dynamic label (EXT, LAB, SUB, FUN, DAT)\n at some address.\n WARNING! Does not handle dynamic labels which use data-type prefixes -\n see {@link #isDynamicSymbolPattern(String, boolean)} for more liberal check","static":true,"name":"isReservedDynamicLabelName","comment":"Returns true if the given name could match a default dynamic label (EXT, LAB, SUB, FUN, DAT)\n at some address.\n WARNING! Does not handle dynamic labels which use data-type prefixes -\n see #isDynamicSymbolPattern(String, boolean) for more liberal check","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.address.AddressFactory","name":"addrFactory","comment":"","type_short":"AddressFactory"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Validate the given symbol name: cannot be null, cannot be an empty string, cannot contain blank\n characters, cannot be a reserved name.\n NOTE: This is not infallible since default data labels can start with any data-type name\n@throws InvalidInputException invalid or reserved name has been specified","static":true,"name":"validateName","comment":"Validate the given symbol name: cannot be null, cannot be an empty string, cannot contain blank\n characters, cannot be a reserved name.\n NOTE: This is not infallible since default data labels can start with any data-type name","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"symbolType","comment":"","type_short":"SymbolType"},{"type_long":"ghidra.program.model.address.AddressFactory","name":"addrFactory","comment":"","type_short":"AddressFactory"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"invalid or reserved name has been specified","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if the given name starts with a possible default symbol prefix.\n@param name the name string to test.","static":true,"name":"startsWithDefaultDynamicPrefix","comment":"Returns true if the given name starts with a possible default symbol prefix.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name string to test.","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"findDynamicPrefix","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Tests if the given name is a possible dynamic symbol name.\n WARNING! This method should be used carefully since it will return true for\n any name which ends with an '_' followed by a valid hex value\n@param name the name to test\n@param caseSensitive true if case matters.","static":true,"name":"isDynamicSymbolPattern","comment":"Tests if the given name is a possible dynamic symbol name.\n WARNING! This method should be used carefully since it will return true for\n any name which ends with an '_' followed by a valid hex value","params":[{"type_long":"java.lang.String","name":"name","comment":"the name to test","type_short":"String"},{"type_long":"boolean","name":"caseSensitive","comment":"true if case matters.","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"isHexDigits","comment":"","params":[{"type_long":"java.lang.String","name":"suffix","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"isHexDigit","comment":"","params":[{"type_long":"char","name":"c","comment":"","type_short":"char"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if the specified char\n is not valid for use in a symbol name\n@param c the character to be tested as a valid symbol character.","static":true,"name":"isInvalidChar","comment":"Returns true if the specified char\n is not valid for use in a symbol name","params":[{"type_long":"char","name":"c","comment":"the character to be tested as a valid symbol character.","type_short":"char"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Removes from the given string any invalid characters or replaces\n them with underscores.\n\n For example:\n given \"a:b*c\", the return value would be \"a_b_c\"\n@param str the string to have invalid chars converted to underscores or removed.\n@param replaceWithUnderscore - true means replace the invalid\n chars with underscore. if false, then just drop the invalid chars","static":true,"name":"replaceInvalidChars","comment":"Removes from the given string any invalid characters or replaces\n them with underscores.\n\n For example:\n given \"a:b*c\", the return value would be \"a_b_c\"","params":[{"type_long":"java.lang.String","name":"str","comment":"the string to have invalid chars converted to underscores or removed.","type_short":"String"},{"type_long":"boolean","name":"replaceWithUnderscore","comment":"- true means replace the invalid\n chars with underscore. if false, then just drop the invalid chars","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Create a name for an offcut reference.\n@param addr the address at which to create an offcut reference name.","static":true,"name":"getDynamicOffcutName","comment":"Create a name for an offcut reference.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to create an offcut reference name.","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Create a name for a dynamic symbol\n@param referenceLevel the type of reference for which to create a dynamic name.\n@param addr the address at which to create a dynamic name.","static":true,"name":"getDynamicName","comment":"Create a name for a dynamic symbol","params":[{"type_long":"int","name":"referenceLevel","comment":"the type of reference for which to create a dynamic name.","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to create a dynamic name.","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Create a name for a dynamic symbol.\n@param program the current program\n@param addr the address of the symbol for which to generate a name\n@return a name for the symbol at the given address","static":true,"name":"getDynamicName","comment":"Create a name for a dynamic symbol.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the current program","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address of the symbol for which to generate a name","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"a name for the symbol at the given address","type_short":"String"}},{"javadoc":"","static":true,"name":"getDynamicDataName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"","type_short":"Data"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"int","name":"refLevel","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"generateOffcutDataName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Data","name":"data","comment":"","type_short":"Data"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"int","name":"offcutOffset","comment":"","type_short":"int"},{"type_long":"int","name":"refLevel","comment":"","type_short":"int"},{"type_long":"boolean","name":"isString","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getDynamicInstructionName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"int","name":"refLevel","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getDyanmicOffcutInstructionName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.address.Address","name":"codeUnitAddress","comment":"","type_short":"Address"},{"type_long":"long","name":"diff","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"normalize to code unit address (in case we have segmented addresses)","static":true,"name":"normalizeSegmentedAddress","comment":"normalize to code unit address (in case we have segmented addresses)","params":[{"type_long":"ghidra.program.model.listing.CodeUnit","name":"codeUnit","comment":"","type_short":"CodeUnit"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Parse a dynamic name and return its address or null if unable to parse.\n@param name the dynamic label name to parse into an address.","static":true,"name":"parseDynamicName","comment":"Parse a dynamic name and return its address or null if unable to parse.","params":[{"type_long":"ghidra.program.model.address.AddressFactory","name":"factory","comment":"","type_short":"AddressFactory"},{"type_long":"java.lang.String","name":"name","comment":"the dynamic label name to parse into an address.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Returns the addressSpace that matches the largest range of parsed pieces, ignoring the first and\n last piece (which can't be part of an addressSpace name).  In other words if the array of strings\n passed in is {\"a\",\"b\",\"c\",\"d\",\"e\"}, it will test for addresSpaces named \"b_c_d\", then \"c_d\", and\n finally \"d\".\n@param factory the address factory containing the valid addressSpaces.\n@param pieces the array of parsed label pieces\n@return The addressSpace the matches the biggest string, or the default space if no match is found.","static":true,"name":"findAddressSpace","comment":"Returns the addressSpace that matches the largest range of parsed pieces, ignoring the first and\n last piece (which can't be part of an addressSpace name).  In other words if the array of strings\n passed in is {\"a\",\"b\",\"c\",\"d\",\"e\"}, it will test for addresSpaces named \"b_c_d\", then \"c_d\", and\n finally \"d\".","params":[{"type_long":"ghidra.program.model.address.AddressFactory","name":"factory","comment":"the address factory containing the valid addressSpaces.","type_short":"AddressFactory"},{"type_long":"java.lang.String[]","name":"pieces","comment":"the array of parsed label pieces","type_short":"java.lang.String[]"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"The addressSpace the matches the biggest string, or the default space if no match is found.","type_short":"AddressSpace"}},{"javadoc":"","static":true,"name":"buildSpaceName","comment":"","params":[{"type_long":"java.lang.String[]","name":"pieces","comment":"","type_short":"java.lang.String[]"},{"type_long":"int","name":"start","comment":"","type_short":"int"},{"type_long":"int","name":"end","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getAddressString","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getDefaultParamName","comment":"","params":[{"type_long":"int","name":"ordinal","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"isDefaultParameterName","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"getDefaultLocalName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"int","name":"stackOffset","comment":"","type_short":"int"},{"type_long":"int","name":"firstUseOffset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getDefaultLocalName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.listing.VariableStorage","name":"storage","comment":"","type_short":"VariableStorage"},{"type_long":"int","name":"firstUseOffset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"isDefaultLocalName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.listing.VariableStorage","name":"storage","comment":"","type_short":"VariableStorage"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"getVariableAddressString","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"isDefaultLocalStackName","comment":"","params":[{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"removeFirstUseOffset","comment":"","params":[{"type_long":"java.lang.String","name":"str","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Creates the standard symbol name for symbols that have the addresses appended to the \n name following an \"@\" character in order to make it unique.\n@param name the \"true\" name of the symbol\n@param address the address to be appended\n@return the name with the address appended.","static":true,"name":"getAddressAppendedName","comment":"Creates the standard symbol name for symbols that have the addresses appended to the \n name following an \"@\" character in order to make it unique.","params":[{"type_long":"java.lang.String","name":"name","comment":"the \"true\" name of the symbol","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to be appended","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name with the address appended.","type_short":"String"}},{"javadoc":"Creates the a symbol name for symbols that have the addresses appended to the \n name in order to make it unique.\n@param name the \"true\" name of the symbol\n@param address the address to be appended\n@param suffixSeparator \"@\" or \"_\"\n@return the name with the address appended.","static":true,"name":"getAddressAppendedName","comment":"Creates the a symbol name for symbols that have the addresses appended to the \n name in order to make it unique.","params":[{"type_long":"java.lang.String","name":"name","comment":"the \"true\" name of the symbol","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address to be appended","type_short":"Address"},{"type_long":"java.lang.String","name":"suffixSeparator","comment":"\"@\" or \"_\"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name with the address appended.","type_short":"String"}},{"javadoc":"Gets the base symbol name regardless of whether or not the address has been appended.\n@param symbol the symbol to get the clean name for.\n@return the base symbol name where the \"@<address>\" has been stripped away if it exists.","static":true,"name":"getCleanSymbolName","comment":"Gets the base symbol name regardless of whether or not the address has been appended.","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"symbol","comment":"the symbol to get the clean name for.","type_short":"Symbol"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the base symbol name where the \"@\" has been stripped away if it exists.","type_short":"String"}},{"javadoc":"Gets the base symbol name regardless of whether or not the address has been appended \n using either the standard \"@\" separator, or the less preferred \"_\" separator.  The\n address string extension must match that which is produced by the \n {@link #getAddressString(Address)} method for it to be recognized.\n@param symbolName a symbol name to get the clean name for.\n@param address the symbol's address\n@return the base symbol name where the \"@<address>\" has been stripped away if it exists.","static":true,"name":"getCleanSymbolName","comment":"Gets the base symbol name regardless of whether or not the address has been appended \n using either the standard \"@\" separator, or the less preferred \"_\" separator.  The\n address string extension must match that which is produced by the \n #getAddressString(Address) method for it to be recognized.","params":[{"type_long":"java.lang.String","name":"symbolName","comment":"a symbol name to get the clean name for.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the symbol's address","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the base symbol name where the \"@\" has been stripped away if it exists.","type_short":"String"}},{"javadoc":"Returns display text suitable for describing in the GUI the {@link SymbolType} of the\n given symbol\n@param symbol The symbol from which to get the SymbolType\n@return a display string for the SymbolType","static":true,"name":"getSymbolTypeDisplayName","comment":"Returns display text suitable for describing in the GUI the SymbolType of the\n given symbol","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"symbol","comment":"The symbol from which to get the SymbolType","type_short":"Symbol"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"a display string for the SymbolType","type_short":"String"}},{"javadoc":"Returns the unique global label or function symbol with the given name. Also, logs if there\n is not exactly one symbol with that name.\n@param program the program to search.\n@param symbolName the name of the global label or function symbol to search.\n@param errorConsumer the object to use for reporting errors via it's accept() method.","static":true,"name":"getExpectedLabelOrFunctionSymbol","comment":"Returns the unique global label or function symbol with the given name. Also, logs if there\n is not exactly one symbol with that name.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"},{"type_long":"java.lang.String","name":"symbolName","comment":"the name of the global label or function symbol to search.","type_short":"String"},{"type_long":"java.util.function.Consumer<java.lang.String>","name":"errorConsumer","comment":"the object to use for reporting errors via it's accept() method.","type_short":"Consumer"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Returns the unique global label or function symbol with the given name. Also, logs if there\n is more than one symbol with that name.\n@param program the program to search.\n@param symbolName the name of the global label or function symbol to search.\n@param errorConsumer the object to use for reporting errors via it's accept() method.","static":true,"name":"getLabelOrFunctionSymbol","comment":"Returns the unique global label or function symbol with the given name. Also, logs if there\n is more than one symbol with that name.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program to search.","type_short":"Program"},{"type_long":"java.lang.String","name":"symbolName","comment":"the name of the global label or function symbol to search.","type_short":"String"},{"type_long":"java.util.function.Consumer<java.lang.String>","name":"errorConsumer","comment":"the object to use for reporting errors via it's accept() method.","type_short":"Consumer"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Create label symbol giving preference to non-global symbols.  An existing function symbol\n may be returned.  If attempting to create a global symbol and the name already exists \n at the address no symbol will be created and null will be returned.  \n If attempting to create a non-global symbol, which does not exist,\n and a global symbol does exist with same name its' namespace will be changed.\n@param program program within which the symbol should be created\n@param address memory address where symbol should be created\n@param namespace symbol namespace or null for global\n@param name symbol name\n@param source symbol source type\n@param errorConsumer error logging consumer\n@return new or existing label or function symbol or null if creating a global symbol\n whose name already exists at address\n@throws InvalidInputException if invalid symbol name provided","static":true,"name":"createPreferredLabelOrFunctionSymbol","comment":"Create label symbol giving preference to non-global symbols.  An existing function symbol\n may be returned.  If attempting to create a global symbol and the name already exists \n at the address no symbol will be created and null will be returned.  \n If attempting to create a non-global symbol, which does not exist,\n and a global symbol does exist with same name its' namespace will be changed.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"program within which the symbol should be created","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"memory address where symbol should be created","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"symbol namespace or null for global","type_short":"Namespace"},{"type_long":"java.lang.String","name":"name","comment":"symbol name","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"symbol source type","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if invalid symbol name provided","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"new or existing label or function symbol or null if creating a global symbol\n whose name already exists at address","type_short":"Symbol"}},{"javadoc":"Returns a comparator for symbols.  The comparison is based upon the name.  This call\n replaces the former <tt>compareTo<\/tt> method on Symbol.  This comparator returned here\n is case-insensitive.\n@return the comparator","static":true,"name":"getSymbolNameComparator","comment":"Returns a comparator for symbols.  The comparison is based upon the name.  This call\n replaces the former compareTo method on Symbol.  This comparator returned here\n is case-insensitive.","params":[],"throws":[],"return":{"type_long":"java.util.Comparator<ghidra.program.model.symbol.Symbol>","comment":"the comparator","type_short":"Comparator"}}],"name":"SymbolUtilities","comment":"Class with static methods to deal with symbol strings.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"MAX_SYMBOL_NAME_LENGTH","comment":"","type_short":"int","constant_value":"2000"},{"type_long":"java.lang.String","javadoc":"Default prefix for a subroutine","static":true,"name":"DEFAULT_SUBROUTINE_PREFIX","comment":"Default prefix for a subroutine","type_short":"String","constant_value":"\"SUB_\""},{"type_long":"java.lang.String","javadoc":"Default prefix for a reference that has flow\n but is not a call.","static":true,"name":"DEFAULT_SYMBOL_PREFIX","comment":"Default prefix for a reference that has flow\n but is not a call.","type_short":"String","constant_value":"\"LAB_\""},{"type_long":"java.lang.String","javadoc":"Default prefix for a data reference.","static":true,"name":"DEFAULT_DATA_PREFIX","comment":"Default prefix for a data reference.","type_short":"String","constant_value":"\"DAT_\""},{"type_long":"java.lang.String","javadoc":"Default prefix for reference that is unknown.","static":true,"name":"DEFAULT_UNKNOWN_PREFIX","comment":"Default prefix for reference that is unknown.","type_short":"String","constant_value":"\"UNK_\""},{"type_long":"java.lang.String","javadoc":"Default prefix for an entry point.","static":true,"name":"DEFAULT_EXTERNAL_ENTRY_PREFIX","comment":"Default prefix for an entry point.","type_short":"String","constant_value":"\"EXT_\""},{"type_long":"java.lang.String","javadoc":"Default prefix for a function.","static":true,"name":"DEFAULT_FUNCTION_PREFIX","comment":"Default prefix for a function.","type_short":"String","constant_value":"\"FUN_\""},{"type_long":"java.lang.String","javadoc":"Default prefix for a reference that is offcut.","static":true,"name":"DEFAULT_INTERNAL_REF_PREFIX","comment":"Default prefix for a reference that is offcut.","type_short":"String","constant_value":"\"OFF_\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"UNDERSCORE","comment":"","type_short":"String","constant_value":"\"_\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"PLUS","comment":"","type_short":"String","constant_value":"\"+\""},{"type_long":"int","javadoc":"","static":true,"name":"UNK_LEVEL","comment":"","type_short":"int","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"DAT_LEVEL","comment":"","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"","static":true,"name":"LAB_LEVEL","comment":"","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"","static":true,"name":"SUB_LEVEL","comment":"","type_short":"int","constant_value":"3"},{"type_long":"int","javadoc":"","static":true,"name":"EXT_LEVEL","comment":"","type_short":"int","constant_value":"5"},{"type_long":"int","javadoc":"","static":true,"name":"FUN_LEVEL","comment":"","type_short":"int","constant_value":"6"},{"type_long":"java.lang.String[]","javadoc":"Array of default prefixes.","static":true,"name":"DYNAMIC_PREFIX_ARRAY","comment":"Array of default prefixes.","type_short":"java.lang.String[]","constant_value":null},{"type_long":"java.util.List<java.lang.String>","javadoc":"","static":true,"name":"DYNAMIC_DATA_TYPE_PREFIXES","comment":"","type_short":"List","constant_value":null},{"type_long":"int","javadoc":"Any dynamic label will have an address with this minimum length or longer","static":true,"name":"MIN_LABEL_ADDRESS_DIGITS","comment":"Any dynamic label will have an address with this minimum length or longer","type_short":"int","constant_value":"4"},{"type_long":"java.lang.String","javadoc":"The standard prefix for denoting the ordinal\n values of a symbol.","static":true,"name":"ORDINAL_PREFIX","comment":"The standard prefix for denoting the ordinal\n values of a symbol.","type_short":"String","constant_value":"\"Ordinal_\""},{"type_long":"char[]","javadoc":"Invalid characters for a symbol name.","static":true,"name":"INVALIDCHARS","comment":"Invalid characters for a symbol name.","type_short":"char[]","constant_value":null},{"type_long":"java.util.Comparator<ghidra.program.model.symbol.Symbol>","javadoc":"","static":true,"name":"CASE_INSENSITIVE_SYMBOL_NAME_COMPARATOR","comment":"","type_short":"Comparator","constant_value":null}]}
