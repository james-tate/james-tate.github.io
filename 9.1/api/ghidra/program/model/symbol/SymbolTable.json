{"implements":[],"javadoc":"A SymbolTable manages the Symbols defined in a program.\n <br>\n A Symbol is an association between an Address,\n a String name. In addition, symbols may have one or more\n References.\n <br>\n A Reference is a 4-tuple of a source address, destination address, type,\n and either a mnemonic or operand index\n <br>\n Any address in a program can have more than one symbol associated to it.\n At any given time, one and only one symbol will be designated as the primary.\n <br>\n A symbol can be either global or local. Local symbols belong to some namespace other than\n the global namespace.\n <br>\n Label and Function symbols do not have to have unique names with a namespace. All other symbols\n must be unique within a namespace and be unique with all other symbols that must be unique.\n In other words you can have a several functions named \"foo\" and several labels named \"foo\"\n in the same namespace.  But you can't have a class named \"foo\" and a namespace named \"foo\".\n But you can have a class named \"foo\" and and many functions and labels named \"foo\" all\n in the same namespace.\n <br>\n A symbol can also be designated as dynamic. Which means the name is\n generated on-the-fly by the system based on its context.","static":false,"methods":[{"javadoc":"Create a label symbol with the given name associated to the given\n Address. The symbol will be global and be of type SymbolType.CODE. Label\n Symbols do not have to have unique names.\n If this is the first symbol defined for the address it becomes\n the primary.\n@param addr the address at which to create a symbol\n@param name the name of the symbol.\n@param source the source of this symbol\n <br>Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT.\n@throws InvalidInputException thrown if names contains white space, is zero length, or is\n             null.  Also thrown if invalid parentNamespace is specified.\n@throws IllegalArgumentException if you try to set the source to DEFAULT for a symbol type\n that doesn't allow it, or an improper addr if specified","static":false,"name":"createLabel","comment":"Create a label symbol with the given name associated to the given\n Address. The symbol will be global and be of type SymbolType.CODE. Label\n Symbols do not have to have unique names.\n If this is the first symbol defined for the address it becomes\n the primary.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to create a symbol","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT.","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"thrown if names contains white space, is zero length, or is\n             null.  Also thrown if invalid parentNamespace is specified.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"@deprecated use {@link #createLabel(Address, String, SourceType)} instead.\n Deprecated in version 7.5, will be removed a few versions later.","static":false,"name":"createSymbol","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Create a label symbol with the given name associated to the given\n Address and namespace. The symbol will be of type SymbolType.CODE.\n If this is the first symbol defined for the address it becomes\n the primary symbol.  If a symbol with that name already exists at the\n address, it will be returned instead with its namespace changed to the new\n namespace unless the new symbol is in the global space, in which case the namespace\n will remain as is.\n@param addr the address at which to create a symbol\n@param name the name of the symbol.\n@param namespace the namespace of the symbol.\n@param source the source of this symbol\n <br>Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT.\n@throws IllegalArgumentException if you try to set the source to DEFAULT for a symbol type\n that doesn't allow it, or an improper addr if specified","static":false,"name":"createLabel","comment":"Create a label symbol with the given name associated to the given\n Address and namespace. The symbol will be of type SymbolType.CODE.\n If this is the first symbol defined for the address it becomes\n the primary symbol.  If a symbol with that name already exists at the\n address, it will be returned instead with its namespace changed to the new\n namespace unless the new symbol is in the global space, in which case the namespace\n will remain as is.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to create a symbol","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace of the symbol.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this symbol\n Some symbol types, such as function symbols, can set the source to Symbol.DEFAULT.","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"@deprecated use {@link #createLabel(Address, String, Namespace, SourceType)} instead.\n Deprecated in version 7.5, will be removed a few versions later.","static":false,"name":"createSymbol","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Removes the specified symbol from the symbol table.  If removing any <b>non-function<\/b>\n symbol the behavior will be the same as invoking {@link Symbol#delete()} on the\n symbol.  Use of this method for non-function symbols is discouraged.\n <p>\n <b>WARNING!<\/b> If removing a function symbol the behavior differs from directly\n invoking {@link Symbol#delete()} on the function symbol.\n <p>\n When removing a function symbol this method has the following behavior:\n <ul>\n <li>If the function is a default symbol (e.g., FUN_12345678) this method\n has no affect and will return null<\/li>\n <li>otherwise if another label exists at the function entry point, that\n label will be removed and the function will be renamed with that labels name<\/li>\n <li>If no other labels exist at the function entry, the function will\n be renamed to the default function name<\/li>\n <\/ul>\n Any reference bound to a symbol removed will loose that\n symbol specific binding.\n@param sym the symbol to be removed.\n@return false, if removal of the symbol fails","static":false,"name":"removeSymbolSpecial","comment":"Removes the specified symbol from the symbol table.  If removing any non-function\n symbol the behavior will be the same as invoking Symbol#delete() on the\n symbol.  Use of this method for non-function symbols is discouraged.\n \n WARNING! If removing a function symbol the behavior differs from directly\n invoking Symbol#delete() on the function symbol.\n \n When removing a function symbol this method has the following behavior:\n \n If the function is a default symbol (e.g., FUN_12345678) this method\n has no affect and will return null\n otherwise if another label exists at the function entry point, that\n label will be removed and the function will be renamed with that labels name\n If no other labels exist at the function entry, the function will\n be renamed to the default function name\n \n Any reference bound to a symbol removed will loose that\n symbol specific binding.","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"sym","comment":"the symbol to be removed.","type_short":"Symbol"}],"throws":[],"return":{"type_long":"boolean","comment":"false, if removal of the symbol fails","type_short":"boolean"}},{"javadoc":"Get the symbol for the given symbol ID.\n@param symbolID the id of the symbol to be retrieved.\n@return null if there is no symbol with the given ID.","static":false,"name":"getSymbol","comment":"Get the symbol for the given symbol ID.","params":[{"type_long":"long","name":"symbolID","comment":"the id of the symbol to be retrieved.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"null if there is no symbol with the given ID.","type_short":"Symbol"}},{"javadoc":"Get the symbol with the given name, address, and namespace.\n <P>\n Note that for a symbol to be uniquely specified, all these parameters are required. Any method\n that queries for symbols using just one or two of these parameters will return a list of symbols.\n <\/P>\n@param name the name of the symbol to retrieve\n@param addr the address of the symbol to retrieve\n@param namespace the namespace of the symbol to retrieve. May be null which indicates global namespace.\n@See {@link getGlobalSymbol(String, Address)} for a convenience method if the namespace is the global namespace.","static":false,"name":"getSymbol","comment":"Get the symbol with the given name, address, and namespace.\n \n Note that for a symbol to be uniquely specified, all these parameters are required. Any method\n that queries for symbols using just one or two of these parameters will return a list of symbols.\n ","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to retrieve","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address of the symbol to retrieve","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace of the symbol to retrieve. May be null which indicates global namespace.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Get the global symbol with the given name and address.  Note that this results in a single\n Symbol because of an additional restriction that allows only one symbol with a given name\n at the same address and namespace (in this case the global namespace).\n\n <P>This is just a convenience method for {@link #getSymbol(String, Address, Namespace)} where\n the namespace is the global namespace.<\/P>\n@param name the name of the symbol to retrieve\n@param addr the address of the symbol to retrieve\n@See {@link getSymbol(String, Address, Namespace)}","static":false,"name":"getGlobalSymbol","comment":"Get the global symbol with the given name and address.  Note that this results in a single\n Symbol because of an additional restriction that allows only one symbol with a given name\n at the same address and namespace (in this case the global namespace).\n\n This is just a convenience method for #getSymbol(String, Address, Namespace) where\n the namespace is the global namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to retrieve","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address of the symbol to retrieve","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Returns the first symbol with the given name found in the given namespace. Ghidra now\n allows multiple symbols with the same name in the same namespace, so using this method\n is likely to produce unintended results. Use {@link #getSymbols(Namespace, String)} instead.\n@param name the name of the symbol to retreive\n@param namespace the namespace of the symbol to retrieve (null assumes global namespace)\n@deprecated This method is no longer useful as Ghidra allows duplicate symbol names in\n the same namespace. Use {@link #getSymbols(Namespace, String)} instead.\n Deprecated in version 7.5, will be removed a few versions later.","static":false,"name":"getSymbol","comment":"Returns the first symbol with the given name found in the given namespace. Ghidra now\n allows multiple symbols with the same name in the same namespace, so using this method\n is likely to produce unintended results. Use #getSymbols(Namespace, String) instead.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to retreive","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace of the symbol to retrieve (null assumes global namespace)","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Returns the first global symbol that it finds with the given name.  Now that Ghidra\n allows duplicate symbol names, this method is practically useless.\n@param name the name of the symbol to be retrieved.\n@return symbol, or null if no global symbol has that name\n@deprecated Use {@link #getGlobalSymbols(String)} instead.  Ghidra now allows\n multiple symbols in any namespace to have the same name.  Deprecated in Ghidra 7.5\n Deprecated in version 7.5, will be removed a few versions later.","static":false,"name":"getSymbol","comment":"Returns the first global symbol that it finds with the given name.  Now that Ghidra\n allows duplicate symbol names, this method is practically useless.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to be retrieved.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"symbol, or null if no global symbol has that name","type_short":"Symbol"}},{"javadoc":"Returns a list of all global symbols with the given name.\n@param name the name of the symbols to retrieve.\n@return a list of all global symbols with the given name.","static":false,"name":"getGlobalSymbols","comment":"Returns a list of all global symbols with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbols to retrieve.","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"a list of all global symbols with the given name.","type_short":"List"}},{"javadoc":"Returns all the label or function symbols that have the given name in the given namespace.\n@param name the name of the symbols to search for.\n@param namespace the namespace to search.  If null, then the global namespace is assumed.\n@return a list of all the label or function symbols with the given name in the given namespace.\n@throws DuplicateNameException if more than one label or function symbol has the name in\n the given namespace.","static":false,"name":"getLabelOrFunctionSymbols","comment":"Returns all the label or function symbols that have the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbols to search for.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace to search.  If null, then the global namespace is assumed.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"a list of all the label or function symbols with the given name in the given namespace.","type_short":"List"}},{"javadoc":"Returns a generic namespace symbol with the given name in the given namespace.\n@param name the name of the namespace symbol to retrieve.\n@param namespace the namespace containing the symbol to retrieve.\n@return a generic namespace symbol with the given name in the given namespace.","static":false,"name":"getNamespaceSymbol","comment":"Returns a generic namespace symbol with the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the namespace symbol to retrieve.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace containing the symbol to retrieve.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"a generic namespace symbol with the given name in the given namespace.","type_short":"Symbol"}},{"javadoc":"Returns the library symbol with the given name.\n@param name the name of the library symbol to retrieve.\n@return the library symbol with the given name.","static":false,"name":"getLibrarySymbol","comment":"Returns the library symbol with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the library symbol to retrieve.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the library symbol with the given name.","type_short":"Symbol"}},{"javadoc":"Returns the class symbol with the given name in the given namespace.\n@param name the name of the class.\n@param namespace the namespace to search for the class.\n@return the class symbol with the given name in the given namespace.","static":false,"name":"getClassSymbol","comment":"Returns the class symbol with the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the class.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace to search for the class.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the class symbol with the given name in the given namespace.","type_short":"Symbol"}},{"javadoc":"Returns the parameter symbol with the given name in the given namespace.\n@param name the name of the parameter.\n@param namespace the namespace (function) to search for the class.\n@return the parameter symbol with the given name in the given namespace.","static":false,"name":"getParameterSymbol","comment":"Returns the parameter symbol with the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the parameter.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace (function) to search for the class.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the parameter symbol with the given name in the given namespace.","type_short":"Symbol"}},{"javadoc":"Returns the local variable symbol with the given name in the given namespace.\n@param name the name of the local variable.\n@param namespace the namespace (function) to search for the class.\n@return the local variable symbol with the given name in the given namespace.","static":false,"name":"getLocalVariableSymbol","comment":"Returns the local variable symbol with the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the local variable.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace (function) to search for the class.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"the local variable symbol with the given name in the given namespace.","type_short":"Symbol"}},{"javadoc":"Returns a list of all symbols with the given name in the given namespace.\n@param name the name of the symbols to retrieve.\n@param namespace the namespace to search for symbols.\n@return ","static":false,"name":"getSymbols","comment":"Returns a list of all symbols with the given name in the given namespace.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbols to retrieve.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace to search for symbols.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.symbol.Symbol>","comment":"","type_short":"List"}},{"javadoc":"Returns a symbol that is either a parameter or local variable.  There can be only\n one because these symbol types have a unique name requirement.\n@param name the naem of the variable.\n@param namespace the namespace (function) to search.\n@return a parameter or local variable symbol with the given name.","static":false,"name":"getVariableSymbol","comment":"Returns a symbol that is either a parameter or local variable.  There can be only\n one because these symbol types have a unique name requirement.","params":[{"type_long":"java.lang.String","name":"name","comment":"the naem of the variable.","type_short":"String"},{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"","type_short":"Function"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"a parameter or local variable symbol with the given name.","type_short":"Symbol"}},{"javadoc":"Returns the namespace with the given name in the given parent namespace.  The namespace\n returned can be either a generic namespace or a class or library.  It does not include\n functions.\n@param name the name of the namespace to be retrieved.\n@param namespace the parent namespace of the namespace to be retrieved.\n@return the namespace with the given name in the given parent namespace.","static":false,"name":"getNamespace","comment":"Returns the namespace with the given name in the given parent namespace.  The namespace\n returned can be either a generic namespace or a class or library.  It does not include\n functions.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the namespace to be retrieved.","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the parent namespace of the namespace to be retrieved.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"the namespace with the given name in the given parent namespace.","type_short":"Namespace"}},{"javadoc":"Returns all the symbols with the given name.\n@param name the name of symbols to search for.\n@return array of symbols with the given name","static":false,"name":"getSymbols","comment":"Returns all the symbols with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of symbols to search for.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"array of symbols with the given name","type_short":"SymbolIterator"}},{"javadoc":"Returns an iterator over all symbols, including Dynamic symbols if\n includeDynamicSymbols is true.\n@param includeDynamicSymbols if true, the iterator will include dynamicSymbols","static":false,"name":"getAllSymbols","comment":"Returns an iterator over all symbols, including Dynamic symbols if\n includeDynamicSymbols is true.","params":[{"type_long":"boolean","name":"includeDynamicSymbols","comment":"if true, the iterator will include dynamicSymbols","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns the symbol that this reference is associated with.\n@param ref the reference to find the associated symbol for.","static":false,"name":"getSymbol","comment":"Returns the symbol that this reference is associated with.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"ref","comment":"the reference to find the associated symbol for.","type_short":"Reference"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"","type_short":"Symbol"}},{"javadoc":"Returns the primary symbol at the specified\n address.  This method will always return null if the address specified\n is neither a Memory address nor an External address.\n@param addr the address at which to retrieve the primary symbol\n@return symbol, or null if no symbol at that address","static":false,"name":"getPrimarySymbol","comment":"Returns the primary symbol at the specified\n address.  This method will always return null if the address specified\n is neither a Memory address nor an External address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to retrieve the primary symbol","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"symbol, or null if no symbol at that address","type_short":"Symbol"}},{"javadoc":"Returns all the symbols at the given address.  When addr is a memory address\n the primary symbol will be returned in array slot 0.\n WARNING! Use of this method with a Variable address is highly discouraged since\n a single Variable address could be used multiple times by many functions.\n@param addr the address at which to retrieve all symbols.\n@return a zero-length array when no symbols are defined at address.","static":false,"name":"getSymbols","comment":"Returns all the symbols at the given address.  When addr is a memory address\n the primary symbol will be returned in array slot 0.\n WARNING! Use of this method with a Variable address is highly discouraged since\n a single Variable address could be used multiple times by many functions.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to retrieve all symbols.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol[]","comment":"a zero-length array when no symbols are defined at address.","type_short":"ghidra.program.model.symbol.Symbol[]"}},{"javadoc":"Returns an array of all user defined symbols at the given address\n@param addr the address at which to retrieve all user defined symbols.","static":false,"name":"getUserSymbols","comment":"Returns an array of all user defined symbols at the given address","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address at which to retrieve all user defined symbols.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol[]","comment":"","type_short":"ghidra.program.model.symbol.Symbol[]"}},{"javadoc":"Returns an iterator over all the symbols in the given namespace\n@param namespace the namespace to search for symbols.","static":false,"name":"getSymbols","comment":"Returns an iterator over all the symbols in the given namespace","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace to search for symbols.","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns an iterator over all the symbols in the given namespace\n@param namespaceID the namespace ID to search for symbols.","static":false,"name":"getSymbols","comment":"Returns an iterator over all the symbols in the given namespace","params":[{"type_long":"long","name":"namespaceID","comment":"the namespace ID to search for symbols.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Return true if there exists a symbol at the given address.\n@param addr address to check for an existing symbol\n@return true if any symbol exists","static":false,"name":"hasSymbol","comment":"Return true if there exists a symbol at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to check for an existing symbol","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if any symbol exists","type_short":"boolean"}},{"javadoc":"Get the unique symbol ID for a dynamic symbol associated with the speified addr.\n The generation of this symbol ID does not reflect the presence of a dyanmic symbol\n at the specified addr.  This symbol ID should not be permanently stored since the encoding\n may change between software releases.\n@param addr dynamic symbol address\n@return unique symbol ID","static":false,"name":"getDynamicSymbolID","comment":"Get the unique symbol ID for a dynamic symbol associated with the speified addr.\n The generation of this symbol ID does not reflect the presence of a dyanmic symbol\n at the specified addr.  This symbol ID should not be permanently stored since the encoding\n may change between software releases.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"dynamic symbol address","type_short":"Address"}],"throws":[],"return":{"type_long":"long","comment":"unique symbol ID","type_short":"long"}},{"javadoc":"Returns a an iterator over all symbols that match the given search string.\n NOTE: The iterator is in the forward direction only.\n@param searchStr the string to search for (may contain * to match any sequence\n or ? to match a single char)\n@param caseSensitive flag to determine if the search is case sensitive or not.","static":false,"name":"getSymbolIterator","comment":"Returns a an iterator over all symbols that match the given search string.\n NOTE: The iterator is in the forward direction only.","params":[{"type_long":"java.lang.String","name":"searchStr","comment":"the string to search for (may contain * to match any sequence\n or ? to match a single char)","type_short":"String"},{"type_long":"boolean","name":"caseSensitive","comment":"flag to determine if the search is case sensitive or not.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns all the symbols of the given type within the given address set.\n@param set the address set in which to look for symbols of the given type\n@param type the SymbolType to look for.\n@param forward the direction within the addressSet to search","static":false,"name":"getSymbols","comment":"Returns all the symbols of the given type within the given address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"the address set in which to look for symbols of the given type","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the SymbolType to look for.","type_short":"SymbolType"},{"type_long":"boolean","name":"forward","comment":"the direction within the addressSet to search","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns the total number of symbols in the table.","static":false,"name":"getNumSymbols","comment":"Returns the total number of symbols in the table.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get iterator over all label symbols. Labels are defined on memory locations.","static":false,"name":"getSymbolIterator","comment":"Get iterator over all label symbols. Labels are defined on memory locations.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns an iterator over all defined symbols in no particular order.","static":false,"name":"getDefinedSymbols","comment":"Returns an iterator over all defined symbols in no particular order.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns the external symbol with the given name.\n@param name the name of the symbol to be retrieved.\n@return symbol, or null if no external symbol has that name","static":false,"name":"getExternalSymbol","comment":"Returns the external symbol with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to be retrieved.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"symbol, or null if no external symbol has that name","type_short":"Symbol"}},{"javadoc":"Returns all the external symbols with the given name.\n@param name the name of symbols to search for.\n@return array of external symbols with the given name","static":false,"name":"getExternalSymbols","comment":"Returns all the external symbols with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of symbols to search for.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"array of external symbols with the given name","type_short":"SymbolIterator"}},{"javadoc":"Returns an iterator over all defined external symbols in no particular order.","static":false,"name":"getExternalSymbols","comment":"Returns an iterator over all defined external symbols in no particular order.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Returns an iterator over all symbols.\n@param forward true means the iterator is in the forward direction","static":false,"name":"getSymbolIterator","comment":"Returns an iterator over all symbols.","params":[{"type_long":"boolean","name":"forward","comment":"true means the iterator is in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Get iterator over all symbols starting at\n the specified <code>startAddr<\/code>\n@param startAddr the address at which to begin the iteration.\n@param forward true means the iterator is in the forward direction","static":false,"name":"getSymbolIterator","comment":"Get iterator over all symbols starting at\n the specified startAddr","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"the address at which to begin the iteration.","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"true means the iterator is in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Get iterator over all primary symbols.\n@param forward true means the iterator is in the forward direction","static":false,"name":"getPrimarySymbolIterator","comment":"Get iterator over all primary symbols.","params":[{"type_long":"boolean","name":"forward","comment":"true means the iterator is in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Get iterator over only primary symbols starting at\n the specified <code>startAddr<\/code>\n@param startAddr the address at which to begin the iteration.\n@param forward true means the iterator is in the forward direction","static":false,"name":"getPrimarySymbolIterator","comment":"Get iterator over only primary symbols starting at\n the specified startAddr","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"the address at which to begin the iteration.","type_short":"Address"},{"type_long":"boolean","name":"forward","comment":"true means the iterator is in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Get an iterator over symbols at addresses in the given addressSet\n@param asv the set of address over which to iterate symbols.\n@param forward true means the iterator is in the forward direction","static":false,"name":"getPrimarySymbolIterator","comment":"Get an iterator over symbols at addresses in the given addressSet","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"asv","comment":"the set of address over which to iterate symbols.","type_short":"AddressSetView"},{"type_long":"boolean","name":"forward","comment":"true means the iterator is in the forward direction","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Sets the given address to be an external entry point.\n@param addr the address to set as an external entry point.","static":false,"name":"addExternalEntryPoint","comment":"Sets the given address to be an external entry point.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to set as an external entry point.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the given address as an external entry point.\n@param addr the address to remove as an external entry point.","static":false,"name":"removeExternalEntryPoint","comment":"Removes the given address as an external entry point.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to remove as an external entry point.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if the given address has been set as an external entry point.\n@param addr address to test for external entry point.","static":false,"name":"isExternalEntryPoint","comment":"Returns true if the given address has been set as an external entry point.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address to test for external entry point.","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get forward\/back iterator over addresses that are entry points.","static":false,"name":"getExternalEntryPointIterator","comment":"Get forward\/back iterator over addresses that are entry points.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressIterator","comment":"","type_short":"AddressIterator"}},{"javadoc":"Get the label history objects for the given address. The history\n object records changes made to labels at some address.\n@param addr address of the label change\n@return array of history objects","static":false,"name":"getLabelHistory","comment":"Get the label history objects for the given address. The history\n object records changes made to labels at some address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"address of the label change","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.LabelHistory[]","comment":"array of history objects","type_short":"ghidra.program.model.symbol.LabelHistory[]"}},{"javadoc":"Get an iterator over all the label history objects.","static":false,"name":"getLabelHistory","comment":"Get an iterator over all the label history objects.","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<ghidra.program.model.symbol.LabelHistory>","comment":"","type_short":"Iterator"}},{"javadoc":"Return true if there is a history of label changes at the given address.\n@param addr the address to check for symbol history.","static":false,"name":"hasLabelHistory","comment":"Return true if there is a history of label changes at the given address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to check for symbol history.","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the lowest level Namespace within which the specified address is contained.\n@param addr the address for which to finds its enclosing namespace.","static":false,"name":"getNamespace","comment":"Returns the lowest level Namespace within which the specified address is contained.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address for which to finds its enclosing namespace.","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"","type_short":"Namespace"}},{"javadoc":"Returns all Class Namespaces defined within the program.","static":false,"name":"getClassNamespaces","comment":"Returns all Class Namespaces defined within the program.","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<ghidra.program.model.listing.GhidraClass>","comment":"","type_short":"Iterator"}},{"javadoc":"Create a class namespace in the given parent namespace.\n@param parent parent namespace\n@param name name of the namespace\n@param source the source of this class namespace's symbol\n@return new class namespace\n@throws DuplicateNameException thrown if another non function or lable symbol exists with the given name\n@throws InvalidInputException throw if the name has invalid characters or is null\n@throws IllegalArgumentException if you try to set the source to 'Symbol.DEFAULT'.","static":false,"name":"createClass","comment":"Create a class namespace in the given parent namespace.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"parent","comment":"parent namespace","type_short":"Namespace"},{"type_long":"java.lang.String","name":"name","comment":"name of the namespace","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this class namespace's symbol","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"thrown if another non function or lable symbol exists with the given name","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"throw if the name has invalid characters or is null","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.listing.GhidraClass","comment":"new class namespace","type_short":"GhidraClass"}},{"javadoc":"Returns an iterator over all symbols that have the given symbol as its parent..\n@param parentSymbol the parent symbol","static":false,"name":"getChildren","comment":"Returns an iterator over all symbols that have the given symbol as its parent..","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"parentSymbol","comment":"the parent symbol","type_short":"Symbol"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.SymbolIterator","comment":"","type_short":"SymbolIterator"}},{"javadoc":"Creates a Library namespace with the given name.\n@param name the name of the new Library namespace\n@param source the source of this external library's symbol\n@return the new Library namespace.\n@throws IllegalArgumentException if you try to set the source to 'Symbol.DEFAULT'.\n@throws DuplicateNameException thrown if another non function or lable symbol exists with the given name","static":false,"name":"createExternalLibrary","comment":"Creates a Library namespace with the given name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the new Library namespace","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this external library's symbol","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"thrown if another non function or lable symbol exists with the given name","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.listing.Library","comment":"the new Library namespace.","type_short":"Library"}},{"javadoc":"Creates a new namespace.\n@param parent the parent namespace for the new namespace\n@param name the name of the new namespace\n@param source the source of this namespace's symbol\n@return the new Namespace object.\n@throws DuplicateNameException thrown if another non function or lable symbol exists with the given name\n@throws InvalidInputException if the name is invalid.\n@throws IllegalArgumentException if you try to set the source to 'Symbol.DEFAULT'.","static":false,"name":"createNameSpace","comment":"Creates a new namespace.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"parent","comment":"the parent namespace for the new namespace","type_short":"Namespace"},{"type_long":"java.lang.String","name":"name","comment":"the name of the new namespace","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this namespace's symbol","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"thrown if another non function or lable symbol exists with the given name","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the name is invalid.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"the new Namespace object.","type_short":"Namespace"}}],"name":"SymbolTable","comment":"A SymbolTable manages the Symbols defined in a program.\n \n A Symbol is an association between an Address,\n a String name. In addition, symbols may have one or more\n References.\n \n A Reference is a 4-tuple of a source address, destination address, type,\n and either a mnemonic or operand index\n \n Any address in a program can have more than one symbol associated to it.\n At any given time, one and only one symbol will be designated as the primary.\n \n A symbol can be either global or local. Local symbols belong to some namespace other than\n the global namespace.\n \n Label and Function symbols do not have to have unique names with a namespace. All other symbols\n must be unique within a namespace and be unique with all other symbols that must be unique.\n In other words you can have a several functions named \"foo\" and several labels named \"foo\"\n in the same namespace.  But you can't have a class named \"foo\" and a namespace named \"foo\".\n But you can have a class named \"foo\" and and many functions and labels named \"foo\" all\n in the same namespace.\n \n A symbol can also be designated as dynamic. Which means the name is\n generated on-the-fly by the system based on its context.","fields":[]}
