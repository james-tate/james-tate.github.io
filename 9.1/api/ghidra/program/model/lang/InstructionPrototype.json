{"implements":[],"javadoc":"InstructionPrototype is designed to describe one machine level instruction.\n A language parser can return the same InstructionProtoype object for the \n same type node. Prototypes for instructions will normally be fixed for a node.","static":false,"methods":[{"javadoc":"Get a new instance of a ParserContext.\n@param buf\n@param processorContext\n@return instruction ParserContext\n@throws MemoryAccessException","static":false,"name":"getParserContext","comment":"Get a new instance of a ParserContext.","params":[{"type_long":"ghidra.program.model.mem.MemBuffer","name":"buf","comment":"","type_short":"MemBuffer"},{"type_long":"ghidra.program.model.lang.ProcessorContextView","name":"processorContext","comment":"","type_short":"ProcessorContextView"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"ghidra.program.model.lang.ParserContext","comment":"instruction ParserContext","type_short":"ParserContext"}},{"javadoc":"Get a ParserContext by parsing bytes outside of the normal disassembly process\n@param addr where the ParserContext is needed\n@param buffer of actual bytes\n@param processorContext\n@return \n@throws InsufficientBytesException\n@throws UnknownInstructionException\n@throws UnknownContextException\n@throws MemoryAccessException","static":false,"name":"getPseudoParserContext","comment":"Get a ParserContext by parsing bytes outside of the normal disassembly process","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"where the ParserContext is needed","type_short":"Address"},{"type_long":"ghidra.program.model.mem.MemBuffer","name":"buffer","comment":"of actual bytes","type_short":"MemBuffer"},{"type_long":"ghidra.program.model.lang.ProcessorContextView","name":"processorContext","comment":"","type_short":"ProcessorContextView"}],"throws":[{"type_long":"ghidra.program.model.lang.InsufficientBytesException","comment":"","type_short":"InsufficientBytesException"},{"type_long":"ghidra.program.model.lang.UnknownInstructionException","comment":"","type_short":"UnknownInstructionException"},{"type_long":"ghidra.program.model.lang.UnknownContextException","comment":"","type_short":"UnknownContextException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"ghidra.program.model.lang.ParserContext","comment":"","type_short":"ParserContext"}},{"javadoc":"@return true if instruction prototype expects one or more delay slotted\n instructions to exist.","static":false,"name":"hasDelaySlots","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if instruction prototype expects one or more delay slotted\n instructions to exist.","type_short":"boolean"}},{"javadoc":"@return true if instruction semantics have a CrossBuild instruction\n dependency which may require a robust InstructionContext with access\n to preceding instructions","static":false,"name":"hasCrossBuildDependency","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if instruction semantics have a CrossBuild instruction\n dependency which may require a robust InstructionContext with access\n to preceding instructions","type_short":"boolean"}},{"javadoc":"Get the mnemonic for this CodeProtype.  Examples: \"MOV\" and\n \"CALL\" for instructions and \"DB\" and \"DA\" for data.\n@param context the instruction context\n@return the mnemonic for this CodePrototype.","static":false,"name":"getMnemonic","comment":"Get the mnemonic for this CodeProtype.  Examples: \"MOV\" and\n \"CALL\" for instructions and \"DB\" and \"DA\" for data.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the mnemonic for this CodePrototype.","type_short":"String"}},{"javadoc":"Get the length of this CodeProtoype.\n@return the length of this CodeProtoype.","static":false,"name":"getLength","comment":"Get the length of this CodeProtoype.","params":[],"throws":[],"return":{"type_long":"int","comment":"the length of this CodeProtoype.","type_short":"int"}},{"javadoc":"Get a Mask that describe which bits of this instruction determine\n the opcode.\n@return a Mask for the opcode bits or null if unknown.","static":false,"name":"getInstructionMask","comment":"Get a Mask that describe which bits of this instruction determine\n the opcode.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Mask","comment":"a Mask for the opcode bits or null if unknown.","type_short":"Mask"}},{"javadoc":"Get a Mask that describe which bits of this instruction determine\n the operand value.\n@return a Mask for the operand bits or null if unknown.","static":false,"name":"getOperandValueMask","comment":"Get a Mask that describe which bits of this instruction determine\n the operand value.","params":[{"type_long":"int","name":"operandIndex","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Mask","comment":"a Mask for the operand bits or null if unknown.","type_short":"Mask"}},{"javadoc":"Get the flow type of this instruction. Used\n for analysis purposes. i.e., how this\n instruction flows to the next instruction.\n@param context the instruction context\n@return flow type.","static":false,"name":"getFlowType","comment":"Get the flow type of this instruction. Used\n for analysis purposes. i.e., how this\n instruction flows to the next instruction.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.FlowType","comment":"flow type.","type_short":"FlowType"}},{"javadoc":"Get the number of delay slot instructions for this\n argument. This should be 0 for instructions which don't have a\n delay slot.  This is used to support the delay slots found on\n some RISC processors such as SPARC and the PA-RISC. This\n returns an integer instead of a boolean in case some other\n processor executes more than one instruction from a delay slot.\n@param context the instruction context\n@return the number of delay slot instructions for this instruction.","static":false,"name":"getDelaySlotDepth","comment":"Get the number of delay slot instructions for this\n argument. This should be 0 for instructions which don't have a\n delay slot.  This is used to support the delay slots found on\n some RISC processors such as SPARC and the PA-RISC. This\n returns an integer instead of a boolean in case some other\n processor executes more than one instruction from a delay slot.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"int","comment":"the number of delay slot instructions for this instruction.","type_short":"int"}},{"javadoc":"@return the number of delay-slot instruction bytes which correspond\n to this prototype.","static":false,"name":"getDelaySlotByteCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of delay-slot instruction bytes which correspond\n to this prototype.","type_short":"int"}},{"javadoc":"Return true if this prototype was disassembled in a delay slot.","static":false,"name":"isInDelaySlot","comment":"Return true if this prototype was disassembled in a delay slot.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Return the number of operands in this instruction.","static":false,"name":"getNumOperands","comment":"Return the number of operands in this instruction.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get the type of a specific operand.\n@param opIndex the index of the operand. (zero based)\n@param context the instruction context.\n@return the type of the operand.","static":false,"name":"getOpType","comment":"Get the type of a specific operand.","params":[{"type_long":"int","name":"opIndex","comment":"the index of the operand. (zero based)","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context.","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"int","comment":"the type of the operand.","type_short":"int"}},{"javadoc":"Get the Address for default flow after instruction.\n@param context the instruction context\n@return Address of fall through flow or null if flow\n does not fall through this instruction.","static":false,"name":"getFallThrough","comment":"Get the Address for default flow after instruction.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"Address of fall through flow or null if flow\n does not fall through this instruction.","type_short":"Address"}},{"javadoc":"Get the byte offset to the default flow after instruction.\n If this instruction does not have a fall-through due to flow\n behavior, this method will still return an offset which accounts for \n the instruction length including delay slotted instructions if \n applicable.\n@param context the instruction context\n@return int how much to add to the current address to get\n the fall through address.","static":false,"name":"getFallThroughOffset","comment":"Get the byte offset to the default flow after instruction.\n If this instruction does not have a fall-through due to flow\n behavior, this method will still return an offset which accounts for \n the instruction length including delay slotted instructions if \n applicable.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"int","comment":"int how much to add to the current address to get\n the fall through address.","type_short":"int"}},{"javadoc":"Get an array of Address objects for all flows other than\n a fall-through, null if no flows.\n@param context the instruction context.\n@return an array of Address objects for all flows other than\n  a fall-through, null if no flows.","static":false,"name":"getFlows","comment":"Get an array of Address objects for all flows other than\n a fall-through, null if no flows.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context.","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address[]","comment":"an array of Address objects for all flows other than\n  a fall-through, null if no flows.","type_short":"ghidra.program.model.address.Address[]"}},{"javadoc":"Get the separator strings between an operand.\n \n The separator string for 0 are the characters before the first operand.\n The separator string for numOperands+1 are the characters after the last operand.\n@param opIndex valid values are 0 thru numOperands+1\n@param context the instruction context\n@return separator string, or null if there is no string","static":false,"name":"getSeparator","comment":"Get the separator strings between an operand.\n \n The separator string for 0 are the characters before the first operand.\n The separator string for numOperands+1 are the characters after the last operand.","params":[{"type_long":"int","name":"opIndex","comment":"valid values are 0 thru numOperands+1","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"separator string, or null if there is no string","type_short":"String"}},{"javadoc":"Get a List of Objects that can be used to render an operands representation.\n@param opIndex operand to get the Representation List\n@param context the instruction context\n@return ArrayList of Register, Address, Scalar, VariableOffset and Character objects\n         of null if the operation isn't supported","static":false,"name":"getOpRepresentationList","comment":"Get a List of Objects that can be used to render an operands representation.","params":[{"type_long":"int","name":"opIndex","comment":"operand to get the Representation List","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"java.util.ArrayList<java.lang.Object>","comment":"ArrayList of Register, Address, Scalar, VariableOffset and Character objects\n         of null if the operation isn't supported","type_short":"ArrayList"}},{"javadoc":"If the indicated operand is an address, this gets the address value for \n that operand\n@param opIndex index of the operand.\n@param context the instruction context.\n@return the address indicated by the operand","static":false,"name":"getAddress","comment":"If the indicated operand is an address, this gets the address value for \n that operand","params":[{"type_long":"int","name":"opIndex","comment":"index of the operand.","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context.","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the address indicated by the operand","type_short":"Address"}},{"javadoc":"If the indicated operand is a scalar, this gets the scalar value for \n that operand\n@param opIndex index of the operand.\n@param context the instruction context\n@return the scalar for the indicated operand","static":false,"name":"getScalar","comment":"If the indicated operand is a scalar, this gets the scalar value for \n that operand","params":[{"type_long":"int","name":"opIndex","comment":"index of the operand.","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"ghidra.program.model.scalar.Scalar","comment":"the scalar for the indicated operand","type_short":"Scalar"}},{"javadoc":"If the indicated operand is a register, this gets the register value \n for that operand\n@param opIndex index of the operand.\n@param context the instruction context\n@return a register description for the indicated operand","static":false,"name":"getRegister","comment":"If the indicated operand is a register, this gets the register value \n for that operand","params":[{"type_long":"int","name":"opIndex","comment":"index of the operand.","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Register","comment":"a register description for the indicated operand","type_short":"Register"}},{"javadoc":"Get objects used by this operand (Address, Scalar, Register ...)\n@param opIndex the index of the operand. (zero based)\n@param context the instruction context\n@return an array of objects found at this operand.","static":false,"name":"getOpObjects","comment":"Get objects used by this operand (Address, Scalar, Register ...)","params":[{"type_long":"int","name":"opIndex","comment":"the index of the operand. (zero based)","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"java.lang.Object[]","comment":"an array of objects found at this operand.","type_short":"java.lang.Object[]"}},{"javadoc":"Get the suggested operand reference type.\n@param opIndex the index of the operand. (zero based)\n@param context the instruction context\n@param override if not null, steers local overrides of pcode generation\n@param uniqueFactory must be specified if flowOverride is not null\n@return reference type.","static":false,"name":"getOperandRefType","comment":"Get the suggested operand reference type.","params":[{"type_long":"int","name":"opIndex","comment":"the index of the operand. (zero based)","type_short":"int"},{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"},{"type_long":"ghidra.program.model.pcode.PcodeOverride","name":"override","comment":"if not null, steers local overrides of pcode generation","type_short":"PcodeOverride"},{"type_long":"ghidra.program.model.address.UniqueAddressFactory","name":"uniqueFactory","comment":"must be specified if flowOverride is not null","type_short":"UniqueAddressFactory"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.RefType","comment":"reference type.","type_short":"RefType"}},{"javadoc":"Return true if the operand at opIndex should have a delimiter following it.\n@param opIndex the index of the operand to test for having a delimiter.","static":false,"name":"hasDelimeter","comment":"Return true if the operand at opIndex should have a delimiter following it.","params":[{"type_long":"int","name":"opIndex","comment":"the index of the operand to test for having a delimiter.","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get the Result objects produced\/affected by this instruction\n These would probably only be Register or Address\n@param context the instruction context\n@return an array of objects that are used by this instruction","static":false,"name":"getInputObjects","comment":"Get the Result objects produced\/affected by this instruction\n These would probably only be Register or Address","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"java.lang.Object[]","comment":"an array of objects that are used by this instruction","type_short":"java.lang.Object[]"}},{"javadoc":"Get the Result objects produced\/affected by this instruction\n These would probably only be Register or Address\n@param context the instruction context\n@return an array of objects that are affected by this instruction","static":false,"name":"getResultObjects","comment":"Get the Result objects produced\/affected by this instruction\n These would probably only be Register or Address","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"}],"throws":[],"return":{"type_long":"java.lang.Object[]","comment":"an array of objects that are affected by this instruction","type_short":"java.lang.Object[]"}},{"javadoc":"Get an array of PCode operations (micro code) that this instruction\n performs.\n@param context the instruction context\n@param override if not null, may indicate that different elements of the pcode generation are overridden\n@param uniqueFactory must be specified if flowOverride is not null\n@return array of PCODE,\n         zero length array if language doesn't support PCODE for this instruction","static":false,"name":"getPcode","comment":"Get an array of PCode operations (micro code) that this instruction\n performs.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"},{"type_long":"ghidra.program.model.pcode.PcodeOverride","name":"override","comment":"if not null, may indicate that different elements of the pcode generation are overridden","type_short":"PcodeOverride"},{"type_long":"ghidra.program.model.address.UniqueAddressFactory","name":"uniqueFactory","comment":"must be specified if flowOverride is not null","type_short":"UniqueAddressFactory"}],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.PcodeOp[]","comment":"array of PCODE,\n         zero length array if language doesn't support PCODE for this instruction","type_short":"ghidra.program.model.pcode.PcodeOp[]"}},{"javadoc":"Same as getPcode but returns the operations in a packed format to optimize transfer to other processes\n@param context the instruction context\n@param override if not null, may indicate that different elements of the pcode generation are overridden\n@param uniqueFactory must be specified if flowOverride is not null\n@return ","static":false,"name":"getPcodePacked","comment":"Same as getPcode but returns the operations in a packed format to optimize transfer to other processes","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"},{"type_long":"ghidra.program.model.pcode.PcodeOverride","name":"override","comment":"if not null, may indicate that different elements of the pcode generation are overridden","type_short":"PcodeOverride"},{"type_long":"ghidra.program.model.address.UniqueAddressFactory","name":"uniqueFactory","comment":"must be specified if flowOverride is not null","type_short":"UniqueAddressFactory"}],"throws":[],"return":{"type_long":"ghidra.program.model.lang.PackedBytes","comment":"","type_short":"PackedBytes"}},{"javadoc":"Get an array of PCode operations (micro code) that a particular operand\n performs to compute its value.\n@param context the instruction context\n@param opIndex the index of the operand for which to get PCode.\n@return array of PCODE,\n         zero length array if language doesn't support PCODE for this instruction","static":false,"name":"getPcode","comment":"Get an array of PCode operations (micro code) that a particular operand\n performs to compute its value.","params":[{"type_long":"ghidra.program.model.lang.InstructionContext","name":"context","comment":"the instruction context","type_short":"InstructionContext"},{"type_long":"int","name":"opIndex","comment":"the index of the operand for which to get PCode.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.PcodeOp[]","comment":"array of PCODE,\n         zero length array if language doesn't support PCODE for this instruction","type_short":"ghidra.program.model.pcode.PcodeOp[]"}},{"javadoc":"Get processor language module associated with this prototype.\n@return language module","static":false,"name":"getLanguage","comment":"Get processor language module associated with this prototype.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.Language","comment":"language module","type_short":"Language"}}],"name":"InstructionPrototype","comment":"InstructionPrototype is designed to describe one machine level instruction.\n A language parser can return the same InstructionProtoype object for the \n same type node. Prototypes for instructions will normally be fixed for a node.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"INVALID_DEPTH_CHANGE","comment":"","type_short":"int","constant_value":"16777216"}]}
