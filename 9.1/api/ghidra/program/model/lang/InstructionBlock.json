{"implements":["java.lang.Iterable"],"javadoc":"Represents a block of instructions.  Used as part of an InstructionSet to be added to the\n program.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Allows the block to be tagged as start of flow to force\n InstructionSet iterator to treat as a flow start.\n This method should not be used after this block has\n been added to an InstructionSet\n@param isStart","static":false,"name":"setStartOfFlow","comment":"Allows the block to be tagged as start of flow to force\n InstructionSet iterator to treat as a flow start.\n This method should not be used after this block has\n been added to an InstructionSet","params":[{"type_long":"boolean","name":"isStart","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return true if this block should be treated as the start of a new \n flow when added to a InstructionSet.","static":false,"name":"isFlowStart","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this block should be treated as the start of a new \n flow when added to a InstructionSet.","type_short":"boolean"}},{"javadoc":"Returns the minimum\/start address of the block;\n@return the minimum\/start address of the block","static":false,"name":"getStartAddress","comment":"Returns the minimum\/start address of the block;","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the minimum\/start address of the block","type_short":"Address"}},{"javadoc":"Returns the maximum address of the block, or null if the block is empty;\n@return the maximum address of the block.","static":false,"name":"getMaxAddress","comment":"Returns the maximum address of the block, or null if the block is empty;","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the maximum address of the block.","type_short":"Address"}},{"javadoc":"Returns the instruction at the specified address within this block\n@param address\n@return instruction at the specified address within this block or null if not found","static":false,"name":"getInstructionAt","comment":"Returns the instruction at the specified address within this block","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"instruction at the specified address within this block or null if not found","type_short":"Instruction"}},{"javadoc":"Find the first instruction within this block which intersects the specified range.\n This method should be used sparingly since it uses a brute-force search.\n@param address\n@return instruction within this block which intersects the specified range or null\n if not found","static":false,"name":"findFirstIntersectingInstruction","comment":"Find the first instruction within this block which intersects the specified range.\n This method should be used sparingly since it uses a brute-force search.","params":[{"type_long":"ghidra.program.model.address.Address","name":"min","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"max","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"instruction within this block which intersects the specified range or null\n if not found","type_short":"Instruction"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Adds an instruction to this block.  If the block in not empty, the newly added instruction\n must be directly after the current block maximum address.  In other words, all instructions\n int the block must be consecutive.\n@param instruction the instruction to add to this block.\n@throws IllegalArgumentException if the new instruction does not immediately follow the\n last instruction added.","static":false,"name":"addInstruction","comment":"Adds an instruction to this block.  If the block in not empty, the newly added instruction\n must be directly after the current block maximum address.  In other words, all instructions\n int the block must be consecutive.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"the instruction to add to this block.","type_short":"Instruction"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add a block flow specified by a InstructionBlockFlow object.  These flows include all\n calls, branches and fall-throughs and may span across multiple InstructionSets and are\n not used by the block flow iterator within the associated InstructionSet.\n@param blockFlow block flow","static":false,"name":"addBlockFlow","comment":"Add a block flow specified by a InstructionBlockFlow object.  These flows include all\n calls, branches and fall-throughs and may span across multiple InstructionSets and are\n not used by the block flow iterator within the associated InstructionSet.","params":[{"type_long":"ghidra.program.model.lang.InstructionBlockFlow","name":"blockFlow","comment":"block flow","type_short":"InstructionBlockFlow"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a branch type flow to this instruction block and is used by the block flow\n iterator of the associated InstructionSet.\n@param destinationAddress the destination of a branch type flow from this instruction block.","static":false,"name":"addBranchFlow","comment":"Adds a branch type flow to this instruction block and is used by the block flow\n iterator of the associated InstructionSet.","params":[{"type_long":"ghidra.program.model.address.Address","name":"destinationAddress","comment":"the destination of a branch type flow from this instruction block.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the fall through address for this block and is used by the block flow\n iterator of the associated InstructionSet.  The fallthrough should not be \n set if it is added as a block flow.\n@param fallthroughAddress the address of the fallthrough","static":false,"name":"setFallThrough","comment":"Sets the fall through address for this block and is used by the block flow\n iterator of the associated InstructionSet.  The fallthrough should not be \n set if it is added as a block flow.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fallthroughAddress","comment":"the address of the fallthrough","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a list of all the branch flows that were added to this instruction block\n and flow to other blocks within the associated InstructionSet.\n@return a list of all the branch flows that were added to this instruction block.","static":false,"name":"getBranchFlows","comment":"Returns a list of all the branch flows that were added to this instruction block\n and flow to other blocks within the associated InstructionSet.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.address.Address>","comment":"a list of all the branch flows that were added to this instruction block.","type_short":"List"}},{"javadoc":"Returns a list of all block flows that were added to this instruction block as\n a list of InstructionBlockFlow objects.  NOTE: These flows may not be contained \n within the associated InstructionSet.\n@return a list of all flows that were added to this instruction block.","static":false,"name":"getBlockFlows","comment":"Returns a list of all block flows that were added to this instruction block as\n a list of InstructionBlockFlow objects.  NOTE: These flows may not be contained \n within the associated InstructionSet.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.lang.InstructionBlockFlow>","comment":"a list of all flows that were added to this instruction block.","type_short":"List"}},{"javadoc":"Returns the fallthrough address.  Null is returned if there is no fall through.\n@return the fallthrough address.","static":false,"name":"getFallThrough","comment":"Returns the fallthrough address.  Null is returned if there is no fall through.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the fallthrough address.","type_short":"Address"}},{"javadoc":"Sets this block to have an instruction error.\n@param type The type of error\/conflict.\n@param intendedInstructionAddress address of intended instruction which failed to be created\n@param conflictAddress the address of the exiting code unit that is preventing the instruction in this\n block to be laid down (required for CODE_UNIT or DUPLCIATE conflict error).\n@param flowFromAddress the flow-from instruction address or null if unknown\n@param message - A message that describes the conflict to a user.","static":false,"name":"setInstructionError","comment":"Sets this block to have an instruction error.","params":[{"type_long":"ghidra.program.model.lang.InstructionError.InstructionErrorType","name":"type","comment":"The type of error\/conflict.","type_short":"InstructionErrorType"},{"type_long":"ghidra.program.model.address.Address","name":"intendedInstructionAddress","comment":"address of intended instruction which failed to be created","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"conflictAddress","comment":"the address of the exiting code unit that is preventing the instruction in this\n block to be laid down (required for CODE_UNIT or DUPLCIATE conflict error).","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"flowFromAddress","comment":"the flow-from instruction address or null if unknown","type_short":"Address"},{"type_long":"java.lang.String","name":"message","comment":"- A message that describes the conflict to a user.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set instruction memory error\n@param instrAddr instruction address\n@param flowFromAddr flow-from address\n@param errorMsg","static":false,"name":"setInstructionMemoryError","comment":"Set instruction memory error","params":[{"type_long":"ghidra.program.model.address.Address","name":"instrAddr","comment":"instruction address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"flowFromAddr","comment":"flow-from address","type_short":"Address"},{"type_long":"java.lang.String","name":"errorMsg","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set inconsistent instruction prototype CODE_UNIT conflict\n@param instrAddr instruction addr where inconsistent prototype exists\n@param flowFromAddr flow-from address","static":false,"name":"setInconsistentPrototypeConflict","comment":"Set inconsistent instruction prototype CODE_UNIT conflict","params":[{"type_long":"ghidra.program.model.address.Address","name":"instrAddr","comment":"instruction addr where inconsistent prototype exists","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"flowFromAddr","comment":"flow-from address","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set offcut-instruction or data CODE_UNIT conflict\n@param codeUnitAddr existing instruction\/data address\n@param newInstrAddr new disassembled instruction address\n@param flowFromAddr flow-from address\n@param isInstruction true if conflict is due to offcut-instruction, otherwise data is assumed\n@param isOffcutOrData true if conflict due to offcut instruction","static":false,"name":"setCodeUnitConflict","comment":"Set offcut-instruction or data CODE_UNIT conflict","params":[{"type_long":"ghidra.program.model.address.Address","name":"codeUnitAddr","comment":"existing instruction\/data address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"newInstrAddr","comment":"new disassembled instruction address","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"flowFromAddr","comment":"flow-from address","type_short":"Address"},{"type_long":"boolean","name":"isInstruction","comment":"true if conflict is due to offcut-instruction, otherwise data is assumed","type_short":"boolean"},{"type_long":"boolean","name":"isOffcut","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets this block to have a PARSE conflict which means that the instruction parse failed\n at the specified conflictAddress using the specified contextValue.\n@param conflictAddress the address of the exiting code unit that is preventing the instruction in this\n block to be laid down.\n@param contextValue the context-register value used during the failed parse attempt\n@param flowFromAddress the flow-from instruction address or null\n@param message - A message that describes the conflict to a user.","static":false,"name":"setParseConflict","comment":"Sets this block to have a PARSE conflict which means that the instruction parse failed\n at the specified conflictAddress using the specified contextValue.","params":[{"type_long":"ghidra.program.model.address.Address","name":"conflictAddress","comment":"the address of the exiting code unit that is preventing the instruction in this\n block to be laid down.","type_short":"Address"},{"type_long":"ghidra.program.model.lang.RegisterValue","name":"contextValue","comment":"the context-register value used during the failed parse attempt","type_short":"RegisterValue"},{"type_long":"ghidra.program.model.address.Address","name":"flowFromAddress","comment":"the flow-from instruction address or null","type_short":"Address"},{"type_long":"java.lang.String","name":"message","comment":"- A message that describes the conflict to a user.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Clears any conflict associated with this block.","static":false,"name":"clearConflict","comment":"Clears any conflict associated with this block.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the current conflict associated with this block.\n@return the current conflict associated with this block.","static":false,"name":"getInstructionConflict","comment":"Returns the current conflict associated with this block.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.InstructionError","comment":"the current conflict associated with this block.","type_short":"InstructionError"}},{"javadoc":"Returns an iterator over all the instructions in this block.","static":false,"name":"iterator","comment":"Returns an iterator over all the instructions in this block.","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<ghidra.program.model.listing.Instruction>","comment":"","type_short":"Iterator"}},{"javadoc":"@return address of last instruction contained within this block","static":false,"name":"getLastInstructionAddress","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"address of last instruction contained within this block","type_short":"Address"}},{"javadoc":"@return true if no instructions exist within this block","static":false,"name":"isEmpty","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if no instructions exist within this block","type_short":"boolean"}},{"javadoc":"@return number of instructions contained within this block","static":false,"name":"getInstructionCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"number of instructions contained within this block","type_short":"int"}},{"javadoc":"@return number of instructions which were added to the program\n successfully.","static":false,"name":"getInstructionsAddedCount","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"number of instructions which were added to the program\n successfully.","type_short":"int"}},{"javadoc":"Set the number of instructions which were added to the program\n@param count","static":false,"name":"setInstructionsAddedCount","comment":"Set the number of instructions which were added to the program","params":[{"type_long":"int","name":"count","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getFlowFromAddress","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"setFlowFromAddress","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"flowFrom","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"hasInstructionError","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"InstructionBlock","comment":"Represents a block of instructions.  Used as part of an InstructionSet to be added to the\n program.","fields":[{"type_long":"boolean","javadoc":"","static":false,"name":"isStartOfFlow","comment":"","type_short":"boolean","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"startAddr","comment":"","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"maxAddress","comment":"","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"flowFrom","comment":"","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"lastInstructionAddress","comment":"","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"fallthroughAddress","comment":"","type_short":"Address","constant_value":null},{"type_long":"java.util.LinkedHashMap<ghidra.program.model.address.Address,ghidra.program.model.listing.Instruction>","javadoc":"","static":false,"name":"instructionMap","comment":"","type_short":"LinkedHashMap","constant_value":null},{"type_long":"java.util.List<ghidra.program.model.address.Address>","javadoc":"","static":false,"name":"flowAddresses","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.List<ghidra.program.model.lang.InstructionBlockFlow>","javadoc":"","static":false,"name":"blockFlows","comment":"","type_short":"List","constant_value":null},{"type_long":"ghidra.program.model.lang.InstructionError","javadoc":"","static":false,"name":"instructionError","comment":"","type_short":"InstructionError","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"instructionsAddedCount","comment":"","type_short":"int","constant_value":null}]}
