{"implements":[],"javadoc":"Address class for dealing with (intel) segmented addresses.  The class itself is agnostic\n about the mapping from segmented encoding to flat address offset, it uses the\n SegmentedAddressSpace to perform this mapping. So the same class can be used to represent\n either a real-mode address or a protected-mode address.  The class uses the underlying\n offset field to hold the flat encoding.","static":false,"extends":"ghidra.program.model.address.GenericAddress","methods":[{"javadoc":"Constructor for SegmentedAddress.\n Offset is not validated against address space.\n@param addrSpace is the address space for this address\n@param flat is the flat offset into the space","static":false,"name":"<init>","comment":"Constructor for SegmentedAddress.\n Offset is not validated against address space.","params":[{"type_long":"long","name":"flat","comment":"is the flat offset into the space","type_short":"long"},{"type_long":"ghidra.program.model.address.SegmentedAddressSpace","name":"addrSpace","comment":"is the address space for this address","type_short":"SegmentedAddressSpace"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructor for SegmentedAddress.\n@param addrSpace is the address space for this address\n@param segment is the segment number\n@param segmentOffset is the offset into the segment\n@throws AddressOutOfBoundsException if the  address does not fit in the space","static":false,"name":"<init>","comment":"Constructor for SegmentedAddress.","params":[{"type_long":"ghidra.program.model.address.SegmentedAddressSpace","name":"addrSpace","comment":"is the address space for this address","type_short":"SegmentedAddressSpace"},{"type_long":"int","name":"segment","comment":"is the segment number","type_short":"int"},{"type_long":"int","name":"segmentOffset","comment":"is the offset into the segment","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOutOfBoundsException","comment":"if the  address does not fit in the space","type_short":"AddressOutOfBoundsException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructor for SegmentedAddress.\n@param addrSpace address space for this address\n@param flat is the flat offset into the space\n@throws AddressOutOfBoundsException if the flat address does not fit in the space","static":false,"name":"<init>","comment":"Constructor for SegmentedAddress.","params":[{"type_long":"ghidra.program.model.address.SegmentedAddressSpace","name":"addrSpace","comment":"address space for this address","type_short":"SegmentedAddressSpace"},{"type_long":"long","name":"flat","comment":"is the flat offset into the space","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOutOfBoundsException","comment":"if the flat address does not fit in the space","type_short":"AddressOutOfBoundsException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"adjustOffset","comment":"","params":[{"type_long":"long","name":"flat","comment":"","type_short":"long"},{"type_long":"ghidra.program.model.address.SegmentedAddressSpace","name":"addrSpace","comment":"","type_short":"SegmentedAddressSpace"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Returns the segment value\n@return int the segment value","static":false,"name":"getSegment","comment":"Returns the segment value","params":[],"throws":[],"return":{"type_long":"int","comment":"int the segment value","type_short":"int"}},{"javadoc":"Returns the offset within the segment.\n@return the offset value","static":false,"name":"getSegmentOffset","comment":"Returns the offset within the segment.","params":[],"throws":[],"return":{"type_long":"int","comment":"the offset value","type_short":"int"}},{"javadoc":"Returns a new address that is equivalent to this address using\n the given segment number.\n@param seg the seqment value to normalize to.\n@return the new address","static":false,"name":"normalize","comment":"Returns a new address that is equivalent to this address using\n the given segment number.","params":[{"type_long":"int","name":"seg","comment":"the seqment value to normalize to.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.SegmentedAddress","comment":"the new address","type_short":"SegmentedAddress"}},{"javadoc":"Return a new segmented address. An attempt is made to normalize to this addresses segment.\n@see ghidra.program.model.address.Address#getNewAddress(long)","static":false,"name":"getNewAddress","comment":"Return a new segmented address. An attempt is made to normalize to this addresses segment.","params":[{"type_long":"long","name":"byteOffset","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"getNewAddress","comment":"","params":[{"type_long":"long","name":"addrOffset","comment":"","type_short":"long"},{"type_long":"boolean","name":"isAddressableWordOffset","comment":"","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOutOfBoundsException","comment":"","type_short":"AddressOutOfBoundsException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"getNewTruncatedAddress","comment":"","params":[{"type_long":"long","name":"addrOffset","comment":"","type_short":"long"},{"type_long":"boolean","name":"isAddressableWordOffset","comment":"","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOutOfBoundsException","comment":"","type_short":"AddressOutOfBoundsException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Returns the String for the given value\n@param value the value to convert to a string.\n@return String the converted value string.","static":false,"name":"getString","comment":"Returns the String for the given value","params":[{"type_long":"long","name":"value","comment":"the value to convert to a string.","type_short":"long"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"String the converted value string.","type_short":"String"}},{"javadoc":"@see ghidra.program.model.address.Address#toString(String)","static":false,"name":"toString","comment":"","params":[{"type_long":"java.lang.String","name":"prefix","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"@see ghidra.program.model.address.Address#getPhysicalAddress()","static":false,"name":"getPhysicalAddress","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[{"type_long":"boolean","name":"showAddressSpace","comment":"","type_short":"boolean"},{"type_long":"int","name":"minNumDigits","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}}],"name":"SegmentedAddress","comment":"Address class for dealing with (intel) segmented addresses.  The class itself is agnostic\n about the mapping from segmented encoding to flat address offset, it uses the\n SegmentedAddressSpace to perform this mapping. So the same class can be used to represent\n either a real-mode address or a protected-mode address.  The class uses the underlying\n offset field to hold the flat encoding.","fields":[{"type_long":"int","javadoc":"","static":false,"name":"segment","comment":"","type_short":"int","constant_value":null}]}
