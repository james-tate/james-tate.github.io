{"implements":["java.lang.Comparable"],"javadoc":"An address represents a location in a program.  Conceptually, addresses consist\n of an \"address space\" and an offset within that space.  Many processors have only\n one \"real\" address space, but some have several spaces. Also, there are\n \"artificial\" address spaces used for analysis and representing other non-memory locations\n such as a register or an offset on the stack relative to a functions frame pointer.","static":false,"methods":[{"javadoc":"Creates a new Address by parsing a String representation of an address. The\n string may be either a simple number (just the offset part of an address) or take\n the form \"addressSpaceName:offset\".  If the latter form is used, the \n \"addressSpaceName\" must match the name of the space for this address.\n@param addrString the String to parse.\n@return the new Address if the string is a legally formed address or null\n if the string contains an address space name that does not match this address's space.\n@throws AddressFormatException if the string cannot be parsed or the\n parsed offset is larger than the size for this address' space.","static":false,"name":"getAddress","comment":"Creates a new Address by parsing a String representation of an address. The\n string may be either a simple number (just the offset part of an address) or take\n the form \"addressSpaceName:offset\".  If the latter form is used, the \n \"addressSpaceName\" must match the name of the space for this address.","params":[{"type_long":"java.lang.String","name":"addrString","comment":"the String to parse.","type_short":"String"}],"throws":[{"type_long":"ghidra.program.model.address.AddressFormatException","comment":"if the string cannot be parsed or the\n parsed offset is larger than the size for this address' space.","type_short":"AddressFormatException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the new Address if the string is a legally formed address or null\n if the string contains an address space name that does not match this address's space.","type_short":"Address"}},{"javadoc":"Creates a new Address in this address's space with the given byte offset.\n@param byteOffset the byte offset for the new address.\n@return the new Address.\n@throws AddressOutOfBoundsException if the offset is less than the minimum offset or \n greater than the max offset allowed for this space.","static":false,"name":"getNewAddress","comment":"Creates a new Address in this address's space with the given byte offset.","params":[{"type_long":"long","name":"byteOffset","comment":"the byte offset for the new address.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the new Address.","type_short":"Address"}},{"javadoc":"Returns a new address in this address's space with the given offset.  \n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to an addressable unit\/word boundary if a byte-offset \n is specified.\n@param offset the offset for the new address.\n@param isAddressableWordOffset if true the specified offset is an addressable unit\/word offset,\n otherwise offset is a byte offset.  See {@link #getAddressableUnitSize()}\n to understand the distinction (i.e., wordOffset = byteOffset * addressableUnitSize).\n@return address with given offset\n@throws AddressOutOfBoundsException if the offset is less than 0 or greater\n than the max offset allowed for this space.","static":false,"name":"getNewAddress","comment":"Returns a new address in this address's space with the given offset.  \n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to an addressable unit\/word boundary if a byte-offset \n is specified.","params":[{"type_long":"long","name":"offset","comment":"the offset for the new address.","type_short":"long"},{"type_long":"boolean","name":"isAddressableWordOffset","comment":"if true the specified offset is an addressable unit\/word offset,\n otherwise offset is a byte offset.  See #getAddressableUnitSize()\n to understand the distinction (i.e., wordOffset = byteOffset * addressableUnitSize).","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOutOfBoundsException","comment":"if the offset is less than 0 or greater\n than the max offset allowed for this space.","type_short":"AddressOutOfBoundsException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"address with given offset","type_short":"Address"}},{"javadoc":"Returns a new address in this address's space with the given offset.  The specified \n offset will be truncated within the space and will not throw an exception.\n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to a word boundary (addressable unit) if a byte-offset \n is specified.\n@param offset the offset for the new address.\n@param isAddressableWordOffset if true the specified offset is an addressable unit\/word offset,\n otherwise offset is a byte offset.  See {@link #getAddressableUnitSize()}\n to understand the distinction (i.e., wordOffset = byteOffset * addressableUnitSize).\n@return address with given byte offset truncated to the physical space size","static":false,"name":"getNewTruncatedAddress","comment":"Returns a new address in this address's space with the given offset.  The specified \n offset will be truncated within the space and will not throw an exception.\n NOTE: for those spaces with an addressable unit size other than 1, the address\n returned may not correspond to a word boundary (addressable unit) if a byte-offset \n is specified.","params":[{"type_long":"long","name":"offset","comment":"the offset for the new address.","type_short":"long"},{"type_long":"boolean","name":"isAddressableWordOffset","comment":"if true the specified offset is an addressable unit\/word offset,\n otherwise offset is a byte offset.  See #getAddressableUnitSize()\n to understand the distinction (i.e., wordOffset = byteOffset * addressableUnitSize).","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"address with given byte offset truncated to the physical space size","type_short":"Address"}},{"javadoc":"Returns the number of bytes needed to form a pointer to this address.  The\n result will be one of {1,2,4,8}.\n@see DataOrganization#getPointerSize() for compiler-specific size of pointers stored in memory.","static":false,"name":"getPointerSize","comment":"Returns the number of bytes needed to form a pointer to this address.  The\n result will be one of {1,2,4,8}.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Returns the address's successor.  In most cases, this is equivalent\n to addr.add(1), but segmented addresses could span segments.  The result\n of calling this on the highest address will result in a null return value.\n@return the next higher address, or null if already at the\n highest address.","static":false,"name":"next","comment":"Returns the address's successor.  In most cases, this is equivalent\n to addr.add(1), but segmented addresses could span segments.  The result\n of calling this on the highest address will result in a null return value.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the next higher address, or null if already at the\n highest address.","type_short":"Address"}},{"javadoc":"Returns the address's predecessor.  In most cases, this is equivalent to\n addr.subtract(1), but segmented addresses could span segments.  The\n result of calling this on the lowest address will result in a null return value.\n@return the next lower address, or null if already at the\n  lowest address.","static":false,"name":"previous","comment":"Returns the address's predecessor.  In most cases, this is equivalent to\n addr.subtract(1), but segmented addresses could span segments.  The\n result of calling this on the lowest address will result in a null return value.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the next lower address, or null if already at the\n  lowest address.","type_short":"Address"}},{"javadoc":"Get the offset of this Address.\n@return the offset of this Address.","static":false,"name":"getOffset","comment":"Get the offset of this Address.","params":[],"throws":[],"return":{"type_long":"long","comment":"the offset of this Address.","type_short":"long"}},{"javadoc":"Get the offset of this Address as a BigInteger\n@return the offset of this Address.","static":false,"name":"getOffsetAsBigInteger","comment":"Get the offset of this Address as a BigInteger","params":[],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"the offset of this Address.","type_short":"BigInteger"}},{"javadoc":"Get the address offset as an unsigned number.\n This may be useful when dealing with signed spaces (e.g. stack)\n@return unsigned address offset","static":false,"name":"getUnsignedOffset","comment":"Get the address offset as an unsigned number.\n This may be useful when dealing with signed spaces (e.g. stack)","params":[],"throws":[],"return":{"type_long":"long","comment":"unsigned address offset","type_short":"long"}},{"javadoc":"Get the addressable memory word offset which corresponds to this address.\n@return addressable memory word offset","static":false,"name":"getAddressableWordOffset","comment":"Get the addressable memory word offset which corresponds to this address.","params":[],"throws":[],"return":{"type_long":"long","comment":"addressable memory word offset","type_short":"long"}},{"javadoc":"Returns the address space associated with this address.","static":false,"name":"getAddressSpace","comment":"Returns the address space associated with this address.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"","type_short":"AddressSpace"}},{"javadoc":"Return true if this address' address space is equal to the\n address space for addr.","static":false,"name":"hasSameAddressSpace","comment":"Return true if this address' address space is equal to the\n address space for addr.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns the number of bits that are used to form the address.  Thus\n the maximum offset for this address space will be 2^size-1.","static":false,"name":"getSize","comment":"Returns the number of bits that are used to form the address.  Thus\n the maximum offset for this address space will be 2^size-1.","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Calculates the displacement between two addresses (<code>this - addr<\/code>)\n@param addr the Address to subtract from <code>this<\/code> address\n@return the difference (thisAddress.offset - thatAddress.offset)\n@throws IllegalArgumentException if the two addresses are not in the same address space","static":false,"name":"subtract","comment":"Calculates the displacement between two addresses (this - addr)","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the Address to subtract from this address","type_short":"Address"}],"throws":[],"return":{"type_long":"long","comment":"the difference (thisAddress.offset - thatAddress.offset)","type_short":"long"}},{"javadoc":"Creates a new address by subtracting the displacement from the current \n address. The new address will wrap in a manner that depends on the \n address space. For a generic address space this will wrap at the \n extents of the address space. For a segmented address space it will \n wrap at the extents of the segment.\n@param displacement the displacement to subtract.\n@return The new Address formed by subtracting the displacement for the offset.","static":false,"name":"subtractWrap","comment":"Creates a new address by subtracting the displacement from the current \n address. The new address will wrap in a manner that depends on the \n address space. For a generic address space this will wrap at the \n extents of the address space. For a segmented address space it will \n wrap at the extents of the segment.","params":[{"type_long":"long","name":"displacement","comment":"the displacement to subtract.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new Address formed by subtracting the displacement for the offset.","type_short":"Address"}},{"javadoc":"Creates a new address by subtracting the displacement from the current \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as subtractWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.\n@param displacement the displacement to add.\n@return The new Address formed by subtracting the displacement from this address's offset.","static":false,"name":"subtractWrapSpace","comment":"Creates a new address by subtracting the displacement from the current \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as subtractWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.","params":[{"type_long":"long","name":"displacement","comment":"the displacement to add.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new Address formed by subtracting the displacement from this address's offset.","type_short":"Address"}},{"javadoc":"Creates a new Address by subtracting displacement from the\n Address.  The Address will not wrap within the space and in fact will throw\n an exception if the result is less than the min address in this space or\n greater than the max address in this space.\n@param displacement the displacement to subtract.\n@return The new Address\n@throws AddressOverflowException if the offset in this Address would\n  overflow due to this operation.","static":false,"name":"subtractNoWrap","comment":"Creates a new Address by subtracting displacement from the\n Address.  The Address will not wrap within the space and in fact will throw\n an exception if the result is less than the min address in this space or\n greater than the max address in this space.","params":[{"type_long":"long","name":"displacement","comment":"the displacement to subtract.","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the offset in this Address would\n  overflow due to this operation.","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new Address","type_short":"Address"}},{"javadoc":"Creates a new address (possibly in a new space) by subtracting the displacement to \n this address.\n@param displacement the amount to subtract from this offset.\n@return The address using the subtracted offset.","static":false,"name":"subtract","comment":"Creates a new address (possibly in a new space) by subtracting the displacement to \n this address.","params":[{"type_long":"long","name":"displacement","comment":"the amount to subtract from this offset.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The address using the subtracted offset.","type_short":"Address"}},{"javadoc":"Creates a new address by adding the displacement to the current \n address. The new address will wrap in a manner that depends on the \n address space. For a generic address space this will wrap at the \n extents of the address space. For a segmented address space it will \n wrap at the extents of the segment.\n@param displacement the displacement to add.\n@return The new Address formed by adding the displacement to this address's offset.","static":false,"name":"addWrap","comment":"Creates a new address by adding the displacement to the current \n address. The new address will wrap in a manner that depends on the \n address space. For a generic address space this will wrap at the \n extents of the address space. For a segmented address space it will \n wrap at the extents of the segment.","params":[{"type_long":"long","name":"displacement","comment":"the displacement to add.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new Address formed by adding the displacement to this address's offset.","type_short":"Address"}},{"javadoc":"Creates a new address by adding the displacement to the current \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as addWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.\n@param displacement the displacement to add.\n@return The new Address formed by adding the displacement to this address's offset.","static":false,"name":"addWrapSpace","comment":"Creates a new address by adding the displacement to the current \n address. If the offset is greater than the max offset of the address space, the high\n order bits are masked off, making the address wrap.  For non-segmented addresses this\n will be the same as addWrap().  For segmented addresses, the address will wrap when\n the 20 bit (oxfffff) offset is exceeded, as opposed to when the segment offset is exceeded.","params":[{"type_long":"long","name":"displacement","comment":"the displacement to add.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new Address formed by adding the displacement to this address's offset.","type_short":"Address"}},{"javadoc":"Creates a new Address with a displacement relative to this\n  Address.  The Address will not wrap around!  An exception will be\n throw if the result is not within this address space.\n@param displacement the displacement to add.\n@return The new Address\n@throws AddressOverflowException if the offset in this Address would\n  overflow (wrap around) due to this operation.","static":false,"name":"addNoWrap","comment":"Creates a new Address with a displacement relative to this\n  Address.  The Address will not wrap around!  An exception will be\n throw if the result is not within this address space.","params":[{"type_long":"long","name":"displacement","comment":"the displacement to add.","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"if the offset in this Address would\n  overflow (wrap around) due to this operation.","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new Address","type_short":"Address"}},{"javadoc":"","static":false,"name":"addNoWrap","comment":"","params":[{"type_long":"java.math.BigInteger","name":"displacement","comment":"","type_short":"BigInteger"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Creates a new address (possibly in a new space) by adding the displacement to \n this address.\n@param displacement the amount to add to this offset.\n@return The new address.\n@throws AddressOutOfBoundsException if wrapping is not supported by the \n corresponding address space and the addition causes an out-of-bounds\n error","static":false,"name":"add","comment":"Creates a new address (possibly in a new space) by adding the displacement to \n this address.","params":[{"type_long":"long","name":"displacement","comment":"the amount to add to this offset.","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOutOfBoundsException","comment":"if wrapping is not supported by the \n corresponding address space and the addition causes an out-of-bounds\n error","type_short":"AddressOutOfBoundsException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"The new address.","type_short":"Address"}},{"javadoc":"Tests whether the given address immediately follows this address.\n@param addr the address to test.","static":false,"name":"isSuccessor","comment":"Tests whether the given address immediately follows this address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address to test.","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns a String representation of the address in hex and padded\n to the appropriate size.","static":false,"name":"toString","comment":"Returns a String representation of the address in hex and padded\n to the appropriate size.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns a String representation of the address using the\n given string as a prefix.  Equivalent of prefix + \":\" + toString(false)\n@param prefix the string to prepend to the address string.","static":false,"name":"toString","comment":"Returns a String representation of the address using the\n given string as a prefix.  Equivalent of prefix + \":\" + toString(false)","params":[{"type_long":"java.lang.String","name":"prefix","comment":"the string to prepend to the address string.","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Returns a String representation that may include the address space name\n@param showAddressSpace true if the address space should be included in \n resulting string.\n@return String the string representation of the address","static":false,"name":"toString","comment":"Returns a String representation that may include the address space name","params":[{"type_long":"boolean","name":"showAddressSpace","comment":"true if the address space should be included in \n resulting string.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"String the string representation of the address","type_short":"String"}},{"javadoc":"Returns a String representation that may include the address space name and may or may\n not pad the address with leading zeros.\n@param showAddressSpace if true, the addressSpace name will be prepended to the address string.\n@param pad if true, the address will be prepended with leading zeros to completely fill out\n the max digits the address could contain.  If false, the address will be prepended only to make\n the number of hex digits at least 4.\n@return the address as a String.","static":false,"name":"toString","comment":"Returns a String representation that may include the address space name and may or may\n not pad the address with leading zeros.","params":[{"type_long":"boolean","name":"showAddressSpace","comment":"if true, the addressSpace name will be prepended to the address string.","type_short":"boolean"},{"type_long":"boolean","name":"pad","comment":"if true, the address will be prepended with leading zeros to completely fill out\n the max digits the address could contain.  If false, the address will be prepended only to make\n the number of hex digits at least 4.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the address as a String.","type_short":"String"}},{"javadoc":"Returns a String representation that may include the address space name and may or may\n not pad the address with leading zeros.\n@param showAddressSpace if true, the addressSpace name will be prepended to the address string.\n@param minNumDigits specifies the minimum number of digits to use.  If the address space size\n is less that minNumDigits, the address will be padded to the address space size.  If the address\n space size is larger that minNumDigits, the address will be displayed with as many digits as\n necessary, but will contain leading zeros to make the address string have at least minNumDigits.\n@return the address as a String.","static":false,"name":"toString","comment":"Returns a String representation that may include the address space name and may or may\n not pad the address with leading zeros.","params":[{"type_long":"boolean","name":"showAddressSpace","comment":"if true, the addressSpace name will be prepended to the address string.","type_short":"boolean"},{"type_long":"int","name":"minNumDigits","comment":"specifies the minimum number of digits to use.  If the address space size\n is less that minNumDigits, the address will be padded to the address space size.  If the address\n space size is larger that minNumDigits, the address will be displayed with as many digits as\n necessary, but will contain leading zeros to make the address string have at least minNumDigits.","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the address as a String.","type_short":"String"}},{"javadoc":"Compares this Address to the specified object.\n The result is <code>true<\/code> if and only if the argument is not \n <code>null<\/code> and is a <code>Address<\/code> object that represents \n the same address as this object.\n@param o the object to compare this <code>String<\/code>\n              against.\n@return <code>true<\/code> if the <code>Addresses<\/code>are equal;\n          <code>false<\/code> otherwise.","static":false,"name":"equals","comment":"Compares this Address to the specified object.\n The result is true if and only if the argument is not \n null and is a Address object that represents \n the same address as this object.","params":[{"type_long":"java.lang.Object","name":"o","comment":"the object to compare this String\n              against.","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the Addressesare equal;\n          false otherwise.","type_short":"boolean"}},{"javadoc":"Returns a hashcode for this Address. The hashcode for an \n <code>Address<\/code> should be a value such that two Address\n objects which are equal will return the same hashcode.\n This method should generally return the same value as getLong().\n@return a hash code value for this object.","static":false,"name":"hashCode","comment":"Returns a hashcode for this Address. The hashcode for an \n Address should be a value such that two Address\n objects which are equal will return the same hashcode.\n This method should generally return the same value as getLong().","params":[],"throws":[],"return":{"type_long":"int","comment":"a hash code value for this object.","type_short":"int"}},{"javadoc":"Returns the physical Address that corresponds to this Address.\n@return address in a physical space corresponding to this\n address.","static":false,"name":"getPhysicalAddress","comment":"Returns the physical Address that corresponds to this Address.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"address in a physical space corresponding to this\n address.","type_short":"Address"}},{"javadoc":"Returns true if this address represents a location in memory","static":false,"name":"isMemoryAddress","comment":"Returns true if this address represents a location in memory","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents an address in a loaded memory block","static":false,"name":"isLoadedMemoryAddress","comment":"Returns true if this address represents an address in a loaded memory block","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents an address not loaded in real memory (i.e. OTHER)","static":false,"name":"isNonLoadedMemoryAddress","comment":"Returns true if this address represents an address not loaded in real memory (i.e. OTHER)","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents a location in stack space","static":false,"name":"isStackAddress","comment":"Returns true if this address represents a location in stack space","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents a location in unique space","static":false,"name":"isUniqueAddress","comment":"Returns true if this address represents a location in unique space","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents a location in constant space","static":false,"name":"isConstantAddress","comment":"Returns true if this address represents a location in constant space","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents a location in the HASH space","static":false,"name":"isHashAddress","comment":"Returns true if this address represents a location in the HASH space","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents a location in register space.\n@depricate use of this method is highly discouraged since since registers\n may also exist in a memory space. The address for such registers \n would return false from this method.","static":false,"name":"isRegisterAddress","comment":"Returns true if this address represents a location in register space.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents a location in variable space","static":false,"name":"isVariableAddress","comment":"Returns true if this address represents a location in variable space","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if this address represents an external location in the external address space","static":false,"name":"isExternalAddress","comment":"Returns true if this address represents an external location in the external address space","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"Address","comment":"An address represents a location in a program.  Conceptually, addresses consist\n of an \"address space\" and an offset within that space.  Many processors have only\n one \"real\" address space, but some have several spaces. Also, there are\n \"artificial\" address spaces used for analysis and representing other non-memory locations\n such as a register or an offset on the stack relative to a functions frame pointer.","fields":[{"type_long":"ghidra.program.model.address.Address","javadoc":"Address object representing an invalid address.","static":true,"name":"NO_ADDRESS","comment":"Address object representing an invalid address.","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"Address object representing an extenal entry address.","static":true,"name":"EXT_FROM_ADDRESS","comment":"Address object representing an extenal entry address.","type_short":"Address","constant_value":null},{"type_long":"char","javadoc":"Character used to separate space names from offsets.","static":true,"name":"SEPARATOR_CHAR","comment":"Character used to separate space names from offsets.","type_short":"char","constant_value":":"}]}
