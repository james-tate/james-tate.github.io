{"implements":[],"javadoc":"Rawest possible Varnode.\n Just a variable location and size, not part of a syntax tree.\n A raw varnode is said to be free, it is not attached to any variable.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"@param a location varnode attached to\n@param sz size of varnode","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"a","comment":"location varnode attached to","type_short":"Address"},{"type_long":"int","name":"sz","comment":"size of varnode","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@param a location varnode attached to\n@param sz size of varnode\n@param symbolKey associated symbol key","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"a","comment":"location varnode attached to","type_short":"Address"},{"type_long":"int","name":"sz","comment":"size of varnode","type_short":"int"},{"type_long":"int","name":"symbolKey","comment":"associated symbol key","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@return size of the varnode in bytes","static":false,"name":"getSize","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"size of the varnode in bytes","type_short":"int"}},{"javadoc":"@return the space this varnode belongs to (ram, register, ...)","static":false,"name":"getSpace","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"the space this varnode belongs to (ram, register, ...)","type_short":"int"}},{"javadoc":"@return the address this varnode is attached to","static":false,"name":"getAddress","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the address this varnode is attached to","type_short":"Address"}},{"javadoc":"Get the address where this varnode is defined or\n NO_ADDRESS if this varnode is an input\n@return the address","static":false,"name":"getPCAddress","comment":"Get the address where this varnode is defined or\n NO_ADDRESS if this varnode is an input","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the address","type_short":"Address"}},{"javadoc":"@return the offset into the address space varnode is defined within","static":false,"name":"getOffset","comment":"","params":[],"throws":[],"return":{"type_long":"long","comment":"the offset into the address space varnode is defined within","type_short":"long"}},{"javadoc":"Returns the word offset into the address space this is defined within\n \n The word size is defined in the Language's .slaspec file with the\n \"WORDSIZE\" argument when DEFINEing a memory SPACE (capitalization is\n for emphasis; the directives are actually lowercase).\n@return the word offset into the address space this is defined within","static":false,"name":"getWordOffset","comment":"Returns the word offset into the address space this is defined within\n \n The word size is defined in the Language's .slaspec file with the\n \"WORDSIZE\" argument when DEFINEing a memory SPACE (capitalization is\n for emphasis; the directives are actually lowercase).","params":[],"throws":[],"return":{"type_long":"long","comment":"the word offset into the address space this is defined within","type_short":"long"}},{"javadoc":"","static":false,"name":"isFree","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Determine if this varnode contains the specified address\n@param address the address for which to check\n@return true if this varnode contains the specified address","static":false,"name":"contains","comment":"Determine if this varnode contains the specified address","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address for which to check","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode contains the specified address","type_short":"boolean"}},{"javadoc":"Determine if this varnode intersects another varnode.\n@param varnode other varnode\n@return true if this varnode intersects the specified varnode","static":false,"name":"intersects","comment":"Determine if this varnode intersects another varnode.","params":[{"type_long":"ghidra.program.model.pcode.Varnode","name":"varnode","comment":"other varnode","type_short":"Varnode"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode intersects the specified varnode","type_short":"boolean"}},{"javadoc":"","static":false,"name":"rangeIntersects","comment":"","params":[{"type_long":"long","name":"otherOffset","comment":"","type_short":"long"},{"type_long":"long","name":"otherEndOffset","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Determine if this varnode intersects the specified address set\n@param set address set\n@return true if this varnode intersects the specified address set","static":false,"name":"intersects","comment":"Determine if this varnode intersects the specified address set","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"set","comment":"address set","type_short":"AddressSetView"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode intersects the specified address set","type_short":"boolean"}},{"javadoc":"@return true if this varnode exists in a Memory space (vs. register etc...).\n Keep in mind this varnode may also correspond to a defined register \n if true is returned and {@link #isRegister()} return false.  \n Memory-based registers may be indirectly addressed which leads to the \n distinction with registers within the register space.","static":false,"name":"isAddress","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode exists in a Memory space (vs. register etc...).\n Keep in mind this varnode may also correspond to a defined register \n if true is returned and #isRegister() return false.  \n Memory-based registers may be indirectly addressed which leads to the \n distinction with registers within the register space.","type_short":"boolean"}},{"javadoc":"@return true if this varnode exists in a Register type space.\n If false is returned, keep in mind this varnode may still correspond to a \n defined register within a memory space.  Memory-based registers may be indirectly \n addressed which leads to the distinction with registers within the register space.","static":false,"name":"isRegister","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode exists in a Register type space.\n If false is returned, keep in mind this varnode may still correspond to a \n defined register within a memory space.  Memory-based registers may be indirectly \n addressed which leads to the distinction with registers within the register space.","type_short":"boolean"}},{"javadoc":"@return true if this varnode is just a constant number","static":false,"name":"isConstant","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode is just a constant number","type_short":"boolean"}},{"javadoc":"@return true if this varnode doesn't exist anywhere.  A temporary variable.","static":false,"name":"isUnique","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this varnode doesn't exist anywhere.  A temporary variable.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isHash","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"@return is input to a pcode op","static":false,"name":"isInput","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"is input to a pcode op","type_short":"boolean"}},{"javadoc":"@return is persistant","static":false,"name":"isPersistant","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"is persistant","type_short":"boolean"}},{"javadoc":"@return is mapped to an address","static":false,"name":"isAddrTied","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"is mapped to an address","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isUnaffected","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"@return get the pcode op this varnode belongs to","static":false,"name":"getDef","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.PcodeOp","comment":"get the pcode op this varnode belongs to","type_short":"PcodeOp"}},{"javadoc":"@return iterator to all PcodeOp s that take this as input","static":false,"name":"getDescendants","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<ghidra.program.model.pcode.PcodeOp>","comment":"iterator to all PcodeOp s that take this as input","type_short":"Iterator"}},{"javadoc":"If there is only one PcodeOp taking this varnode as input, return it. Otherwise return null\n@return the lone descendant PcodeOp","static":false,"name":"getLoneDescend","comment":"If there is only one PcodeOp taking this varnode as input, return it. Otherwise return null","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.PcodeOp","comment":"the lone descendant PcodeOp","type_short":"PcodeOp"}},{"javadoc":"@return the high level variable this varnode represents","static":false,"name":"getHigh","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.pcode.HighVariable","comment":"the high level variable this varnode represents","type_short":"HighVariable"}},{"javadoc":"@return the index of the group, within the high containing this, that are forced merged with this","static":false,"name":"getMergeGroup","comment":"","params":[],"throws":[],"return":{"type_long":"short","comment":"the index of the group, within the high containing this, that are forced merged with this","type_short":"short"}},{"javadoc":"@param buf is the builder to which to append XML","static":false,"name":"buildXML","comment":"","params":[{"type_long":"java.lang.StringBuilder","name":"buf","comment":"is the builder to which to append XML","type_short":"StringBuilder"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build an XML document representation of a varnode with the given address and size.\n@param resBuf is the builder to which to append the XML\n@param addr location varnode is defined at\n@param size size of the varnode.","static":true,"name":"buildXMLAddress","comment":"Build an XML document representation of a varnode with the given address and size.","params":[{"type_long":"java.lang.StringBuilder","name":"resBuf","comment":"is the builder to which to append the XML","type_short":"StringBuilder"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"location varnode is defined at","type_short":"Address"},{"type_long":"int","name":"size","comment":"size of the varnode.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Convert an address into an XML document.\n@param addr -- Address to convert to XML\n@return XML string","static":true,"name":"buildXMLAddress","comment":"Convert an address into an XML document.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"-- Address to convert to XML","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"XML string","type_short":"String"}},{"javadoc":"Convert a varnode array into an XML document.\n@param varnodes sequence of storage varnodes\n@param logicalsize the logical size value of the varnode\n@return XML string","static":true,"name":"buildXMLAddress","comment":"Convert a varnode array into an XML document.","params":[{"type_long":"ghidra.program.model.pcode.Varnode[]","name":"varnodes","comment":"sequence of storage varnodes","type_short":"ghidra.program.model.pcode.Varnode[]"},{"type_long":"int","name":"logicalsize","comment":"the logical size value of the varnode","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"XML string","type_short":"String"}},{"javadoc":"","static":true,"name":"buildVarnodePiece","comment":"","params":[{"type_long":"java.lang.StringBuilder","name":"buf","comment":"","type_short":"StringBuilder"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"size","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"appendSpaceOffset","comment":"","params":[{"type_long":"java.lang.StringBuilder","name":"buf","comment":"","type_short":"StringBuilder"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build a varnode from a SAX parse tree node\n@param parser the parser\n@param factory pcode factory used to create valid pcode\n@return new varnode element based on info in the XML.\n@throws PcodeXMLException","static":true,"name":"readXML","comment":"Build a varnode from a SAX parse tree node","params":[{"type_long":"ghidra.xml.XmlPullParser","name":"parser","comment":"the parser","type_short":"XmlPullParser"},{"type_long":"ghidra.program.model.pcode.PcodeFactory","name":"factory","comment":"pcode factory used to create valid pcode","type_short":"PcodeFactory"}],"throws":[{"type_long":"ghidra.program.model.pcode.PcodeXMLException","comment":"","type_short":"PcodeXMLException"}],"return":{"type_long":"ghidra.program.model.pcode.Varnode","comment":"new varnode element based on info in the XML.","type_short":"Varnode"}},{"javadoc":"Trim a varnode in a constant space to the correct starting offset.\n \n Constant handles may contain constants of indeterminate size.\n This is where the size gets fixed, i.e. we mask off the constant\n to its proper size.  A varnode that is ends up in pcode should\n call this method to ensure that varnodes always contains raw data.\n On the other hand, varnodes in handles are allowed to have offsets\n that violate size restrictions.","static":false,"name":"trim","comment":"Trim a varnode in a constant space to the correct starting offset.\n \n Constant handles may contain constants of indeterminate size.\n This is where the size gets fixed, i.e. we mask off the constant\n to its proper size.  A varnode that is ends up in pcode should\n call this method to ensure that varnodes always contains raw data.\n On the other hand, varnodes in handles are allowed to have offsets\n that violate size restrictions.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Convert this varnode to an alternate String representation based on a specified language.\n@param language\n@return string representation","static":false,"name":"toString","comment":"Convert this varnode to an alternate String representation based on a specified language.","params":[{"type_long":"ghidra.program.model.lang.Language","name":"language","comment":"","type_short":"Language"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"string representation","type_short":"String"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"o","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Create an address from a SAX parse tree node.\n@param el SAX parse tree element\n@param addrFactory address factory used to create valid addresses\n@return Address created from XML info","static":true,"name":"readXMLAddress","comment":"Create an address from a SAX parse tree node.","params":[{"type_long":"ghidra.xml.XmlElement","name":"el","comment":"SAX parse tree element","type_short":"XmlElement"},{"type_long":"ghidra.program.model.address.AddressFactory","name":"addrFactory","comment":"address factory used to create valid addresses","type_short":"AddressFactory"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"Address created from XML info","type_short":"Address"}},{"javadoc":"","static":true,"name":"readXMLAddress","comment":"","params":[{"type_long":"java.lang.String","name":"localName","comment":"","type_short":"String"},{"type_long":"org.xml.sax.Attributes","name":"attr","comment":"","type_short":"Attributes"},{"type_long":"ghidra.program.model.address.AddressFactory","name":"addrFactory","comment":"","type_short":"AddressFactory"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Parse an XML containing an address.  The format options are simple enough that we don't try to invoke\n an actual XML parser but just walk the string\n@param addrstring is the string containing the XML tag\n@param addrfactory is the factory that can produce addresses\n@param refSpace can be null but is otherwise the reference AddressSpace from which the request is sent.\n@return the created Address or Address.NO_ADDRESS in some special cases\n@throws PcodeXMLException","static":true,"name":"readXMLAddress","comment":"Parse an XML containing an address.  The format options are simple enough that we don't try to invoke\n an actual XML parser but just walk the string","params":[{"type_long":"java.lang.String","name":"addrstring","comment":"is the string containing the XML tag","type_short":"String"},{"type_long":"ghidra.program.model.address.AddressFactory","name":"addrfactory","comment":"is the factory that can produce addresses","type_short":"AddressFactory"},{"type_long":"ghidra.program.model.address.AddressSpace","name":"refSpace","comment":"can be null but is otherwise the reference AddressSpace from which the request is sent.","type_short":"AddressSpace"}],"throws":[{"type_long":"ghidra.program.model.pcode.PcodeXMLException","comment":"","type_short":"PcodeXMLException"}],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the created Address or Address.NO_ADDRESS in some special cases","type_short":"Address"}}],"name":"Varnode","comment":"Rawest possible Varnode.\n Just a variable location and size, not part of a syntax tree.\n A raw varnode is said to be free, it is not attached to any variable.","fields":[{"type_long":"long[]","javadoc":"","static":true,"name":"masks","comment":"","type_short":"long[]","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"address","comment":"","type_short":"Address","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"size","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"spaceID","comment":"","type_short":"int","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"offset","comment":"","type_short":"long","constant_value":null}]}
