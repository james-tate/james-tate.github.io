{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"getContainedDataTypes","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"rootDataType","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.program.model.data.DataType>","comment":"","type_short":"Collection"}},{"javadoc":"","static":true,"name":"getDirectContainedDatatypes","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.data.DataType>","comment":"","type_short":"List"}},{"javadoc":"Check to see if the second data type is the same as the first data type or is part of it.\n <br>Note: pointers to the second data type are references and therefore are not considered\n to be part of the first and won't cause true to be returned. If you pass a pointer to this\n method for the first or second parameter, it will return false.\n@param firstDataType the data type whose components or base type should be checked to see\n if the second data type is part of it.\n@param secondDataType the data type to be checked for in the first data type.\n@return true if the second data type is the first data type or is part of it.","static":true,"name":"isSecondPartOfFirst","comment":"Check to see if the second data type is the same as the first data type or is part of it.\n Note: pointers to the second data type are references and therefore are not considered\n to be part of the first and won't cause true to be returned. If you pass a pointer to this\n method for the first or second parameter, it will return false.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"firstDataType","comment":"the data type whose components or base type should be checked to see\n if the second data type is part of it.","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"secondDataType","comment":"the data type to be checked for in the first data type.","type_short":"DataType"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the second data type is the first data type or is part of it.","type_short":"boolean"}},{"javadoc":"Returns true if the two dataTypes have the same sourceArchive and the same UniversalID.","static":true,"name":"isSameDataType","comment":"Returns true if the two dataTypes have the same sourceArchive and the same UniversalID.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType1","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType2","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if the two dataTypes have the same sourceArchive and the same UniversalID OR\n are equivalent","static":true,"name":"isSameOrEquivalentDataType","comment":"Returns true if the two dataTypes have the same sourceArchive and the same UniversalID OR\n are equivalent","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType1","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"dataType2","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Get the name of a data type with all conflict naming patterns removed.\n@param dataType data type\n@param includeCategoryPath if true the category path will be included with its\n@return name with without conflict patterns","static":true,"name":"getNameWithoutConflict","comment":"Get the name of a data type with all conflict naming patterns removed.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"data type","type_short":"DataType"},{"type_long":"boolean","name":"includeCategoryPath","comment":"if true the category path will be included with its","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"name with without conflict patterns","type_short":"String"}},{"javadoc":"Compares two data type name strings to determine if they are equivalent names, ignoring\n conflict patterns present.\n@param name1 the first name\n@param name2 the second name\n@return true if the names are equivalent when conflict suffixes are ignored.","static":true,"name":"equalsIgnoreConflict","comment":"Compares two data type name strings to determine if they are equivalent names, ignoring\n conflict patterns present.","params":[{"type_long":"java.lang.String","name":"name1","comment":"the first name","type_short":"String"},{"type_long":"java.lang.String","name":"name2","comment":"the second name","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the names are equivalent when conflict suffixes are ignored.","type_short":"boolean"}},{"javadoc":"Get the base data type for the specified data type stripping\n away pointers and arrays only.  A null will be returned for a\n default pointer.\n@param baseDataType the data type whose base data type is to be determined.\n@return the base data type.","static":true,"name":"getBaseDataType","comment":"Get the base data type for the specified data type stripping\n away pointers and arrays only.  A null will be returned for a\n default pointer.","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"the base data type.","type_short":"DataType"}},{"javadoc":"","static":true,"name":"getArrayBaseDataType","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"","static":true,"name":"getArrayBaseElementLength","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":true,"name":"getArrayElementLengthForDynamic","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getArrayDimensions","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getName","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"},{"type_long":"boolean","name":"showBaseSizeForDynamics","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getDisplayName","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"},{"type_long":"boolean","name":"showBaseSizeForDynamics","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"getMnemonic","comment":"","params":[{"type_long":"ghidra.program.model.data.Array","name":"arrayDt","comment":"","type_short":"Array"},{"type_long":"boolean","name":"showBaseSizeForDynamics","comment":"","type_short":"boolean"},{"type_long":"ghidra.docking.settings.Settings","name":"settings","comment":"","type_short":"Settings"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Create a data type category path derived from the specified namespace and rooted from\n the specified baseCategory\n@param baseCategory category path from which to root the namespace-base path\n@param namespace the namespace\n@return namespace derived category path","static":true,"name":"getDataTypeCategoryPath","comment":"Create a data type category path derived from the specified namespace and rooted from\n the specified baseCategory","params":[{"type_long":"ghidra.program.model.data.CategoryPath","name":"baseCategory","comment":"category path from which to root the namespace-base path","type_short":"CategoryPath"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace","type_short":"Namespace"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.CategoryPath","comment":"namespace derived category path","type_short":"CategoryPath"}},{"javadoc":"Attempt to find the data type whose dtName and specified namespace match a\n stored data type within the specified dataTypeManager.  The best match\n will be returned.  The namespace will be used in checking data type parent categories,\n however if no type corresponds to the namespace another type whose name\n matches may be returned.\n@param dataTypeManager data type manager\n@param namespace namespace associated with dtName (null indicates no namespace constraint)\n@param dtName name of data type\n@param classConstraint optional data type interface constraint (e.g., Structure), or null\n@return best matching data type","static":true,"name":"findDataType","comment":"Attempt to find the data type whose dtName and specified namespace match a\n stored data type within the specified dataTypeManager.  The best match\n will be returned.  The namespace will be used in checking data type parent categories,\n however if no type corresponds to the namespace another type whose name\n matches may be returned.","params":[{"type_long":"ghidra.program.model.data.DataTypeManager","name":"dataTypeManager","comment":"data type manager","type_short":"DataTypeManager"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"namespace associated with dtName (null indicates no namespace constraint)","type_short":"Namespace"},{"type_long":"java.lang.String","name":"dtName","comment":"name of data type","type_short":"String"},{"type_long":"java.lang.Class<? extends ghidra.program.model.data.DataType>","name":"classConstraint","comment":"optional data type interface constraint (e.g., Structure), or null","type_short":"Class"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"best matching data type","type_short":"DataType"}},{"javadoc":"Attempt to find the data type whose dtNameWithNamespace match a\n stored data type within the specified dataTypeManager.  The best match\n will be returned.  The namespace will be used in checking data type parent categories,\n however if no type corresponds to the namespace another type whose name\n matches may be returned.\n NOTE: name parsing assumes :: delimiter and can be thrown off if name include template\n information which could contain namespaces.\n@param dataTypeManager data type manager\n@param namespace namespace associated with dtName (null indicates no namespace constraint)\n@param dtNameWithNamespace name of data type qualified with namespace (e.g., ns1::ns2::dtname)\n@param classConstraint optional data type interface constraint (e.g., Structure), or null\n@return best matching data type","static":true,"name":"findNamespaceQualifiedDataType","comment":"Attempt to find the data type whose dtNameWithNamespace match a\n stored data type within the specified dataTypeManager.  The best match\n will be returned.  The namespace will be used in checking data type parent categories,\n however if no type corresponds to the namespace another type whose name\n matches may be returned.\n NOTE: name parsing assumes :: delimiter and can be thrown off if name include template\n information which could contain namespaces.","params":[{"type_long":"ghidra.program.model.data.DataTypeManager","name":"dataTypeManager","comment":"data type manager","type_short":"DataTypeManager"},{"type_long":"java.lang.String","name":"dtNameWithNamespace","comment":"name of data type qualified with namespace (e.g., ns1::ns2::dtname)","type_short":"String"},{"type_long":"java.lang.Class<? extends ghidra.program.model.data.DataType>","name":"classConstraint","comment":"optional data type interface constraint (e.g., Structure), or null","type_short":"Class"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"best matching data type","type_short":"DataType"}},{"javadoc":"Return the appropriate datatype for a given C primitive datatype name.\n@param dataTypeName the datatype name (e.g. \"unsigned int\", \"long long\")\n@return the appropriate datatype for a given C primitive datatype name.","static":true,"name":"getCPrimitiveDataType","comment":"Return the appropriate datatype for a given C primitive datatype name.","params":[{"type_long":"java.lang.String","name":"dataTypeName","comment":"the datatype name (e.g. \"unsigned int\", \"long long\")","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"the appropriate datatype for a given C primitive datatype name.","type_short":"DataType"}},{"javadoc":"","static":true,"name":"hasPreferredNamespaceCategory","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"},{"type_long":"java.lang.String[]","name":"splitDataTypeName","comment":"","type_short":"java.lang.String[]"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"hasPreferredNamespaceCategory","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dataType","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"","type_short":"Namespace"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"findDataType","comment":"","params":[{"type_long":"ghidra.program.model.data.DataTypeManager","name":"dataTypeManager","comment":"","type_short":"DataTypeManager"},{"type_long":"java.lang.String","name":"dtName","comment":"","type_short":"String"},{"type_long":"java.lang.Class<? extends ghidra.program.model.data.DataType>","name":"classConstraint","comment":"","type_short":"Class"},{"type_long":"ghidra.program.database.data.DataTypeUtilities.NamespaceMatcher","name":"preferredCategoryMatcher","comment":"","type_short":"NamespaceMatcher"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}}],"name":"DataTypeUtilities","comment":"","fields":[{"type_long":"java.util.Map<java.lang.String,ghidra.program.model.data.DataType>","javadoc":"","static":true,"name":"cPrimitiveNameMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.regex.Pattern","javadoc":"","static":true,"name":"DATATYPE_CONFLICT_PATTERN","comment":"","type_short":"Pattern","constant_value":null}]}
