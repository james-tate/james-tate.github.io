{"implements":[],"javadoc":"<code>SymbolMerge<\/code> provides functionality for replacing or merging\n symbols from one program to another.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Creates a <code>SymbolMerge<\/code> for replacing or merging symbols from one program\n to another program.\n@param fromProgram the program to get symbols \"from\".\n@param toProgram the program to merge symbols \"to\".","static":false,"name":"<init>","comment":"Creates a SymbolMerge for replacing or merging symbols from one program\n to another program.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"fromProgram","comment":"the program to get symbols \"from\".","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"toProgram","comment":"the program to merge symbols \"to\".","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.util.AddressTranslator","name":"originToResultTranslator","comment":"","type_short":"AddressTranslator"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This method creates a namespace in one program (the \"to\" program) that is effectively the\n same as the namespace from another program (the \"from\" program.) It will resolve each\n parent namespace in this namespace's parent hierarchy until reaching the global namespace\n for the program or until there is no parent namespace.\n When resolving any namespace the type of namespace will be the same as it was in the \"from\"\n program. However, the name of the namespace will match the original name in the \"from\"\n program or will be the original name with a conflict suffix attached.\n <br>If a namespace that is effectively the same can't be found then this method will create\n one and the name may match the original or have a conflict name.\n <br>If the namespace can't be resolved, an exception is thrown.\n <br>Any namespaces that are created with a conflict name will have their symbol IDs mapped\n into the <code>conflictSymbolIDMap<\/code>.\n@param fromNamespace the namespace in the \"from\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@return the resolved namespace in the \"to\" program. Also the <code>conflictSymbolIDMap<\/code>\n will have been modified, if this namespace had to be created with a conflict name.\n@throws DuplicateNameException if the name space can't be resolved due\n to a name conflict that can't be dealt with.\n@throws InvalidInputException if the name space is not validly named\n for the \"to\" program.","static":false,"name":"resolveNamespace","comment":"This method creates a namespace in one program (the \"to\" program) that is effectively the\n same as the namespace from another program (the \"from\" program.) It will resolve each\n parent namespace in this namespace's parent hierarchy until reaching the global namespace\n for the program or until there is no parent namespace.\n When resolving any namespace the type of namespace will be the same as it was in the \"from\"\n program. However, the name of the namespace will match the original name in the \"from\"\n program or will be the original name with a conflict suffix attached.\n If a namespace that is effectively the same can't be found then this method will create\n one and the name may match the original or have a conflict name.\n If the namespace can't be resolved, an exception is thrown.\n Any namespaces that are created with a conflict name will have their symbol IDs mapped\n into the conflictSymbolIDMap.","params":[{"type_long":"ghidra.program.model.symbol.Namespace","name":"fromNamespace","comment":"the namespace in the \"from\" program.","type_short":"Namespace"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the name space can't be resolved due\n to a name conflict that can't be dealt with.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the name space is not validly named\n for the \"to\" program.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"the resolved namespace in the \"to\" program. Also the conflictSymbolIDMap\n will have been modified, if this namespace had to be created with a conflict name.","type_short":"Namespace"}},{"javadoc":"Get\/create a uniquely named namespace. If the namespace's name can't\n be created because of a name conflict, it will be given a new conflict name.\n@param name the desired name for the namespace\n@param symbolType the symbol type for this namespace\n@param address the address for this namespace\n This address should be derived from the \"to\" program.\n@param toParentNamespace the parent of this namespace that is in the \"to\" program.\n@param source the source of this symbol\n@return an equivalent namespace that exists or was created in the \"to\" program.\n@throws DuplicateNameException if the namespace couldn't be created\n because of an unresolvable name conflict.\n@throws InvalidInputException if the namespace couldn't be created\n because the specified name is invalid in the \"to\" program.","static":false,"name":"createNamespace","comment":"Get\/create a uniquely named namespace. If the namespace's name can't\n be created because of a name conflict, it will be given a new conflict name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the desired name for the namespace","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"symbolType","comment":"the symbol type for this namespace","type_short":"SymbolType"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address for this namespace\n This address should be derived from the \"to\" program.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"toParentNamespace","comment":"the parent of this namespace that is in the \"to\" program.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this symbol","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the namespace couldn't be created\n because of an unresolvable name conflict.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the namespace couldn't be created\n because the specified name is invalid in the \"to\" program.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"an equivalent namespace that exists or was created in the \"to\" program.","type_short":"Namespace"}},{"javadoc":"Creates a new symbol of the indicated type along with its associated Object in the \"to\" program.\n <br>This method will throw an exception if the symbol can't be created.\n <br>Note: It will not create a symbol with a conflict name.\n@param name the name for the symbol\n@param type the symbol type for this symbol\n@param address the address for this symbol\n This address should be derived from the \"to\" program.\n@param parentNamespace the parent namespace of this symbol that is in the \"to\" program\n@param source the source of this symbol.\n@return a new symbol. Returns null if it can't create a symbol of the indicated type..\n@throws DuplicateNameException if the symbol and Object couldn't be created\n because of an unresolvable name conflict.\n@throws InvalidInputException if the symbol and Object couldn't be created\n because of an invalid name.","static":false,"name":"createSymbol","comment":"Creates a new symbol of the indicated type along with its associated Object in the \"to\" program.\n This method will throw an exception if the symbol can't be created.\n Note: It will not create a symbol with a conflict name.","params":[{"type_long":"java.lang.String","name":"name","comment":"the name for the symbol","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the symbol type for this symbol","type_short":"SymbolType"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address for this symbol\n This address should be derived from the \"to\" program.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"parentNamespace","comment":"the parent namespace of this symbol that is in the \"to\" program","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this symbol.","type_short":"SourceType"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the symbol and Object couldn't be created\n because of an unresolvable name conflict.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the symbol and Object couldn't be created\n because of an invalid name.","type_short":"InvalidInputException"}],"return":{"type_long":"ghidra.program.model.symbol.Symbol","comment":"a new symbol. Returns null if it can't create a symbol of the indicated type..","type_short":"Symbol"}},{"javadoc":"<code>replaceSymbols<\/code> will replace the symbols at the indicated address\n in the destination program with those from the source program. If the same symbol exists\n in the source and destination programs, this method will simply allow it to remain in the\n destination program. For a symbol to be the same, it must have the same name and the same\n parent namespace path. The primary symbol will be get set to the symbol that was primary in\n the source program.\n@param address the program address where the symbols are being replaced.\n This address should be derived from the \"to\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@param monitor the task monitor for updating user progress and allowing cancelling.\n@return a map of symbols that were created as conflicts during the replace. These map symbols\n in the source program to a symbol with another name due to a duplicate symbol problem.\n (key = \"from\" program's symbol; value = \"to\" program's symbol)\n@throws CancelledException if the task monitor is cancelled.\n@throws DuplicateNameException if the name space can't be resolved due\n to a name conflict that can't be dealt with.\n@throws InvalidInputException the indicated address.","static":false,"name":"replaceSymbols","comment":"replaceSymbols will replace the symbols at the indicated address\n in the destination program with those from the source program. If the same symbol exists\n in the source and destination programs, this method will simply allow it to remain in the\n destination program. For a symbol to be the same, it must have the same name and the same\n parent namespace path. The primary symbol will be get set to the symbol that was primary in\n the source program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the program address where the symbols are being replaced.\n This address should be derived from the \"to\" program.","type_short":"Address"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for updating user progress and allowing cancelling.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the task monitor is cancelled.","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if the name space can't be resolved due\n to a name conflict that can't be dealt with.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"the indicated address.","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"a map of symbols that were created as conflicts during the replace. These map symbols\n in the source program to a symbol with another name due to a duplicate symbol problem.\n (key = \"from\" program's symbol; value = \"to\" program's symbol)","type_short":"void"}},{"javadoc":"<code>removeUniqueToSymbols<\/code> removes all the symbols in the\n destination program at the specified address that don't have the same\n symbol in the source program at that address. The FUNCTION symbol will\n not be removed at the address even if it is different. Otherwise, the\n function would inadvertently get removed.\n@param address the program address where the symbols are being replaced.\n This address should be derived from the \"to\" program.\n@param monitor the task monitor for updating user progress and allowing cancelling.\n@throws CancelledException if the task monitor is cancelled.","static":false,"name":"removeUniqueToSymbols","comment":"removeUniqueToSymbols removes all the symbols in the\n destination program at the specified address that don't have the same\n symbol in the source program at that address. The FUNCTION symbol will\n not be removed at the address even if it is different. Otherwise, the\n function would inadvertently get removed.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddress","comment":"","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for updating user progress and allowing cancelling.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the task monitor is cancelled.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds symbols to the \"to\" program that are not in the \"to\" program, but are in the\n \"from\" program.\n@param fromAddress the program address where the symbols are being added from.\n This address should be derived from the \"from\" program.\n@param replace true indicates this method is being called as part of a replace.\n false indicates this method is being done as part of a merge.\n <br>Note: merge and replace require different behaviors here.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@param monitor the task monitor for updating user progress and allowing cancelling.\n@return an array of <code>SymbolTranslators<\/code> for symbols that ended up with different\n pathnames in the destination program than they had in the source program. These map symbols\n in the source program to a symbol with another name due to a duplicate symbol problem.\n@throws CancelledException if the task monitor is canceled.\n@throws DuplicateNameException if a symbol couldn't be added due\n to a name conflict that can't be dealt with.\n@throws InvalidInputException if the symbol name being used to create a symbol in the\n destination program is not valid.","static":false,"name":"addFromSymbols","comment":"Adds symbols to the \"to\" program that are not in the \"to\" program, but are in the\n \"from\" program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddress","comment":"the program address where the symbols are being added from.\n This address should be derived from the \"from\" program.","type_short":"Address"},{"type_long":"boolean","name":"replace","comment":"true indicates this method is being called as part of a replace.\n false indicates this method is being done as part of a merge.\n Note: merge and replace require different behaviors here.","type_short":"boolean"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for updating user progress and allowing cancelling.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the task monitor is canceled.","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the symbol name being used to create a symbol in the\n destination program is not valid.","type_short":"InvalidInputException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if a symbol couldn't be added due\n to a name conflict that can't be dealt with.","type_short":"DuplicateNameException"}],"return":{"type_long":"void","comment":"an array of SymbolTranslators for symbols that ended up with different\n pathnames in the destination program than they had in the source program. These map symbols\n in the source program to a symbol with another name due to a duplicate symbol problem.","type_short":"void"}},{"javadoc":"","static":false,"name":"determineToNamespace","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"toAddress","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"fromNamespace","comment":"","type_short":"Namespace"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"","type_short":"LongLongHashtable"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Namespace","comment":"","type_short":"Namespace"}},{"javadoc":"Replaces the function symbol at the indicated entry point in the \"to\" program with the\n function symbol in the \"from\" program. If there is no function in the \"to\" program the\n symbol becomes a regular \"label\" symbol.\n@param fromEntryPoint the entry point address\n This address should be derived from the \"from\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws InvalidInputException if the function symbol name from the second program isn't valid\n@throws DuplicateNameException if a duplicate name is encountered that couldn't be handled\n while replacing the function symbol.","static":false,"name":"replaceFunctionSymbol","comment":"Replaces the function symbol at the indicated entry point in the \"to\" program with the\n function symbol in the \"from\" program. If there is no function in the \"to\" program the\n symbol becomes a regular \"label\" symbol.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromEntryPoint","comment":"the entry point address\n This address should be derived from the \"from\" program.","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"toEntryPoint","comment":"","type_short":"Address"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if a duplicate name is encountered that couldn't be handled\n while replacing the function symbol.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the function symbol name from the second program isn't valid","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges the function symbol at the indicated entry point from the \"from\" program into the\n \"to\" program. The function is merged  as a regular \"label\" symbol.\n@param fromEntryPoint the entry point address\n This address should be derived from the \"from\" program.\n@param replacePrimary true indicates that the primary symbol in the \"to\" program should be\n set to the function symbol if there was one in the \"from\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws InvalidInputException if the function symbol name from the second program isn't valid\n@throws DuplicateNameException if a duplicate name is encountered that couldn't be handled\n while copying the function symbol.","static":false,"name":"mergeFunctionSymbol","comment":"Merges the function symbol at the indicated entry point from the \"from\" program into the\n \"to\" program. The function is merged  as a regular \"label\" symbol.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromEntryPoint","comment":"the entry point address\n This address should be derived from the \"from\" program.","type_short":"Address"},{"type_long":"boolean","name":"replacePrimary","comment":"true indicates that the primary symbol in the \"to\" program should be\n set to the function symbol if there was one in the \"from\" program.","type_short":"boolean"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if a duplicate name is encountered that couldn't be handled\n while copying the function symbol.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if the function symbol name from the second program isn't valid","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"addFunctionAsLabel","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"entryPoint","comment":"","type_short":"Address"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"","type_short":"LongLongHashtable"},{"type_long":"ghidra.program.model.symbol.SymbolTable","name":"toSymTab","comment":"","type_short":"SymbolTable"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"","type_short":"SourceType"},{"type_long":"java.lang.String","name":"fromName","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"toNamespace","comment":"","type_short":"Namespace"},{"type_long":"long","name":"oldID","comment":"","type_short":"long"}],"throws":[{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeLabels<\/CODE> either replaces the symbols in the \"to\" program with those in the\n \"from\" program or merges the symbols from the \"from\" program into the \"to\" program at\n the indicated addresses.\n@param fromAddressSet the addresses where symbols should be replaced or merged.\n The addresses in this set should be derived from the \"from\" program.\n@param setting indicates whether to replace or merge the symbols.\n@param replacePrimary true indicates that the primary symbol in the \"to\" program should be\n set to the same symbol as was primary in the \"from\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeLabels","comment":"mergeLabels either replaces the symbols in the \"to\" program with those in the\n \"from\" program or merges the symbols from the \"from\" program into the \"to\" program at\n the indicated addresses.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"fromAddressSet","comment":"the addresses where symbols should be replaced or merged.\n The addresses in this set should be derived from the \"from\" program.","type_short":"AddressSetView"},{"type_long":"int","name":"setting","comment":"indicates whether to replace or merge the symbols.","type_short":"int"},{"type_long":"boolean","name":"replacePrimary","comment":"true indicates that the primary symbol in the \"to\" program should be\n set to the same symbol as was primary in the \"from\" program.","type_short":"boolean"},{"type_long":"boolean","name":"replaceFunction","comment":"","type_short":"boolean"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"replaceSymbol adds the symbol and its aliases from the fromProgram's SymbolTable to\n  the toProgram's SymbolTable. If the toSymbolTable already has a symbol (and\n  possibly aliases) they are removed and the symbol and aliases from the\n  fromProgram's SymbolTable are added.\n@param fromAddress the address where the symbols will be copy from\/to.\n This address should be derived from the \"from\" program.\n@param replacePrimary true indicates that the primary symbol in the \"to\" program should be\n set to the same symbol as was primary in the \"from\" program.\n@param replaceFunction true indicates that the function symbol in the \"to\" program should be\n set to the same function symbol as in the \"from\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)\n@param monitor the task monitor for notifying the user of this merge's progress.\n@return the symbol now at the address in the toSymbolTable.\n@throws CancelledException if user cancels via the monitor.\n@throws InvalidInputException if a symbol name from the second program isn't valid\n@throws DuplicateNameException if a duplicate name is encountered that couldn't be handled\n while copying a symbol.","static":false,"name":"copySymbols","comment":"replaceSymbol adds the symbol and its aliases from the fromProgram's SymbolTable to\n  the toProgram's SymbolTable. If the toSymbolTable already has a symbol (and\n  possibly aliases) they are removed and the symbol and aliases from the\n  fromProgram's SymbolTable are added.","params":[{"type_long":"ghidra.program.model.address.Address","name":"fromAddress","comment":"the address where the symbols will be copy from\/to.\n This address should be derived from the \"from\" program.","type_short":"Address"},{"type_long":"boolean","name":"replacePrimary","comment":"true indicates that the primary symbol in the \"to\" program should be\n set to the same symbol as was primary in the \"from\" program.","type_short":"boolean"},{"type_long":"boolean","name":"replaceFunction","comment":"true indicates that the function symbol in the \"to\" program should be\n set to the same function symbol as in the \"from\" program.","type_short":"boolean"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"if a duplicate name is encountered that couldn't be handled\n while copying a symbol.","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"if a symbol name from the second program isn't valid","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"the symbol now at the address in the toSymbolTable.","type_short":"void"}},{"javadoc":"@param address This address should be derived from the \"to\" program.\n@param conflictSymbolIDMap maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","static":false,"name":"replacePrimary","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"This address should be derived from the \"to\" program.","type_short":"Address"},{"type_long":"ghidra.util.datastruct.LongLongHashtable","name":"conflictSymbolIDMap","comment":"maps the symbol IDs in the \"from\" program to the symbol IDs\n in the \"to\" program for any symbols (and their associated objects) that were created\n with conflict names.\n (key = \"from\" program's symbol ID; value = \"to\" program's symbol ID)","type_short":"LongLongHashtable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"reApplyDuplicateSymbols","comment":"","params":[{"type_long":"java.util.Hashtable<ghidra.program.model.symbol.Symbol,ghidra.program.model.symbol.Symbol>","name":"dupSyms","comment":"","type_short":"Hashtable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"getDuplicateSymbolsInfo","comment":"","params":[{"type_long":"java.util.Hashtable<ghidra.program.model.symbol.Symbol,ghidra.program.model.symbol.Symbol>","name":"dupSyms","comment":"","type_short":"Hashtable"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}}],"name":"SymbolMerge","comment":"SymbolMerge provides functionality for replacing or merging\n symbols from one program to another.","fields":[{"type_long":"int","javadoc":"Indicates how often to show progress counter changes.","static":true,"name":"PROGRESS_COUNTER_GRANULARITY","comment":"Indicates how often to show progress counter changes.","type_short":"int","constant_value":"129"},{"type_long":"ghidra.program.util.AddressTranslator","javadoc":"","static":false,"name":"originToResultTranslator","comment":"","type_short":"AddressTranslator","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"fromProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"toProgram","comment":"","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.symbol.SymbolTable","javadoc":"","static":false,"name":"fromSymbolTable","comment":"","type_short":"SymbolTable","constant_value":null},{"type_long":"ghidra.program.model.symbol.SymbolTable","javadoc":"","static":false,"name":"toSymbolTable","comment":"","type_short":"SymbolTable","constant_value":null}]}
