{"implements":["ghidra.util.prop.PropertyVisitor"],"javadoc":"<CODE>ProgramMerge<\/CODE> is a class for merging the differences between two\n programs. The differences are merged from program2 into program1.\n <P>Program1 is the program being modified by the merge. Program2 is source\n for obtaining differences to apply to program1.\n <P>If name conflicts occur while merging, the item (for example, symbol) will\n be merged with a new name that consists of the original name followed by \"_conflict\"\n and a one up number.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"<CODE>ProgramMerge<\/CODE> allows the merging of differences from program2\n into program1 (the result program).\n@param resultProgram The result program that will get modified by merge.\n@param originProgram The program (used as read only) for obtaining\n differences to merge.","static":false,"name":"<init>","comment":"ProgramMerge allows the merging of differences from program2\n into program1 (the result program).","params":[{"type_long":"ghidra.program.model.listing.Program","name":"resultProgram","comment":"The result program that will get modified by merge.","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"originProgram","comment":"The program (used as read only) for obtaining\n differences to merge.","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>ProgramMerge<\/CODE> allows the merging of differences from program2 (the origin program)\n into program1 (the result program).\n <br>If the address translator is not a \"one for one translator\" then certain methods within\n this class will throw an UnsupportedOperationException.\n The destination program from the address translator should be the result program into\n which changes are made.\n The source program from the translator is the origin program for obtaining the changes.\n@param addressTranslator converts addresses from the origin program into an\n equivalent address in the destination program.\n@see AddressTranslator","static":false,"name":"<init>","comment":"ProgramMerge allows the merging of differences from program2 (the origin program)\n into program1 (the result program).\n If the address translator is not a \"one for one translator\" then certain methods within\n this class will throw an UnsupportedOperationException.\n The destination program from the address translator should be the result program into\n which changes are made.\n The source program from the translator is the origin program for obtaining the changes.","params":[{"type_long":"ghidra.program.util.AddressTranslator","name":"originToResultTranslator","comment":"","type_short":"AddressTranslator"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Initializes numerous variables to be used by the ProgramMerge.\n@param result the result program where changes are written.\n@param origin the origin program to get information to apply to program1.","static":false,"name":"init","comment":"Initializes numerous variables to be used by the ProgramMerge.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"result","comment":"the result program where changes are written.","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Program","name":"origin","comment":"the origin program to get information to apply to program1.","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets the result program. Merge changes are applied to this program.\n@return the program being changed by the merge.","static":false,"name":"getResultProgram","comment":"Gets the result program. Merge changes are applied to this program.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"the program being changed by the merge.","type_short":"Program"}},{"javadoc":"Gets the origin program. This program is used for obtaining things to merge into program1.\n@return the program we are obtaining the changes from which we will merge.","static":false,"name":"getOriginProgram","comment":"Gets the origin program. This program is used for obtaining things to merge into program1.","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"the program we are obtaining the changes from which we will merge.","type_short":"Program"}},{"javadoc":"Clears all error messages and information messages.","static":false,"name":"clearMessages","comment":"Clears all error messages and information messages.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determines if this ProgramMerge currently has an error message.\n@return true if there is an error message.","static":false,"name":"hasErrorMessage","comment":"Determines if this ProgramMerge currently has an error message.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there is an error message.","type_short":"boolean"}},{"javadoc":"Determines if this ProgramMerge currently has an informational message.\n@return true if there is an information message.","static":false,"name":"hasInfoMessage","comment":"Determines if this ProgramMerge currently has an informational message.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there is an information message.","type_short":"boolean"}},{"javadoc":"Get the error messages that resulted from the last call to a merge or\n replace method. These are errors that prevented something from being merged.\n <br>Important: Call clearErrorMessage() to clear the current error message after this returns it.\n@return the error message string or an empty string if there were no problems with the merge.","static":false,"name":"getErrorMessage","comment":"Get the error messages that resulted from the last call to a merge or\n replace method. These are errors that prevented something from being merged.\n Important: Call clearErrorMessage() to clear the current error message after this returns it.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the error message string or an empty string if there were no problems with the merge.","type_short":"String"}},{"javadoc":"Get the information messages that resulted from the last call to a merge or\n replace method. These messages are non-critical changes that were\n necessary during the merge. For example giving a symbol a name with a conflict\n extension because another symbol with that name existed elsewhere in the\n program already.\n <br>Important: Call clearInfoMessage() to clear the current info message after this returns it.\n@return the information message string or an empty string if there were no informational\n messages for the merge.","static":false,"name":"getInfoMessage","comment":"Get the information messages that resulted from the last call to a merge or\n replace method. These messages are non-critical changes that were\n necessary during the merge. For example giving a symbol a name with a conflict\n extension because another symbol with that name existed elsewhere in the\n program already.\n Important: Call clearInfoMessage() to clear the current info message after this returns it.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the information message string or an empty string if there were no informational\n messages for the merge.","type_short":"String"}},{"javadoc":"This method clears the current error message.","static":false,"name":"clearErrorMessage","comment":"This method clears the current error message.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"This method clears the current informational message.","static":false,"name":"clearInfoMessage","comment":"This method clears the current informational message.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeProgramContext<\/CODE> merges the program context (register values)\n into the result program.\n@param originAddressSet the addresses to be merged.\n The addresses in this set are derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeProgramContext","comment":"mergeProgramContext merges the program context (register values)\n into the result program.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set are derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merge context register values over a specified address range.  It is very important that all\n instructions be cleared over this range in the result program prior to invoking this\n method.\n@param resultContext\n@param originContext\n@param originReg\n@param originRange\n@param resultRange\n@param monitor\n@throws CancelledException\n@throws ContextChangeException if an instruction was encountered where a context register\n value change was attempted","static":false,"name":"mergeProgramContext","comment":"Merge context register values over a specified address range.  It is very important that all\n instructions be cleared over this range in the result program prior to invoking this\n method.","params":[{"type_long":"ghidra.program.model.listing.ProgramContext","name":"resultContext","comment":"","type_short":"ProgramContext"},{"type_long":"ghidra.program.model.listing.ProgramContext","name":"originContext","comment":"","type_short":"ProgramContext"},{"type_long":"ghidra.program.model.lang.Register","name":"originReg","comment":"","type_short":"Register"},{"type_long":"ghidra.program.model.address.AddressRange","name":"originRange","comment":"","type_short":"AddressRange"},{"type_long":"ghidra.program.model.address.AddressRange","name":"resultRange","comment":"","type_short":"AddressRange"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"ghidra.program.model.listing.ContextChangeException","comment":"if an instruction was encountered where a context register\n value change was attempted","type_short":"ContextChangeException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Copies the bytes to the result program from the origin program for the specified set of\n address ranges.\n@param toProgram program that the bytes are copied to.\n@param fromProgram program the bytes are copied from.\n@param originAddressSet the set of address ranges to be copied.\n The addresses in this set are derived from the origin program.\n@throws MemoryAccessException if bytes can't be copied.\n@throws CancelledException if user cancels copy bytes via the monitor.","static":false,"name":"copyBytesInRanges","comment":"Copies the bytes to the result program from the origin program for the specified set of\n address ranges.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the set of address ranges to be copied.\n The addresses in this set are derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be copied.","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels copy bytes via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Copies the bytes to one program memory from another for the specified\n address range.\n@param toMem program memory that the bytes are copied to.\n@param fromMem program memory the bytes are copied from.\n@param fromAddressRange the address range to be copied.\n The addresses in this range are derived from the program associated with the \"to memory\".\n@throws MemoryAccessException if bytes can't be copied.","static":false,"name":"copyByteRange","comment":"Copies the bytes to one program memory from another for the specified\n address range.","params":[{"type_long":"ghidra.program.model.mem.Memory","name":"toMem","comment":"program memory that the bytes are copied to.","type_short":"Memory"},{"type_long":"ghidra.program.model.mem.Memory","name":"fromMem","comment":"program memory the bytes are copied from.","type_short":"Memory"},{"type_long":"ghidra.program.model.address.AddressRange","name":"fromAddressRange","comment":"the address range to be copied.\n The addresses in this range are derived from the program associated with the \"to memory\".","type_short":"AddressRange"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be copied.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeBytes<\/CODE> merges byte differences within the specified\n  address set.\n <br>Note: Any instructions at the equivalent byte addresses in the result program will get cleared and\n re-created resulting in the existing references being dropped.\n@param originAddressSet the addresses to be merged.\n The addresses in this set are derived from the origin program.\n@param overwriteInstructions if true affected instructions will be cleared and\n re-disassmebled after bytes are modified\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws MemoryAccessException if bytes can't be merged.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeBytes","comment":"mergeBytes merges byte differences within the specified\n  address set.\n Note: Any instructions at the equivalent byte addresses in the result program will get cleared and\n re-created resulting in the existing references being dropped.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set are derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"overwriteInstructions","comment":"if true affected instructions will be cleared and\n re-disassmebled after bytes are modified","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be merged.","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the address set for all instructions that overlap the indicated byte address set.\n@param byteAddressSet the byte address set\n The addresses in this set should be derived from the same program for the listing passed as\n parameter 2.\n@param listing the listing to check for instructions\n@return the instruction address set. The addresses in this set will have an address\n factory matching that of the byteAddressSet.","static":false,"name":"getInstructionSet","comment":"Get the address set for all instructions that overlap the indicated byte address set.","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"byteAddressSet","comment":"the byte address set\n The addresses in this set should be derived from the same program for the listing passed as\n parameter 2.","type_short":"AddressSet"},{"type_long":"ghidra.program.model.listing.Listing","name":"listing","comment":"the listing to check for instructions","type_short":"Listing"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"the instruction address set. The addresses in this set will have an address\n factory matching that of the byteAddressSet.","type_short":"AddressSet"}},{"javadoc":"<CODE>mergeCodeUnits<\/CODE> merges all instructions &\/or data\n (as indicated) in the specified address set from the origin program.\n It merges them into the result program. When merging\n instructions, the bytes are also replaced if they differ.\n This assumes originToResultTranslator maps address spaces and does\n not do fine-grained mapping of addresses.\n@param addrSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param byteDiffs address set indicating addresses where the bytes differ\n between the result program and the origin program.\n The addresses in this set should be derived from the origin program.\n@param mergeDataBytes true indicates bytes that differ should be copied when merging Data.\n false means don't copy any bytes for Data.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws MemoryAccessException if bytes can't be copied.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeCodeUnits","comment":"mergeCodeUnits merges all instructions \/or data\n (as indicated) in the specified address set from the origin program.\n It merges them into the result program. When merging\n instructions, the bytes are also replaced if they differ.\n This assumes originToResultTranslator maps address spaces and does\n not do fine-grained mapping of addresses.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"byteDiffs","comment":"address set indicating addresses where the bytes differ\n between the result program and the origin program.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"mergeDataBytes","comment":"true indicates bytes that differ should be copied when merging Data.\n false means don't copy any bytes for Data.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be copied.","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"shouldClearInstruction","comment":"","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instruction","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.listing.Instruction","name":"resultInstruction","comment":"","type_short":"Instruction"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"<CODE>performMergeInstruction<\/CODE> merges the indicated instruction\n into the merge program. Before the instruction is created the bytes for\n the instruction are copied from program2 to program1.\n Corresponding code unit(s) must already be cleared in result program,\n as well as having copied context-register value.\n@param originInstruction the instruction to be merged\n This instruction should be from the origin program.\n@param originByteDiffs address set indicating addresses where the bytes differ\n between program1 and program2.\n The addresses in this set should be from program1.\n@throws CodeUnitInsertionException if the instruction can't be created\n in the merge program.\n@throws MemoryAccessException if bytes can't be copied.","static":false,"name":"performMergeInstruction","comment":"performMergeInstruction merges the indicated instruction\n into the merge program. Before the instruction is created the bytes for\n the instruction are copied from program2 to program1.\n Corresponding code unit(s) must already be cleared in result program,\n as well as having copied context-register value.","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"originInstruction","comment":"the instruction to be merged\n This instruction should be from the origin program.","type_short":"Instruction"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"originByteDiffs","comment":"address set indicating addresses where the bytes differ\n between program1 and program2.\n The addresses in this set should be from program1.","type_short":"AddressSetView"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"if bytes can't be copied.","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"copyInstructionAttributes","comment":"","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"originInstruction","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.listing.Instruction","name":"targetInstruction","comment":"","type_short":"Instruction"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"disassembleDelaySlottedInstruction","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"","type_short":"Instruction"}},{"javadoc":"","static":false,"name":"disassembleNonDelaySlotInstruction","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"","type_short":"Instruction"}},{"javadoc":"","static":false,"name":"bytesAreDifferent","comment":"","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originByteDiffs","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.address.Address","name":"originMin","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"resultMin","comment":"","type_short":"Address"},{"type_long":"int","name":"byteCnt","comment":"","type_short":"int"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"<CODE>performMergeData<\/CODE> merges the indicated defined data\n into the merge program. The bytes in the merge program are not affected\n by this method.\n Corresponding code unit(s) must already be cleared in result program.\n@param originData the defined data to be merged\n This data should be from the origin program.\n@param originByteDiffs address set indicating addresses where the bytes differ\n between the result program and the origin program.\n This addresses in this set should be derived from the origin program.\n@param copyBytes true indicates bytes that differ should be copied.\n false means don't copy any bytes.\n@throws CodeUnitInsertionException if the defined data can't be created\n in the merge program.","static":false,"name":"performMergeData","comment":"performMergeData merges the indicated defined data\n into the merge program. The bytes in the merge program are not affected\n by this method.\n Corresponding code unit(s) must already be cleared in result program.","params":[{"type_long":"ghidra.program.model.listing.Data","name":"originData","comment":"the defined data to be merged\n This data should be from the origin program.","type_short":"Data"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"originByteDiffs","comment":"address set indicating addresses where the bytes differ\n between the result program and the origin program.\n This addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"copyBytes","comment":"true indicates bytes that differ should be copied.\n false means don't copy any bytes.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.util.CodeUnitInsertionException","comment":"if the defined data can't be created\n in the merge program.","type_short":"CodeUnitInsertionException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeEquates<\/CODE> merges the equate differences in the specified\n address set.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"mergeEquates","comment":"mergeEquates merges the equate differences in the specified\n address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeEquate<\/CODE> replaces the current equates in program1 with those in program2.\n@param originAddress the address where the equates should be merged.\n This address should be derived from the origin program.\n@param opIndex the operand index where the equates should be merged.\n@param value the scalar value where the equate is used.","static":false,"name":"mergeEquate","comment":"mergeEquate replaces the current equates in program1 with those in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address where the equates should be merged.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"opIndex","comment":"the operand index where the equates should be merged.","type_short":"int"},{"type_long":"long","name":"value","comment":"the scalar value where the equate is used.","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getUniqueEquate","comment":"","params":[{"type_long":"ghidra.program.model.symbol.EquateTable","name":"et","comment":"","type_short":"EquateTable"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Equate","comment":"","type_short":"Equate"}},{"javadoc":"<CODE>mergeEquates<\/CODE> merges all equates for the indicated\n address from the second program. It merges them into the merge program.\n@param originAddress the address where the equates are to be merged.\n This address should be derived from the origin program.","static":false,"name":"mergeEquates","comment":"mergeEquates merges all equates for the indicated\n address from the second program. It merges them into the merge program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address where the equates are to be merged.\n This address should be derived from the origin program.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@param dupEquate\n@param desiredName","static":false,"name":"saveDuplicateEquate","comment":"","params":[{"type_long":"ghidra.program.model.symbol.Equate","name":"dupEquate","comment":"","type_short":"Equate"},{"type_long":"java.lang.String","name":"desiredName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"reApplyDuplicateEquates","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getDuplicateEquatesInfo","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"clearDuplicateEquates","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceReferences<\/CODE> replaces all references in\n program1 for the specified address set with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceReferences","comment":"replaceReferences replaces all references in\n program1 for the specified address set with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceReferences<\/CODE> replaces all references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param onlyKeepDefaults true indicates to replace all references with only\n the default references from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceReferences","comment":"replaceReferences replaces all references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"onlyKeepDefaults","comment":"true indicates to replace all references with only\n the default references from the origin program.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@param resultAddress This address should be derived from program 1.","static":false,"name":"replaceRefs","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"},{"type_long":"boolean","name":"defaultsOnly","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeReferences<\/CODE> merges the references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference if possible. A merge of references prevents the loss of any\n non-default references already in the result program.\n <br> Important: Fallthrough references will not be merged by this method.\n Fallthroughs are handled by merging code units.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param onlyKeepDefaults true indicates to merge only the default references\n from the origin program into the result program. Non-default references will not be merged.\n false indicates merge all references except fallthroughs.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"mergeReferences","comment":"mergeReferences merges the references in\n program1 for the specified address set with the references from program2.\n If an equivalent reference already exists then it is updated to match the\n new reference if possible. A merge of references prevents the loss of any\n non-default references already in the result program.\n  Important: Fallthrough references will not be merged by this method.\n Fallthroughs are handled by merging code units.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"boolean","name":"onlyKeepDefaults","comment":"true indicates to merge only the default references\n from the origin program into the result program. Non-default references will not be merged.\n false indicates merge all references except fallthroughs.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"mergeRefs","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"},{"type_long":"boolean","name":"defaultsOnly","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"replaceReferences","comment":"","params":[{"type_long":"ghidra.program.model.listing.CodeUnit","name":"originCu","comment":"","type_short":"CodeUnit"},{"type_long":"int","name":"opIndex","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceReferences<\/CODE> replaces all references in\n program1 for the specified address and operand index with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n <br> Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.\n@param originAddress the \"from\" address where references are to be replaced\n@param operandIndex the operand of the code unit at the address where\n references are to be replaced.","static":false,"name":"replaceReferences","comment":"replaceReferences replaces all references in\n program1 for the specified address and operand index with those in program2.\n If an equivalent reference already exists then it is updated to match the\n new reference.\n  Note: All reference types (memory, stack, external) get replaced\n where possible. i.e. If a function or variable doesn't exist for a\n variable reference then it will not be able to replace the reference.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the \"from\" address where references are to be replaced","type_short":"Address"},{"type_long":"int","name":"operandIndex","comment":"the operand of the code unit at the address where\n references are to be replaced.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the reference in program1 with the reference from the origin program.\n@param resultRef the program1 reference to be replaced.\n@param originRef the program2 reference used to replace what's in program1.\n@return the resulting reference in program1. null if reference is removed\n by the replace.","static":false,"name":"replaceReference","comment":"Replaces the reference in program1 with the reference from the origin program.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"resultRef","comment":"the program1 reference to be replaced.","type_short":"Reference"},{"type_long":"ghidra.program.model.symbol.Reference","name":"originRef","comment":"the program2 reference used to replace what's in program1.","type_short":"Reference"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the resulting reference in program1. null if reference is removed\n by the replace.","type_short":"Reference"}},{"javadoc":"","static":false,"name":"updateExternalLocation","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"toPgm","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.symbol.ExternalReference","name":"fromRef","comment":"","type_short":"ExternalReference"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the reference in program1 with the reference from the origin program.\n@param resultRef the program1 reference to be replaced.\n@param originRef the program2 reference used to replace what's in program1.\n@param toSymbolID ID of the symbol in program1 the resulting reference is to.\n@return the resulting reference in program1. null if reference is removed\n by the replace.","static":false,"name":"replaceReference","comment":"Replaces the reference in program1 with the reference from the origin program.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"resultRef","comment":"the program1 reference to be replaced.","type_short":"Reference"},{"type_long":"ghidra.program.model.symbol.Reference","name":"originRef","comment":"the program2 reference used to replace what's in program1.","type_short":"Reference"},{"type_long":"long","name":"toSymbolID","comment":"ID of the symbol in program1 the resulting reference is to.","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the resulting reference in program1. null if reference is removed\n by the replace.","type_short":"Reference"}},{"javadoc":"<CODE>addReference<\/CODE> creates a reference in program1 that is equivalent\n to the one specified as a parameter. If a symbol ID is specified, the\n reference will refer to the symbol in program1 with that ID. If the reference\n is an external reference, then the external location associated with it can be replaced\n also by setting the replace external location flag.\n@param originRef the reference equivalent to the one to be created.\n@param toSymbolID ID of the symbol to referred to. null indicates don't\n refer directly to a symbol.\n@param replaceExtLoc the replace external location flag. true indicates to replace the\n external location, if applicable, with the one defined for the reference passed to this method.\n@return the reference that was created. null if none created.","static":false,"name":"addReference","comment":"addReference creates a reference in program1 that is equivalent\n to the one specified as a parameter. If a symbol ID is specified, the\n reference will refer to the symbol in program1 with that ID. If the reference\n is an external reference, then the external location associated with it can be replaced\n also by setting the replace external location flag.","params":[{"type_long":"ghidra.program.model.symbol.Reference","name":"originRef","comment":"the reference equivalent to the one to be created.","type_short":"Reference"},{"type_long":"long","name":"toSymbolID","comment":"ID of the symbol to referred to. null indicates don't\n refer directly to a symbol.","type_short":"long"},{"type_long":"boolean","name":"replaceExtLoc","comment":"the replace external location flag. true indicates to replace the\n external location, if applicable, with the one defined for the reference passed to this method.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.Reference","comment":"the reference that was created. null if none created.","type_short":"Reference"}},{"javadoc":"","static":false,"name":"findExternalLocation","comment":"","params":[{"type_long":"ghidra.program.model.symbol.ExternalLocation","name":"origExtLoc","comment":"","type_short":"ExternalLocation"},{"type_long":"ghidra.program.model.symbol.Symbol","name":"resultToSymbol","comment":"","type_short":"Symbol"}],"throws":[],"return":{"type_long":"ghidra.program.model.symbol.ExternalLocation","comment":"","type_short":"ExternalLocation"}},{"javadoc":"<CODE>replaceFallThroughs<\/CODE> replaces all fallthroughs in\n program1 for the specified address set with those in program2 where they differ.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if the user cancels the replace via the monitor.","static":false,"name":"replaceFallThroughs","comment":"replaceFallThroughs replaces all fallthroughs in\n program1 for the specified address set with those in program2 where they differ.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the replace via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"replaceFallThrough","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeComment<\/CODE> merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.\n@param originAddressSet the addresses where comments should be merged\/replaced.\n The addresses in this set should be from the origin program.\n@param type ProgramMergeFilter comment type.\n The comment type can be PLATE, PRE, EOL, REPEATABLE, POST.\n@param both true means merge both program1 and program2 comments.\n false means replace the program1 comment with the program2 comment.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeComment","comment":"mergeComment merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"originAddressSet","comment":"the addresses where comments should be merged\/replaced.\n The addresses in this set should be from the origin program.","type_short":"AddressSet"},{"type_long":"int","name":"type","comment":"ProgramMergeFilter comment type.\n The comment type can be PLATE, PRE, EOL, REPEATABLE, POST.","type_short":"int"},{"type_long":"boolean","name":"both","comment":"true means merge both program1 and program2 comments.\n false means replace the program1 comment with the program2 comment.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeCommentType<\/CODE> merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.\n It merges them from program2 into program1.\n This merges eol, pre, post, repeatable, and plate comments.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from the origin program.\n@param type the comment type. PLATE, PRE, EOL, REPEATABLE, POST\n@param setting how to merge. IGNORE, REPLACE, MERGE\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeCommentType","comment":"mergeCommentType merges\/replaces comments of the indicated\n type wherever they occur in the specified address set.\n It merges them from program2 into program1.\n This merges eol, pre, post, repeatable, and plate comments.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from the origin program.","type_short":"AddressSetView"},{"type_long":"int","name":"type","comment":"the comment type. PLATE, PRE, EOL, REPEATABLE, POST","type_short":"int"},{"type_long":"int","name":"setting","comment":"how to merge. IGNORE, REPLACE, MERGE","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeComments<\/CODE> merges the comment of the indicated\n type in program1 with the comment in program2 at the specified address.\n@param commentType comment type to merge (from CodeUnit class).\n <br>EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.\n@param addr the address\n This address should be derived from the origin program.","static":false,"name":"mergeComments","comment":"mergeComments merges the comment of the indicated\n type in program1 with the comment in program2 at the specified address.","params":[{"type_long":"int","name":"commentType","comment":"comment type to merge (from CodeUnit class).\n EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceComment<\/CODE> replaces the comment of the indicated\n type in program1 with the comment in program2 at the specified address.\n@param commentType comment type to replace (from CodeUnit class).\n <br>EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.\n@param addr the address\n This address should be derived from the origin program.","static":false,"name":"replaceComment","comment":"replaceComment replaces the comment of the indicated\n type in program1 with the comment in program2 at the specified address.","params":[{"type_long":"int","name":"commentType","comment":"comment type to replace (from CodeUnit class).\n EOL_COMMENT, PRE_COMMENT, POST_COMMENT, REPEATABLE_COMMENT, OR PLATE_COMMENT.","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges\/replaces tags of program2 into program1. When merging, tags that are in\n conflict are replaced according to the user setting (ignore, replace, merge).\n@param originAddressSet the addresses to be merged.\n@param setting how to merge. IGNORE, REPLACE, MERGE\n@param discardTags tags to keep out of the final result\n@param keepTags tags to add to the final result\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"applyFunctionTagChanges","comment":"Merges\/replaces tags of program2 into program1. When merging, tags that are in\n conflict are replaced according to the user setting (ignore, replace, merge).","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.","type_short":"AddressSetView"},{"type_long":"int","name":"setting","comment":"how to merge. IGNORE, REPLACE, MERGE","type_short":"int"},{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"discardTags","comment":"tags to keep out of the final result","type_short":"Set"},{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"keepTags","comment":"tags to add to the final result","type_short":"Set"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Combines function tags in Original with Result, making sure that all tags in the\n keepTags list are included, while removing any in the discardTags list.\n@param originAddress the address\n@param discardTags tags to discard from the result\n@param keepTags tags to add to the result","static":false,"name":"mergeFunctionTags","comment":"Combines function tags in Original with Result, making sure that all tags in the\n keepTags list are included, while removing any in the discardTags list.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address","type_short":"Address"},{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"discardTags","comment":"tags to discard from the result","type_short":"Set"},{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"keepTags","comment":"tags to add to the result","type_short":"Set"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Removes the given tag from the program if it is not currently being used by\n any functions.\n@param tag the tag to remove","static":false,"name":"removeTagIfUnassigned","comment":"Removes the given tag from the program if it is not currently being used by\n any functions.","params":[{"type_long":"ghidra.program.model.listing.FunctionTag","name":"tag","comment":"the tag to remove","type_short":"FunctionTag"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if the given set of tags contains one with the given name.\n@param tags the list of tags to inspect\n@param name the name to find\n@return true if the list contains the tag","static":false,"name":"containsTag","comment":"Returns true if the given set of tags contains one with the given name.","params":[{"type_long":"java.util.Collection<ghidra.program.model.listing.FunctionTag>","name":"tags","comment":"the list of tags to inspect","type_short":"Collection"},{"type_long":"java.lang.String","name":"name","comment":"the name to find","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the list contains the tag","type_short":"boolean"}},{"javadoc":"Returns a list of all tag names in the given set of function tags.\n@param tags the list of function tags\n@return list of tag names","static":false,"name":"getTagNames","comment":"Returns a list of all tag names in the given set of function tags.","params":[{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","name":"tags","comment":"the list of function tags","type_short":"Set"}],"throws":[],"return":{"type_long":"java.util.Set<java.lang.String>","comment":"list of tag names","type_short":"Set"}},{"javadoc":"Returns a set of all function tags for the function containing the given address, for the\n given listing.\n@param listing the listing\n@param addr the function address to inspect\n@return set of function tags or an empty set if the address isn't in a function.","static":false,"name":"getTagsAtAddress","comment":"Returns a set of all function tags for the function containing the given address, for the\n given listing.","params":[{"type_long":"ghidra.program.model.listing.Listing","name":"listing","comment":"the listing","type_short":"Listing"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the function address to inspect","type_short":"Address"}],"throws":[],"return":{"type_long":"java.util.Set<ghidra.program.model.listing.FunctionTag>","comment":"set of function tags or an empty set if the address isn't in a function.","type_short":"Set"}},{"javadoc":"Clears out the function tags at the given address in Result and\n replaces them with tags from Origin.\n@param originAddress the function entry point in Origin","static":false,"name":"replaceFunctionTags","comment":"Clears out the function tags at the given address in Result and\n replaces them with tags from Origin.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the function entry point in Origin","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeLabels<\/CODE> merges all symbols and aliases\n in the specified address set from the second program.\n It merges them into the merge program.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from program1.\n@param setting the current merge label setting.\n@param replacePrimary true indicates the primary label should become the same as in the second program.\n@param replaceFunction true indicates the function symbol should also be merged.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeLabels","comment":"mergeLabels merges all symbols and aliases\n in the specified address set from the second program.\n It merges them into the merge program.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"int","name":"setting","comment":"the current merge label setting.","type_short":"int"},{"type_long":"boolean","name":"replacePrimary","comment":"true indicates the primary label should become the same as in the second program.","type_short":"boolean"},{"type_long":"boolean","name":"replaceFunction","comment":"true indicates the function symbol should also be merged.","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeLabels<\/CODE> merges all symbols and aliases\n in the specified address set from the second program.\n It merges them into the merge program.\n@param originAddressSet the addresses to be merged.\n The addresses in this address set should be derived from program1.\n@param setting the current label setting.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeLabels","comment":"mergeLabels merges all symbols and aliases\n in the specified address set from the second program.\n It merges them into the merge program.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this address set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"int","name":"setting","comment":"the current label setting.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceLabels<\/CODE> replaces all symbols and aliases\n in the specified address set from the second program.\n@param originAddressSet the addresses to be replaced\n The addresses in this address set should be derived from program1.\n@param replaceFunction true indicates the function symbol should be replaced\n@param monitor the task monitor for notifying the user of this merge's progress\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"replaceLabels","comment":"replaceLabels replaces all symbols and aliases\n in the specified address set from the second program.","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"originAddressSet","comment":"the addresses to be replaced\n The addresses in this address set should be derived from program1.","type_short":"AddressSet"},{"type_long":"boolean","name":"replaceFunction","comment":"true indicates the function symbol should be replaced","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"reApplyDuplicateSymbols","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getDuplicateSymbolsInfo","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"clearDuplicateSymbols","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determines whether the \"fromFunc\" function's body overlaps any function bodies that already\n exist within the \"toProgram\" other than a function with an\n entry point at the \"fromFunc\" function's entry point.\n@param fromFunc the function whose body should get checked.\n@param toProgram the program to check the function body against.\n@return true if it overlaps functions other than one with an entry point matching\n that of the \"fromFunc\".","static":true,"name":"overlapsOtherFunctions","comment":"Determines whether the \"fromFunc\" function's body overlaps any function bodies that already\n exist within the \"toProgram\" other than a function with an\n entry point at the \"fromFunc\" function's entry point.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"the function whose body should get checked.","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Program","name":"toProgram","comment":"the program to check the function body against.","type_short":"Program"}],"throws":[],"return":{"type_long":"boolean","comment":"true if it overlaps functions other than one with an entry point matching\n that of the \"fromFunc\".","type_short":"boolean"}},{"javadoc":"Determines whether the \"fromFunc\" function's body overlaps any function bodies that already\n exist within the \"toProgram\" other than a function with an\n entry point at the \"fromFunc\" function's entry point.\n@param fromFunc the function whose body should get checked.\n@param toProgram the program to check the function body against.\n@return true if it overlaps functions other than one with an entry point matching\n that of the \"fromFunc\".\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":true,"name":"overlapsOtherFunctions","comment":"Determines whether the \"fromFunc\" function's body overlaps any function bodies that already\n exist within the \"toProgram\" other than a function with an\n entry point at the \"fromFunc\" function's entry point.","params":[{"type_long":"ghidra.program.util.AddressTranslator","name":"addressTranslator","comment":"","type_short":"AddressTranslator"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"the function whose body should get checked.","type_short":"Function"}],"throws":[{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"boolean","comment":"true if it overlaps functions other than one with an entry point matching\n that of the \"fromFunc\".","type_short":"boolean"}},{"javadoc":"<CODE>replaceFunctionNames<\/CODE> merges function name and namespace differences\n within the specified address set.\n@param originAddressSet the addresses to be merged.\n The addresses in this set should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"replaceFunctionNames","comment":"replaceFunctionNames merges function name and namespace differences\n within the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctions<\/CODE> merges function differences within the specified\n  address set.\n@param addrSet the addresses to be merged.\n The addresses in this set should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeFunctions","comment":"mergeFunctions merges function differences within the specified\n  address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet","comment":"the addresses to be merged.\n The addresses in this set should be derived from program1.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"removeFunctionsNotInProgram2","comment":"","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet2","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"replaceFunctions","comment":"","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"addrSet2","comment":"","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"replaceThunks","comment":"","params":[{"type_long":"ghidra.program.model.address.AddressSet","name":"thunkSet","comment":"","type_short":"AddressSet"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isThunkFunction","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"<CODE>mergeFunction<\/CODE> completely replaces any function at the\n indicated address in program1 with the function, if any, in program2.\n@param entry the entry point address of the function to be merged.\n This address should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"mergeFunction","comment":"mergeFunction completely replaces any function at the\n indicated address in program1 with the function, if any, in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"the entry point address of the function to be merged.\n This address should be derived from program1.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"","type_short":"Function"}},{"javadoc":"<CODE>mergeFunctionReturn<\/CODE> replaces the return type\/storage of the\n function in program1 with the return type\/storage of the function in program2\n at the specified entry point address.\n@param entry the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionReturn","comment":"mergeFunctionReturn replaces the return type\/storage of the\n function in program1 with the return type\/storage of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionName<\/CODE> replaces the name of the\n function in program1 with the name of the function in program2\n at the specified entry point address.\n@param entry the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws InvalidInputException\n@throws DuplicateNameException","static":false,"name":"mergeFunctionName","comment":"mergeFunctionName replaces the name of the\n function in program1 with the name of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"replaceFunctionName","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"function","comment":"","type_short":"Function"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"","type_short":"SourceType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"sameDataType","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt1","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"dt2","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"<CODE>replaceFunctionSignatureSource<\/CODE> changes the result function's signature source\n to match the origin program's signature source.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionSignatureSource","comment":"replaceFunctionSignatureSource changes the result function's signature source\n to match the origin program's signature source.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionReturnAddressOffset<\/CODE> replaces the return address offset of the\n function in program1 with the return address offset of the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionReturnAddressOffset","comment":"mergeFunctionReturnAddressOffset replaces the return address offset of the\n function in program1 with the return address offset of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionLocalSize<\/CODE> replaces the local size of the\n function in program1 with the local size of the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionLocalSize","comment":"mergeFunctionLocalSize replaces the local size of the\n function in program1 with the local size of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeFunctionStackPurgeSize<\/CODE> replaces the stack purge size of the\n function in program1 with the stack purge size of the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"mergeFunctionStackPurgeSize","comment":"mergeFunctionStackPurgeSize replaces the stack purge size of the\n function in program1 with the stack purge size of the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVarArgs<\/CODE> changes whether the function has VarArgs\n in program1 if it doesn't match the use of VarArgs in the function in program2\n at the specified entry point address.\n@param entry2 the entry point address of the function.\n This address should be derived from program1.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionVarArgs","comment":"replaceFunctionVarArgs changes whether the function has VarArgs\n in program1 if it doesn't match the use of VarArgs in the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry2","comment":"the entry point address of the function.\n This address should be derived from program1.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionCallingConvention<\/CODE> changes the function calling convention\n in program1 if it doesn't match the function calling convention in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionCallingConvention","comment":"replaceFunctionCallingConvention changes the function calling convention\n in program1 if it doesn't match the function calling convention in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionInlineFlag<\/CODE> changes whether the function is inline\n in program1 if it doesn't match whether the function is inline in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionInlineFlag","comment":"replaceFunctionInlineFlag changes whether the function is inline\n in program1 if it doesn't match whether the function is inline in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionNoReturnFlag<\/CODE> changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"does not return\" flag in the function in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionNoReturnFlag","comment":"replaceFunctionNoReturnFlag changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"does not return\" flag in the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionCustomStorageFlag<\/CODE> changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"custom storage\" flag in the function in program2\n at the specified entry point address.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.","static":false,"name":"replaceFunctionCustomStorageFlag","comment":"replaceFunctionCustomStorageFlag changes whether the flag is set indicating\n the function does not return\n in program1 if it doesn't match the \"custom storage\" flag in the function in program2\n at the specified entry point address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameters<\/CODE> replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.\n@param originEntryPoint the entry point address of the function.\n This address should be derived from the origin program.","static":false,"name":"replaceFunctionParameters","comment":"replaceFunctionParameters replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameters<\/CODE> replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.\n@param toFunc target function\n@param fromFunc source function","static":false,"name":"replaceFunctionParameters","comment":"replaceFunctionParameters replaces the parameters of the\n function in program1 with the parameters of the function in program2\n at the specified entry point address.  It also replaces the return\n type\/storage as well as custom storage use.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"target function","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"source function","type_short":"Function"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Create a name that is unique in both namespaces of the given symbolTable.\n@param symbolTable the symbolTable where the symbol will be created.\n@param name the desired name. This name will be given a conflict suffix if necessary\n to make it unique.\n@param address the address of the symbol.\n@param namespace1 the first namespace where the new symbol should be unique. \n This namespace must be from the same program as the symbol table.\n@param namespace2 the second namespace where the new symbol should be unique.\n This namespace must be from the same program as the symbol table.\n@param type the symbol type of the symbol.\n@return a unique name for both namespaces.","static":true,"name":"getUniqueName","comment":"Create a name that is unique in both namespaces of the given symbolTable.","params":[{"type_long":"ghidra.program.model.symbol.SymbolTable","name":"symbolTable","comment":"the symbolTable where the symbol will be created.","type_short":"SymbolTable"},{"type_long":"java.lang.String","name":"name","comment":"the desired name. This name will be given a conflict suffix if necessary\n to make it unique.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the symbol.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace1","comment":"the first namespace where the new symbol should be unique. \n This namespace must be from the same program as the symbol table.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace2","comment":"the second namespace where the new symbol should be unique.\n This namespace must be from the same program as the symbol table.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the symbol type of the symbol.","type_short":"SymbolType"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"a unique name for both namespaces.","type_short":"String"}},{"javadoc":"Create a name that is unique in the indicated namespace of the symbol table.\n@param symbolTable the symbolTable where the symbol will be created.\n@param name the desired name. This name will be given a conflict suffix if necessary\n to make it unique.\n@param address the address of the symbol.\n@param namespace the namespace where the new symbol would be created.\n This namespace must be from the same program as the symbol table.\n@param type the type of symbol.\n@return a unique name within the namespace.","static":true,"name":"getUniqueName","comment":"Create a name that is unique in the indicated namespace of the symbol table.","params":[{"type_long":"ghidra.program.model.symbol.SymbolTable","name":"symbolTable","comment":"the symbolTable where the symbol will be created.","type_short":"SymbolTable"},{"type_long":"java.lang.String","name":"name","comment":"the desired name. This name will be given a conflict suffix if necessary\n to make it unique.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the symbol.","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace where the new symbol would be created.\n This namespace must be from the same program as the symbol table.","type_short":"Namespace"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the type of symbol.","type_short":"SymbolType"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"a unique name within the namespace.","type_short":"String"}},{"javadoc":"Tests if a symbol can successfully be created.  This is useful when creating symbol\n types that require unique names such as Namespaces, Libraries, and Classes.\n@param namespace the namespace where the new symbol would be created.\n@param name the name of the symbol to test.\n@param address the address of the symbol to test. (Can be null)\n@param type the symbol type of the symbol to test.\n@return true if the symbol with the given properties could be created without causing\n a duplicate name exception.","static":true,"name":"isUniqueSymbolName","comment":"Tests if a symbol can successfully be created.  This is useful when creating symbol\n types that require unique names such as Namespaces, Libraries, and Classes.","params":[{"type_long":"ghidra.program.model.symbol.SymbolTable","name":"symbolTable","comment":"","type_short":"SymbolTable"},{"type_long":"ghidra.program.model.symbol.Namespace","name":"namespace","comment":"the namespace where the new symbol would be created.","type_short":"Namespace"},{"type_long":"java.lang.String","name":"name","comment":"the name of the symbol to test.","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"the address of the symbol to test. (Can be null)","type_short":"Address"},{"type_long":"ghidra.program.model.symbol.SymbolType","name":"type","comment":"the symbol type of the symbol to test.","type_short":"SymbolType"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the symbol with the given properties could be created without causing\n a duplicate name exception.","type_short":"boolean"}},{"javadoc":"Adds\/Replaces\/Removes a function at the specified address in the\n resultListing based on the function in the origListing.\n <br>Note: This method will replace the function, but does not create\n the parent namespace or put the function in the parent namespace.\n This must be done separately.\n@param originEntryPoint the address of the functions entry point.\n This address should be derived from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@return the new function that was created in the resultListing or null\n if no function was created. If null is returned you should call\n getErrorMessage() to see if an error occurred.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceFunction","comment":"Adds\/Replaces\/Removes a function at the specified address in the\n resultListing based on the function in the origListing.\n Note: This method will replace the function, but does not create\n the parent namespace or put the function in the parent namespace.\n This must be done separately.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the address of the functions entry point.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the new function that was created in the resultListing or null\n if no function was created. If null is returned you should call\n getErrorMessage() to see if an error occurred.","type_short":"Function"}},{"javadoc":"Replaces the external result function with the origin Function.\n <br>Note: This method will replace the function, but does not create\n the parent namespace or put the function in the parent namespace.\n This must be done separately.\n@param toFunction the result function to replace.\n@param fromFunction the function to use as the model when replacing the result function.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@return the new function that was created in the resultListing or null\n if no function was created. If null is returned you should call\n getErrorMessage() to see if an error occurred.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translators are not\n \"one for one translators\".","static":false,"name":"replaceExternalFunction","comment":"Replaces the external result function with the origin Function.\n Note: This method will replace the function, but does not create\n the parent namespace or put the function in the parent namespace.\n This must be done separately.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunction","comment":"the result function to replace.","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunction","comment":"the function to use as the model when replacing the result function.","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translators are not\n \"one for one translators\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the new function that was created in the resultListing or null\n if no function was created. If null is returned you should call\n getErrorMessage() to see if an error occurred.","type_short":"Function"}},{"javadoc":"@param newFunc\n@param fromFunc\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"replaceVariables","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"newFunc","comment":"","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"resolveParamaterNameConflicts","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Parameter[]","name":"fromParams","comment":"","type_short":"ghidra.program.model.listing.Parameter[]"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"resolveParameterNameConflict","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"","type_short":"Function"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Replaces the local symbols in toFunc with the local symbols that are in the fromFunc.\n@param toFunc the function having its local variables replaced.\n@param fromFunc the source of the replacement variables.\n@throws CancelledException if user cancels via the monitor.","static":false,"name":"replaceLocals","comment":"Replaces the local symbols in toFunc with the local symbols that are in the fromFunc.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"the function having its local variables replaced.","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"the source of the replacement variables.","type_short":"Function"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"replaceVariable","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"fromFunc","comment":"","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Variable","name":"fromVar","comment":"","type_short":"Variable"},{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"","type_short":"Function"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Variable","comment":"","type_short":"Variable"}},{"javadoc":"","static":false,"name":"resolveLocalNameConflict","comment":"","params":[{"type_long":"ghidra.program.model.listing.Function","name":"toFunc","comment":"","type_short":"Function"},{"type_long":"java.lang.String","name":"name","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Changes the variable's name to a unique name.\n@param namedSymbol the variable's symbol\n@param source the source of this variable's symbol\n@return the new name or null if it couldn't be renamed.","static":false,"name":"renameVarUniquely","comment":"Changes the variable's name to a unique name.","params":[{"type_long":"ghidra.program.model.symbol.Symbol","name":"namedSymbol","comment":"the variable's symbol","type_short":"Symbol"},{"type_long":"ghidra.program.model.symbol.SourceType","name":"source","comment":"the source of this variable's symbol","type_short":"SourceType"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the new name or null if it couldn't be renamed.","type_short":"String"}},{"javadoc":"Detail level parameter adjustments may only be done when both source and result functions\n initially had the same number of auto-params and the same total number of parameters\n (only complete signature replacement is supported otherwise).  This method is intended to\n adjust the result ordinal based upon adjustments which may have already been performed on\n the result function causing its number of auto-params to change from when the\n conflicts were initially determined.\n@param func\n@param ordinal\n@return adjusted result parameter ordinal","static":false,"name":"getAdjustedResultOrdinal","comment":"Detail level parameter adjustments may only be done when both source and result functions\n initially had the same number of auto-params and the same total number of parameters\n (only complete signature replacement is supported otherwise).  This method is intended to\n adjust the result ordinal based upon adjustments which may have already been performed on\n the result function causing its number of auto-params to change from when the\n conflicts were initially determined.","params":[{"type_long":"ghidra.program.model.listing.Function","name":"resultFunc","comment":"","type_short":"Function"},{"type_long":"ghidra.program.model.listing.Function","name":"srcFunc","comment":"","type_short":"Function"},{"type_long":"int","name":"ordinal","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"adjusted result parameter ordinal","type_short":"int"}},{"javadoc":"<CODE>replaceFunctionParameterName<\/CODE> replaces the name of the indicated\n function parameter in program1 with the name from the origin program.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param ordinal the index of the parameter to change.\n@param monitor the task monitor for notifying the user of progress.\n@throws InvalidInputException\n@throws DuplicateNameException","static":false,"name":"replaceFunctionParameterName","comment":"replaceFunctionParameterName replaces the name of the indicated\n function parameter in program1 with the name from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"ordinal","comment":"the index of the parameter to change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameterDataType<\/CODE> replaces the data type of the indicated\n function parameter in program1 with the data type from the origin program.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param ordinal the index of the parameter to change.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionParameterDataType","comment":"replaceFunctionParameterDataType replaces the data type of the indicated\n function parameter in program1 with the data type from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"ordinal","comment":"the index of the parameter to change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionParameterComment<\/CODE> replaces the comment of the indicated\n function parameter in program1 with the comment from the origin program.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param ordinal the index of the parameter to change.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionParameterComment","comment":"replaceFunctionParameterComment replaces the comment of the indicated\n function parameter in program1 with the comment from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"int","name":"ordinal","comment":"the index of the parameter to change.","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariable<\/CODE> replaces the name of the indicated\n function variable in program1 with that from the origin program.\n@param entry the entry point address of the function to modify.\n This address should be derived from program1.\n@param var a variable that is equivalent to the one in program1 to be replaced.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.\n@throws DuplicateNameException","static":false,"name":"replaceFunctionVariable","comment":"replaceFunctionVariable replaces the name of the indicated\n function variable in program1 with that from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be replaced.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariables<\/CODE> replaces the\n function variables\/parameters in program1 with that from the origin program.\n@param entry the entry point address of the function to modify.\n This address should be derived from program1.\n@param var a variable that is equivalent to the one in program1 to be replaced.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.\n@throws DuplicateNameException","static":false,"name":"replaceVariables","comment":"replaceFunctionVariables replaces the\n function variables\/parameters in program1 with that from the origin program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"","type_short":"Address"},{"type_long":"java.util.List<ghidra.program.model.listing.Variable>","name":"varList","comment":"","type_short":"List"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Finds a variable in the array that is equivalent to the one specified by var.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param variables the variables to be searched\n@return the equivalent variable in the array or null.","static":false,"name":"findVariable","comment":"Finds a variable in the array that is equivalent to the one specified by var.","params":[{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.program.model.listing.Variable[]","name":"variables","comment":"the variables to be searched","type_short":"ghidra.program.model.listing.Variable[]"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Variable","comment":"the equivalent variable in the array or null.","type_short":"Variable"}},{"javadoc":"<CODE>replaceFunctionVariableName<\/CODE> replaces the name on the indicated\n function variable in program1 with the name from the equivalent variable in program2.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.\n@throws InvalidInputException\n@throws DuplicateNameException","static":false,"name":"replaceFunctionVariableName","comment":"replaceFunctionVariableName replaces the name on the indicated\n function variable in program1 with the name from the equivalent variable in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"},{"type_long":"ghidra.util.exception.InvalidInputException","comment":"","type_short":"InvalidInputException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariableDataType<\/CODE> replaces the data type on the indicated\n function variable in program1 with the data type from the equivalent variable in program2.\n@param originEntryPoint the entry point address of the function to modify.\n This address should be derived from the origin program.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionVariableDataType","comment":"replaceFunctionVariableDataType replaces the data type on the indicated\n function variable in program1 with the data type from the equivalent variable in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"the entry point address of the function to modify.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>replaceFunctionVariableComment<\/CODE> replaces the comment on the indicated\n function variable in program1 with the comment from the equivalent variable in program2.\n@param originEntryPoint entry point address of the function whose variable is getting the comment replaced.\n This address should be derived from the origin program.\n@param var a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.\n@param monitor the task monitor for notifying the user of progress.","static":false,"name":"replaceFunctionVariableComment","comment":"replaceFunctionVariableComment replaces the comment on the indicated\n function variable in program1 with the comment from the equivalent variable in program2.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originEntryPoint","comment":"entry point address of the function whose variable is getting the comment replaced.\n This address should be derived from the origin program.","type_short":"Address"},{"type_long":"ghidra.program.model.listing.Variable","name":"var","comment":"a variable that is equivalent to the one in program1 to be changed.\n The variable passed here could be from another program.","type_short":"Variable"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of progress.","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeBookmarks<\/CODE> merges bookmark differences from the origin program to the\n result program\n  within the specified address set.\n@param originAddressSet the addresses in the origin program where bookmarks are to be\n merged to the equivalent address in the result program.\n@param monitor the task monitor for notifying the user of this merge's\n progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeBookmarks","comment":"mergeBookmarks merges bookmark differences from the origin program to the\n result program\n  within the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses in the origin program where bookmarks are to be\n merged to the equivalent address in the result program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's\n progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Merges the bookmarks from the origin program into the result\n  program at an address equivalent to the originAddress. Merging means replace any existing\n  bookmarks in the merge program at the address with the bookmarks\n  found in the listing at that address.\n@param originAddress the address in the origin program to get the bookmarks from.","static":false,"name":"mergeBookmarksAtAddress","comment":"Merges the bookmarks from the origin program into the result\n  program at an address equivalent to the originAddress. Merging means replace any existing\n  bookmarks in the merge program at the address with the bookmarks\n  found in the listing at that address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address in the origin program to get the bookmarks from.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeBookmark<\/CODE> merges the indicated bookmark from the origin program into the\n result program at an address equivalent to the originAddress.\n Merging means replace any existing bookmark of the specified type for NOTEs\n or of the specified type and category for non-NOTE types.\n <p>Note: This method merges a single bookmark without affecting\n other bookmarks at the indicated address.\n@param originAddress the address in the origin program where the bookmark is to be merged.\n@param type indicates the type of bookmark to merge.\n@param category indicates the category of the bookmark.\n@param monitor a task monitor for providing feedback to the user.\n@throws CancelledException if the user cancels the bookmark merge from the monitor dialog.","static":false,"name":"mergeBookmark","comment":"mergeBookmark merges the indicated bookmark from the origin program into the\n result program at an address equivalent to the originAddress.\n Merging means replace any existing bookmark of the specified type for NOTEs\n or of the specified type and category for non-NOTE types.\n Note: This method merges a single bookmark without affecting\n other bookmarks at the indicated address.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address in the origin program where the bookmark is to be merged.","type_short":"Address"},{"type_long":"java.lang.String","name":"type","comment":"indicates the type of bookmark to merge.","type_short":"String"},{"type_long":"java.lang.String","name":"category","comment":"indicates the category of the bookmark.","type_short":"String"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"a task monitor for providing feedback to the user.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the user cancels the bookmark merge from the monitor dialog.","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"<CODE>mergeProperties<\/CODE> merges user defined property differences\n  within the specified address set.\n@param originAddressSet the addresses to be merged from the origin program.\n@param monitor the task monitor for notifying the user of this merge's progress.\n@throws CancelledException if user cancels via the monitor.\n@throws UnsupportedOperationException if the ProgramMerge translator is not a\n \"one for one translator\".","static":false,"name":"mergeProperties","comment":"mergeProperties merges user defined property differences\n  within the specified address set.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"originAddressSet","comment":"the addresses to be merged from the origin program.","type_short":"AddressSetView"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor for notifying the user of this merge's progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels via the monitor.","type_short":"CancelledException"},{"type_long":"java.lang.UnsupportedOperationException","comment":"if the ProgramMerge translator is not a\n \"one for one translator\".","type_short":"UnsupportedOperationException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the user defined properties from the origin program into the result\n  program at the address that is equivalent to the origin address.\n  Note: To merge properties, there must be a code unit AT the equivalent address\n  in the result program.\n@param originAddress the address of the code unit to get the properties from in the origin program.","static":false,"name":"mergePropertiesAtAddress","comment":"Replaces the user defined properties from the origin program into the result\n  program at the address that is equivalent to the origin address.\n  Note: To merge properties, there must be a code unit AT the equivalent address\n  in the result program.","params":[{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address of the code unit to get the properties from in the origin program.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Replaces the user defined properties from the specified origin address in the origin program\n to the equivalent result address in the result program.\n Note: To merge properties, there must be a code unit AT the equivalent address\n in the result program.\n@param originAddress the address of the code unit to get the properties from in the origin program.","static":false,"name":"mergeUserProperty","comment":"Replaces the user defined properties from the specified origin address in the origin program\n to the equivalent result address in the result program.\n Note: To merge properties, there must be a code unit AT the equivalent address\n in the result program.","params":[{"type_long":"java.lang.String","name":"userPropertyName","comment":"","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"originAddress","comment":"the address of the code unit to get the properties from in the origin program.","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getProperty","comment":"","params":[{"type_long":"ghidra.program.model.util.PropertyMap","name":"map","comment":"","type_short":"PropertyMap"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"java.lang.Object","comment":"","type_short":"Object"}},{"javadoc":"","static":false,"name":"setProperty","comment":"","params":[{"type_long":"ghidra.program.model.util.PropertyMap","name":"map","comment":"","type_short":"PropertyMap"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"","type_short":"Address"},{"type_long":"java.lang.Object","name":"property","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is a void property type.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is a void property type.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is a String property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is a String property type.","params":[{"type_long":"java.lang.String","name":"value","comment":"the value for the named property.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is an Object property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is an Object property type.","params":[{"type_long":"java.lang.Object","name":"value","comment":"the value for the named property.","type_short":"Object"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is an Object property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is an Object property type.","params":[{"type_long":"ghidra.util.Saveable","name":"value","comment":"the value for the named property.","type_short":"Saveable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Set the property on the merge program's code unit if the named property\n  is an int property type.\n@param value the value for the named property.","static":false,"name":"visit","comment":"Set the property on the merge program's code unit if the named property\n  is an int property type.","params":[{"type_long":"int","name":"value","comment":"the value for the named property.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"ProgramMerge","comment":"ProgramMerge is a class for merging the differences between two\n programs. The differences are merged from program2 into program1.\n Program1 is the program being modified by the merge. Program2 is source\n for obtaining differences to apply to program1.\n If name conflicts occur while merging, the item (for example, symbol) will\n be merged with a new name that consists of the original name followed by \"_conflict\"\n and a one up number.","fields":[{"type_long":"java.lang.String","javadoc":"Suffix that is attached to a symbol name and then followed by a number to create a new unique symbol name.","static":true,"name":"SYMBOL_CONFLICT_SUFFIX","comment":"Suffix that is attached to a symbol name and then followed by a number to create a new unique symbol name.","type_short":"String","constant_value":null},{"type_long":"int","javadoc":"Indicates how often to show progress counter changes.","static":true,"name":"PROGRESS_COUNTER_GRANULARITY","comment":"Indicates how often to show progress counter changes.","type_short":"int","constant_value":"129"},{"type_long":"java.lang.StringBuffer","javadoc":"Message indicating errors that occurred during a merge.","static":false,"name":"errorMsg","comment":"Message indicating errors that occurred during a merge.","type_short":"StringBuffer","constant_value":null},{"type_long":"java.lang.StringBuffer","javadoc":"Message indicating non-error information about a merge.","static":false,"name":"infoMsg","comment":"Message indicating non-error information about a merge.","type_short":"StringBuffer","constant_value":null},{"type_long":"ghidra.program.util.AddressTranslator","javadoc":"The address translator converts an address from the origin program to an equivalent address in the result program.","static":false,"name":"originToResultTranslator","comment":"The address translator converts an address from the origin program to an equivalent address in the result program.","type_short":"AddressTranslator","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"The first program that will be modified by the merge.","static":false,"name":"resultProgram","comment":"The first program that will be modified by the merge.","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Program","javadoc":"The second program (used as read only) for obtaining differences to merge.","static":false,"name":"originProgram","comment":"The second program (used as read only) for obtaining differences to merge.","type_short":"Program","constant_value":null},{"type_long":"ghidra.program.model.listing.Listing","javadoc":"The listing for the program being merged into.","static":false,"name":"resultListing","comment":"The listing for the program being merged into.","type_short":"Listing","constant_value":null},{"type_long":"ghidra.program.model.listing.Listing","javadoc":"The listing for the program being merged from.","static":false,"name":"originListing","comment":"The listing for the program being merged from.","type_short":"Listing","constant_value":null},{"type_long":"ghidra.program.model.listing.CodeUnit","javadoc":"The current code unit that is being modified when a user defined property is merged.","static":false,"name":"resultCu","comment":"The current code unit that is being modified when a user defined property is merged.","type_short":"CodeUnit","constant_value":null},{"type_long":"java.lang.String","javadoc":"The current property name being merged, when merging user defined properties.","static":false,"name":"propertyName","comment":"The current property name being merged, when merging user defined properties.","type_short":"String","constant_value":null},{"type_long":"ghidra.program.util.SymbolMerge","javadoc":"","static":false,"name":"symbolMerge","comment":"","type_short":"SymbolMerge","constant_value":null},{"type_long":"ghidra.program.util.FunctionMerge","javadoc":"","static":false,"name":"functionMerge","comment":"","type_short":"FunctionMerge","constant_value":null},{"type_long":"ghidra.util.datastruct.LongLongHashtable","javadoc":"","static":false,"name":"conflictSymbolIDMap","comment":"","type_short":"LongLongHashtable","constant_value":null},{"type_long":"java.util.HashMap<java.lang.String,ghidra.program.util.ProgramMerge.DupEquate>","javadoc":"","static":false,"name":"dupEquates","comment":"","type_short":"HashMap","constant_value":null}]}
