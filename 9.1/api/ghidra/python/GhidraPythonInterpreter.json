{"implements":[],"javadoc":"A python interpreter meant for Ghidra's use.  Each interpreter you get will have its own\n variable space so they should not interfere with each other.\n <p>\n There is no longer a way to reset an interpreter...it was too complicated to get right.\n Instead, you should {@link #cleanup()} your old interpreter and make a new one.","static":false,"extends":"org.python.util.InteractiveInterpreter","methods":[{"javadoc":"Gets a new GhidraPythonInterpreter instance.\n@return A new GhidraPythonInterpreter. Could be null if it failed to be created.","static":true,"name":"get","comment":"Gets a new GhidraPythonInterpreter instance.","params":[],"throws":[],"return":{"type_long":"ghidra.python.GhidraPythonInterpreter","comment":"A new GhidraPythonInterpreter. Could be null if it failed to be created.","type_short":"GhidraPythonInterpreter"}},{"javadoc":"Creates a new Ghidra python interpreter object.\n@param state The initial system state of the interpreter.","static":false,"name":"<init>","comment":"Creates a new Ghidra python interpreter object.","params":[{"type_long":"org.python.core.PySystemState","name":"state","comment":"The initial system state of the interpreter.","type_short":"PySystemState"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Initializes\/resets the python path to include all known Ghidra script paths.","static":false,"name":"initializePythonPath","comment":"Initializes\/resets the python path to include all known Ghidra script paths.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Pushes (executes) a line of Python to the interpreter.\n@param line the line of Python to push to the interpreter\n@param script a PythonScript from which we load state (or null)\n@return true if more input is needed before execution can occur\n@throws PyException if an unhandled exception occurred while executing the line of python\n@throws IllegalStateException if this interpreter has been cleaned up.","static":false,"name":"push","comment":"Pushes (executes) a line of Python to the interpreter.","params":[{"type_long":"java.lang.String","name":"line","comment":"the line of Python to push to the interpreter","type_short":"String"},{"type_long":"ghidra.python.PythonScript","name":"script","comment":"a PythonScript from which we load state (or null)","type_short":"PythonScript"}],"throws":[{"type_long":"org.python.core.PyException","comment":"if an unhandled exception occurred while executing the line of python","type_short":"PyException"},{"type_long":"java.lang.IllegalStateException","comment":"if this interpreter has been cleaned up.","type_short":"IllegalStateException"}],"return":{"type_long":"boolean","comment":"true if more input is needed before execution can occur","type_short":"boolean"}},{"javadoc":"Execute a python file using this interpreter.\n@param file The python file to execute.\n@param script A PythonScript from which we load state (or null).\n@throws IllegalStateException if this interpreter has been cleaned up.","static":false,"name":"execFile","comment":"Execute a python file using this interpreter.","params":[{"type_long":"generic.jar.ResourceFile","name":"file","comment":"The python file to execute.","type_short":"ResourceFile"},{"type_long":"ghidra.python.PythonScript","name":"script","comment":"A PythonScript from which we load state (or null).","type_short":"PythonScript"}],"throws":[{"type_long":"java.lang.IllegalStateException","comment":"if this interpreter has been cleaned up.","type_short":"IllegalStateException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"cleanup","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Prints the given string to the interpreter's error stream with a newline\n appended.\n@param str The string to print.","static":false,"name":"printErr","comment":"Prints the given string to the interpreter's error stream with a newline\n appended.","params":[{"type_long":"java.lang.String","name":"str","comment":"The string to print.","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Gets the interpreter's primary prompt.\n@return The interpreter's primary prompt.","static":false,"name":"getPrimaryPrompt","comment":"Gets the interpreter's primary prompt.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"The interpreter's primary prompt.","type_short":"String"}},{"javadoc":"Gets the interprester's secondary prompt.\n@return The interpreter's secondary prompt.","static":false,"name":"getSecondaryPrompt","comment":"Gets the interprester's secondary prompt.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"The interpreter's secondary prompt.","type_short":"String"}},{"javadoc":"Handle a KeyboardInterrupt.\n <p>\n This will attempt to interrupt the interpreter if it is running. There are\n two types of things this interrupt will work on:\n <p>\n 1: A batched series of python commands (such as a loop).  This works by setting\n our interrupt flag that is checked by our {@link InterruptTraceFunction} when\n various trace events happen.\n <p>\n 2: A sleeping or otherwise interruptible python command.  Since jython is all\n java under the hood, a sleep is really just a {@link Thread#sleep}, which we can\n kick with a {@link Thread#interrupt()}.\n <p>\n If another type of thing is taking a really long time, this interrupt will fail.\n@param pythonThread The Python Thread we need to interrupt.","static":false,"name":"interrupt","comment":"Handle a KeyboardInterrupt.\n \n This will attempt to interrupt the interpreter if it is running. There are\n two types of things this interrupt will work on:\n \n 1: A batched series of python commands (such as a loop).  This works by setting\n our interrupt flag that is checked by our InterruptTraceFunction when\n various trace events happen.\n \n 2: A sleeping or otherwise interruptible python command.  Since jython is all\n java under the hood, a sleep is really just a Thread#sleep, which we can\n kick with a Thread#interrupt().\n \n If another type of thing is taking a really long time, this interrupt will fail.","params":[{"type_long":"java.lang.Thread","name":"pythonThread","comment":"The Python Thread we need to interrupt.","type_short":"Thread"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Injects all of the accessible fields and methods found in the PythonScript class hierarchy into\n the given interpreter's Python address space.\n@param script The script whose class hierarchy is to be used for injection.","static":false,"name":"injectScriptHierarchy","comment":"Injects all of the accessible fields and methods found in the PythonScript class hierarchy into\n the given interpreter's Python address space.","params":[{"type_long":"ghidra.python.PythonScript","name":"script","comment":"The script whose class hierarchy is to be used for injection.","type_short":"PythonScript"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Safely sets a variable in the interpreter's namespace. This first checks to\n make sure that we are not overriding a builtin Python symbol.\n@param varName The name of variable.\n@param obj The value of the variable.\n@return True if the variable was set; false if it already existed and wasn't set.","static":false,"name":"setVariable","comment":"Safely sets a variable in the interpreter's namespace. This first checks to\n make sure that we are not overriding a builtin Python symbol.","params":[{"type_long":"java.lang.String","name":"varName","comment":"The name of variable.","type_short":"String"},{"type_long":"java.lang.Object","name":"obj","comment":"The value of the variable.","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"True if the variable was set; false if it already existed and wasn't set.","type_short":"boolean"}},{"javadoc":"Sets a bound (callback\/function pointer) method as a local variable in the interpreter.\n@param obj A Java object that contains the method to bind.\n@param method The method from the object to bind.\n@return True if the method was set; false if it already existed and wasn't set.","static":false,"name":"setMethod","comment":"Sets a bound (callback\/function pointer) method as a local variable in the interpreter.","params":[{"type_long":"java.lang.Object","name":"obj","comment":"A Java object that contains the method to bind.","type_short":"Object"},{"type_long":"java.lang.reflect.Method","name":"method","comment":"The method from the object to bind.","type_short":"Method"}],"throws":[],"return":{"type_long":"boolean","comment":"True if the method was set; false if it already existed and wasn't set.","type_short":"boolean"}},{"javadoc":"Returns the possible command completions for a command.\n@param cmd The command line.\n@param includeBuiltins True if we should include python built-ins; otherwise, false.\n@return A list of possible command completions.  Could be empty if there aren't any.\n@see PythonPlugin#getCompletions","static":false,"name":"getCommandCompletions","comment":"Returns the possible command completions for a command.","params":[{"type_long":"java.lang.String","name":"cmd","comment":"The command line.","type_short":"String"},{"type_long":"boolean","name":"includeBuiltins","comment":"True if we should include python built-ins; otherwise, false.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.plugin.core.console.CodeCompletion>","comment":"A list of possible command completions.  Could be empty if there aren't any.","type_short":"List"}},{"javadoc":"Returns method documentation for the current command.\n@param cmd the current command\n@return method documentation for the current command","static":false,"name":"getMethodCommandCompletions","comment":"Returns method documentation for the current command.","params":[{"type_long":"java.lang.String","name":"cmd","comment":"the current command","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.plugin.core.console.CodeCompletion>","comment":"method documentation for the current command","type_short":"List"}},{"javadoc":"Returns a Map of property->string_substitution pairs.\n@param cmd current command\n@param includeBuiltins True if we should include python built-ins; otherwise, false.\n@return A list of possible command completions.  Could be empty if there aren't any.","static":false,"name":"getPropertyCommandCompletions","comment":"Returns a Map of property-string_substitution pairs.","params":[{"type_long":"java.lang.String","name":"cmd","comment":"current command","type_short":"String"},{"type_long":"boolean","name":"includeBuiltins","comment":"True if we should include python built-ins; otherwise, false.","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.plugin.core.console.CodeCompletion>","comment":"A list of possible command completions.  Could be empty if there aren't any.","type_short":"List"}}],"name":"GhidraPythonInterpreter","comment":"A python interpreter meant for Ghidra's use.  Each interpreter you get will have its own\n variable space so they should not interfere with each other.\n \n There is no longer a way to reset an interpreter...it was too complicated to get right.\n Instead, you should #cleanup() your old interpreter and make a new one.","fields":[{"type_long":"boolean","javadoc":"","static":true,"name":"pythonInitialized","comment":"","type_short":"boolean","constant_value":null},{"type_long":"java.util.List<org.python.core.PyString>","javadoc":"","static":true,"name":"defaultPythonPath","comment":"","type_short":"List","constant_value":null},{"type_long":"org.python.core.TraceFunction","javadoc":"","static":false,"name":"interruptTraceFunction","comment":"","type_short":"TraceFunction","constant_value":null},{"type_long":"org.python.core.PyModule","javadoc":"","static":false,"name":"introspectModule","comment":"","type_short":"PyModule","constant_value":null},{"type_long":"org.python.core.PyModule","javadoc":"","static":false,"name":"builtinModule","comment":"","type_short":"PyModule","constant_value":null},{"type_long":"org.python.core.PyObject","javadoc":"","static":false,"name":"interrupt","comment":"","type_short":"PyObject","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"scriptMethodsInjected","comment":"","type_short":"boolean","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"cleanedUp","comment":"","type_short":"boolean","constant_value":null}]}
