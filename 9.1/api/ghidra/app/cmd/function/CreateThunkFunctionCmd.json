{"implements":[],"javadoc":"Command for creating a thunk function at an address.","static":false,"extends":"ghidra.framework.cmd.BackgroundCommand","methods":[{"javadoc":"Constructs a new command for creating a thunk function.\n@param entry entry point address for the function to be created.\n@param body set of addresses to associated with the function to be created.\n The addresses must not already be included in the body of any existing function.\n If null, and entry corresponds to an existing function, that function will be\n converted to a thunk, otherwise an error will result.\n@param referencedFunctionAddr the function address to which this thunk refers.  If no function\n exists at that specified referencedFunctionAddr one will be created per the following scheme:\n <pre><ul>\n <li>If referencedFunctionAddr is not contained within a memory block, an external function will\n be created (a check will be done to look for an previously defined external location)<\/li>\n <li>If referencedFunctionAddr corresponds to an instruction, a new function will be\n created at that address.<\/li>\n <\/ul><\/pre>","static":false,"name":"<init>","comment":"Constructs a new command for creating a thunk function.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"entry point address for the function to be created.","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"set of addresses to associated with the function to be created.\n The addresses must not already be included in the body of any existing function.\n If null, and entry corresponds to an existing function, that function will be\n converted to a thunk, otherwise an error will result.","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.address.Address","name":"referencedFunctionAddr","comment":"the function address to which this thunk refers.  If no function\n exists at that specified referencedFunctionAddr one will be created per the following scheme:\n \n If referencedFunctionAddr is not contained within a memory block, an external function will\n be created (a check will be done to look for an previously defined external location)\n If referencedFunctionAddr corresponds to an instruction, a new function will be\n created at that address.\n ","type_short":"Address"},{"type_long":"java.util.List<ghidra.program.model.address.Address>","name":"referringThunkAddresses","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new command for creating a thunk function.\n@param entry entry point address for the function to be created.\n@param body set of addresses to associated with the function to be created.\n The addresses must not already be included in the body of any existing function.\n If null, and entry corresponds to an existing function, that function will be\n converted to a thunk, otherwise an error will result.\n@param referencedFunctionAddr the function address to which this thunk refers.  If no function\n exists at that specified referencedFunctionAddr one will be created per the following scheme:\n <pre><ul>\n <li>If referencedFunctionAddr is not contained within a memory block, an external function will\n be created (a check will be done to look for an previously defined external location)<\/li>\n <li>If referencedFunctionAddr corresponds to an instruction, a new function will be\n created at that address.<\/li>\n <\/ul><\/pre>","static":false,"name":"<init>","comment":"Constructs a new command for creating a thunk function.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"entry point address for the function to be created.","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"set of addresses to associated with the function to be created.\n The addresses must not already be included in the body of any existing function.\n If null, and entry corresponds to an existing function, that function will be\n converted to a thunk, otherwise an error will result.","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.address.Address","name":"referencedFunctionAddr","comment":"the function address to which this thunk refers.  If no function\n exists at that specified referencedFunctionAddr one will be created per the following scheme:\n \n If referencedFunctionAddr is not contained within a memory block, an external function will\n be created (a check will be done to look for an previously defined external location)\n If referencedFunctionAddr corresponds to an instruction, a new function will be\n created at that address.\n ","type_short":"Address"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new command for creating a thunk function.\n@param entry entry point address for the function to be created.\n@param body set of addresses to associated with the function to be created.\n The addresses must not already be included in the body of any existing function.\n If null, and entry corresponds to an existing function, that function will be\n converted to a thunk, otherwise an error will result.\n@param referencedSymbol the symbol which identifies the intended function to which this thunk refers.\n If no function exists at that specified referencedSymbol location, one will be created per the following scheme:\n <pre><ul>\n <li>If referencedFunctionAddr is not contained within a memory block, an external function will\n be created (a check will be done to look for an previously defined external location)<\/li>\n <li>If referencedFunctionAddr corresponds to an instruction, a new function will be\n created at that address.<\/li>\n <li>If referencedSymbol corresponds to an external CODE symbol, it will be converted to an\n external FUNCTION<\/li>\n <\/ul><\/pre>","static":false,"name":"<init>","comment":"Constructs a new command for creating a thunk function.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"entry point address for the function to be created.","type_short":"Address"},{"type_long":"ghidra.program.model.address.AddressSetView","name":"body","comment":"set of addresses to associated with the function to be created.\n The addresses must not already be included in the body of any existing function.\n If null, and entry corresponds to an existing function, that function will be\n converted to a thunk, otherwise an error will result.","type_short":"AddressSetView"},{"type_long":"ghidra.program.model.symbol.Symbol","name":"referencedSymbol","comment":"the symbol which identifies the intended function to which this thunk refers.\n If no function exists at that specified referencedSymbol location, one will be created per the following scheme:\n \n If referencedFunctionAddr is not contained within a memory block, an external function will\n be created (a check will be done to look for an previously defined external location)\n If referencedFunctionAddr corresponds to an instruction, a new function will be\n created at that address.\n If referencedSymbol corresponds to an external CODE symbol, it will be converted to an\n external FUNCTION\n ","type_short":"Symbol"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new command for creating a thunk function that can compute the function this function is thunking to.\n@param entry entry point address for the function to be created.\n@param checkForSideEffects true to check for side-effects that indicate it is not a pure thunk.\n \n The body may be computed.  References to the thunked to function may be created.\n \n If no function exists at the location being thunked, it will be created based on the above rules.","static":false,"name":"<init>","comment":"Constructs a new command for creating a thunk function that can compute the function this function is thunking to.","params":[{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"entry point address for the function to be created.","type_short":"Address"},{"type_long":"boolean","name":"checkForSideEffects","comment":"true to check for side-effects that indicate it is not a pure thunk.\n \n The body may be computed.  References to the thunked to function may be created.\n \n If no function exists at the location being thunked, it will be created based on the above rules.","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"applyTo","comment":"","params":[{"type_long":"ghidra.framework.model.DomainObject","name":"obj","comment":"","type_short":"DomainObject"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"computeThunkBody","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"","static":false,"name":"getReferencedFunction","comment":"","params":[{"type_long":"boolean","name":"autoThunkOK","comment":"","type_short":"boolean"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"","type_short":"Function"}},{"javadoc":"","static":false,"name":"getExternalFunction","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"","type_short":"Function"}},{"javadoc":"resolve the flow destination by computing to a single value with a restriction to a single basic block.\n@return single flow address, null if single flow can't be resolved","static":false,"name":"resolveComputableFlow","comment":"resolve the flow destination by computing to a single value with a restriction to a single basic block.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"location","comment":"","type_short":"Address"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"single flow address, null if single flow can't be resolved","type_short":"boolean"}},{"javadoc":"@return function if create command was successful","static":false,"name":"getThunkFunction","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"function if create command was successful","type_short":"Function"}},{"javadoc":"@return the function referenced by the newly created thunk function\n is command was successful","static":false,"name":"getReferencedFunction","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Function","comment":"the function referenced by the newly created thunk function\n is command was successful","type_short":"Function"}},{"javadoc":"if the code starting at entry is a thunk, return the thunked addess if known.\n@param program code resides in\n@param entry start of the code\n@return the function address, Address.NO_ADDRESS if thunk but unknonw addr, null otherwise","static":true,"name":"getThunkedAddr","comment":"if the code starting at entry is a thunk, return the thunked addess if known.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"code resides in","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"start of the code","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"the function address, Address.NO_ADDRESS if thunk but unknonw addr, null otherwise","type_short":"Address"}},{"javadoc":"Get the address that this function would thunk if it is a valid thunk\n@param program\n@param entry location to check for a thunk\n@param checkForSideEffects true if there should be no extra registers affected\n@return address that the thunk thunks,Address.NO_ADDRESS if thunk but unknown addr, null otherwise","static":true,"name":"getThunkedAddr","comment":"Get the address that this function would thunk if it is a valid thunk","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"location to check for a thunk","type_short":"Address"},{"type_long":"boolean","name":"checkForSideEffects","comment":"true if there should be no extra registers affected","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"address that the thunk thunks,Address.NO_ADDRESS if thunk but unknown addr, null otherwise","type_short":"Address"}},{"javadoc":"","static":true,"name":"addSetRegisters","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"","type_short":"Address"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"setRegisters","comment":"","type_short":"HashSet"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Handle conversion of label within reserved EXTERNAL block to a real \n external function which can be thunked.  This may be necessary when a\n loaded symbol failed to identify itself as a function.  This will \n only handle single symbols contained within the global namespace.\n@param program\n@param entry function being created\n@return newly created external function address or null","static":true,"name":"getThunkedExternalFunctionAddress","comment":"Handle conversion of label within reserved EXTERNAL block to a real \n external function which can be thunked.  This may be necessary when a\n loaded symbol failed to identify itself as a function.  This will \n only handle single symbols contained within the global namespace.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"entry","comment":"function being created","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"newly created external function address or null","type_short":"Address"}},{"javadoc":"","static":true,"name":"isLocalBranch","comment":"","params":[{"type_long":"ghidra.program.model.listing.Listing","name":"listing","comment":"","type_short":"Listing"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.symbol.FlowType","name":"flowType","comment":"","type_short":"FlowType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"getFlowingAddrFromFinalState","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"","type_short":"Instruction"},{"type_long":"ghidra.program.model.symbol.FlowType","name":"flowType","comment":"","type_short":"FlowType"},{"type_long":"boolean","name":"checkForSideEffects","comment":"","type_short":"boolean"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"setRegisters","comment":"","type_short":"HashSet"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"usedRegisters","comment":"","type_short":"HashSet"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"try to get a simple flow address from a single instruction\n@param instr to check for simple flow to target\n@return targetAddr if was a simple flow, null otherwise","static":true,"name":"getSimpleFlow","comment":"try to get a simple flow address from a single instruction","params":[{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"to check for simple flow to target","type_short":"Instruction"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"targetAddr if was a simple flow, null otherwise","type_short":"Address"}},{"javadoc":"add in all registers used\/set in the pcodeop, checking for a register with an unknown input.\n@param program - program this pcode belongs to\n@param setAtStartRegisters - registers that were set at the start of the function\n@param setRegisters - registers that are currently set to a value\n@param usedRegisters - registers that have been used by any pcode op\n@param pcode - pcode operation.\n@param allow8bitNonUse - TRUE to allow setting of 8bit size registers without\n                          eventual use of the value.\n                          8-bit registers are normally flags. For 16-bit or\n                          8-bit processors, this should be FALSE\n@return true if all input registers had a valid input\n         false if input register found that was not initialized","static":true,"name":"addRegisterUsage","comment":"add in all registers used\/set in the pcodeop, checking for a register with an unknown input.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"- program this pcode belongs to","type_short":"Program"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"setAtStartRegisters","comment":"- registers that were set at the start of the function","type_short":"HashSet"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"setRegisters","comment":"- registers that are currently set to a value","type_short":"HashSet"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"usedRegisters","comment":"- registers that have been used by any pcode op","type_short":"HashSet"},{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"pcode","comment":"- pcode operation.","type_short":"PcodeOp"},{"type_long":"boolean","name":"allow8bitNonUse","comment":"- TRUE to allow setting of 8bit size registers without\n                          eventual use of the value.\n                          8-bit registers are normally flags. For 16-bit or\n                          8-bit processors, this should be FALSE","type_short":"boolean"}],"throws":[],"return":{"type_long":"boolean","comment":"true if all input registers had a valid input\n         false if input register found that was not initialized","type_short":"boolean"}},{"javadoc":"Check if the setRegisters contains the varnode or any of its parents.\n If a parent register has been set, then this varnode is set","static":true,"name":"containsRegister","comment":"Check if the setRegisters contains the varnode or any of its parents.\n If a parent register has been set, then this varnode is set","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"java.util.HashSet<ghidra.program.model.pcode.Varnode>","name":"setRegisters","comment":"","type_short":"HashSet"},{"type_long":"ghidra.program.model.pcode.Varnode","name":"regVarnode","comment":"","type_short":"Varnode"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":true,"name":"getFlowingAddress","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Instruction","name":"instr","comment":"","type_short":"Instruction"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"","type_short":"Address"}},{"javadoc":"Check if this is a Thunking function.\n@return true if this is a function thunking another.","static":true,"name":"isThunk","comment":"Check if this is a Thunking function.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"},{"type_long":"ghidra.program.model.listing.Function","name":"func","comment":"","type_short":"Function"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this is a function thunking another.","type_short":"boolean"}}],"name":"CreateThunkFunctionCmd","comment":"Command for creating a thunk function at an address.","fields":[{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"entry","comment":"","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.address.AddressSetView","javadoc":"","static":false,"name":"body","comment":"","type_short":"AddressSetView","constant_value":null},{"type_long":"ghidra.program.model.address.Address","javadoc":"","static":false,"name":"referencedFunctionAddr","comment":"","type_short":"Address","constant_value":null},{"type_long":"ghidra.program.model.symbol.Symbol","javadoc":"","static":false,"name":"referencedSymbol","comment":"","type_short":"Symbol","constant_value":null},{"type_long":"ghidra.program.model.listing.Function","javadoc":"","static":false,"name":"thunkFunction","comment":"","type_short":"Function","constant_value":null},{"type_long":"ghidra.program.model.listing.Function","javadoc":"","static":false,"name":"referencedFunction","comment":"","type_short":"Function","constant_value":null},{"type_long":"java.util.List<ghidra.program.model.address.Address>","javadoc":"","static":false,"name":"referringThunkAddresses","comment":"","type_short":"List","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"checkForSideEffects","comment":"","type_short":"boolean","constant_value":null},{"type_long":"int","javadoc":"","static":true,"name":"MAX_NUMBER_OF_THUNKING_INSTRUCTIONS","comment":"","type_short":"int","constant_value":"5"},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"DEFAULT_FUNCTION_COMMENT","comment":"","type_short":"String","constant_value":null}]}
