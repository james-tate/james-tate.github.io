{"implements":[],"javadoc":"Handles merging of function tags when they are added\/removed from \n functions. \n \n Most merging can be done automatically; the exception being when a\n tag has been added to a function by one user, but deleted from the\n program by another.\n \n Note that there are other tag related conflict cases, but they are \n handled by the {@link FunctionTagMerger}, which handles all aspects of\n creation\/deletion\/editing of tags independent of functions. \n \n THIS CLASS ONLY DEALS WITH FUNCTION-RELATED ADDS\/REMOVES.\n \n The specific cases handled by the class are described below:\n \n  - X and Y are tags\n  - ** indicates a conflict\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\t\n \t\t\t\t|\n User B\t\t|\n -------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\t**\t\t\tX\t\t\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\t**\t\t\n \t\t\t\t|\n Delete X\t\t|\t**\t\tY\t\t\t-\t\t\t-\t\t\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\t**\t\t\t-\t\t\t-","static":false,"extends":"ghidra.app.merge.listing.AbstractListingMerger","methods":[{"javadoc":"Constructor.\n@param listingMergeMgr the listing merge manager that owns this merger.","static":false,"name":"<init>","comment":"Constructor.","params":[{"type_long":"ghidra.app.merge.listing.ListingMergeManager","name":"listingMergeMgr","comment":"the listing merge manager that owns this merger.","type_short":"ListingMergeManager"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"PUBLIC METHODS","static":false,"name":"init","comment":"PUBLIC METHODS","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getConflictType","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getConflictCount","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"apply","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Stores the users' selection for how to handle a conflict.\n@param option user option, from {@link ListingMergeConstants}","static":false,"name":"setConflictResolution","comment":"Stores the users' selection for how to handle a conflict.","params":[{"type_long":"int","name":"option","comment":"user option, from ListingMergeConstants","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"autoMerge","comment":"","params":[{"type_long":"int","name":"progressMin","comment":"","type_short":"int"},{"type_long":"int","name":"progressMax","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.util.ProgramConflictException","comment":"","type_short":"ProgramConflictException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getConflicts","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSetView","comment":"","type_short":"AddressSetView"}},{"javadoc":"","static":false,"name":"hasConflict","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"mergeConflicts","comment":"","params":[{"type_long":"ghidra.app.merge.tool.ListingMergePanel","name":"listingPanel","comment":"","type_short":"ListingMergePanel"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"int","name":"chosenConflictOption","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"","type_short":"MemoryAccessException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Attempts to merge changes between the My and Latest versions of the program. Conflicts\n will be stored in the {@link #conflictMap} for later resolution.\n@param diffType from {@link ProgramDiffFilter}\n@param monitor task monitor\n@throws ProgramConflictException\n@throws CancelledException\n@throws IOException","static":false,"name":"autoMerge","comment":"Attempts to merge changes between the My and Latest versions of the program. Conflicts\n will be stored in the #conflictMap for later resolution.","params":[{"type_long":"int","name":"diffType","comment":"from ProgramDiffFilter","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.program.util.ProgramConflictException","comment":"","type_short":"ProgramConflictException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Determines if any deleted tags from one program were added to a function in\n the other. If so, updates the conflict list with the offending tag\/address.\n \n If there is no conflict for a particular address, the changes are automatically\n merged.\n@param changedAddresses list of addresses to inspect\n@param deletedTags all tags deleted in the 'other' program\n@param programAddedTo the program in which the adds reside\n@throws IOException","static":false,"name":"processChangedAddresses","comment":"Determines if any deleted tags from one program were added to a function in\n the other. If so, updates the conflict list with the offending tag\/address.\n \n If there is no conflict for a particular address, the changes are automatically\n merged.","params":[{"type_long":"ghidra.program.model.address.AddressSetView","name":"changedAddresses","comment":"list of addresses to inspect","type_short":"AddressSetView"},{"type_long":"java.util.Collection<? extends ghidra.program.model.listing.FunctionTag>","name":"deletedTags","comment":"all tags deleted in the 'other' program","type_short":"Collection"},{"type_long":"ghidra.program.model.listing.Program","name":"programAddedTo","comment":"the program in which the adds reside","type_short":"Program"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds the given tag\/address combo to the global conflict list.\n@param addr the conflicting address\n@param tag the conflicting tag","static":false,"name":"addToConflicts","comment":"Adds the given tag\/address combo to the global conflict list.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the conflicting address","type_short":"Address"},{"type_long":"ghidra.program.model.listing.FunctionTag","name":"tag","comment":"the conflicting tag","type_short":"FunctionTag"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns all tags that were added to the function at the given address.\n@param program the program where the function resides\n@param addr the function entry point\n@return ","static":false,"name":"getTagsAddedToFunction","comment":"Returns all tags that were added to the function at the given address.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program where the function resides","type_short":"Program"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the function entry point","type_short":"Address"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.program.model.listing.FunctionTag>","comment":"","type_short":"Collection"}},{"javadoc":"Compares the given program against Original to determine if any tags differ \n between the two. Any tags in Original that are NOT in the given program \n indicate deletions.\n@param program the program version\n@param monitor\n@return database IDs from the FunctionTagAdapter table that were deleted","static":false,"name":"getDeletedTags","comment":"Compares the given program against Original to determine if any tags differ \n between the two. Any tags in Original that are NOT in the given program \n indicate deletions.","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program version","type_short":"Program"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"java.util.Collection<? extends ghidra.program.model.listing.FunctionTag>","comment":"database IDs from the FunctionTagAdapter table that were deleted","type_short":"Collection"}},{"javadoc":"Sets up the conflict panel for SINGLE conflict. This will be a standard listing merge \n panel showing all four programs (Latest, My, Original, Result). Choices for \n resolving the conflict will appear at the bottom.\n@param listingPanel the main panel\n@param addr\n@param tagID\n@param changeListener","static":false,"name":"setupConflictsPanel","comment":"Sets up the conflict panel for SINGLE conflict. This will be a standard listing merge \n panel showing all four programs (Latest, My, Original, Result). Choices for \n resolving the conflict will appear at the bottom.","params":[{"type_long":"ghidra.app.merge.tool.ListingMergePanel","name":"listingPanel","comment":"the main panel","type_short":"ListingMergePanel"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"","type_short":"Address"},{"type_long":"java.lang.Long","name":"tagID","comment":"","type_short":"Long"},{"type_long":"javax.swing.event.ChangeListener","name":"changeListener","comment":"","type_short":"ChangeListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a string containing the tag and the program version it's associated\n with. This is used when displaying the conflict panel.\n@param version\n@param tags\n@return ","static":false,"name":"getFunctionTagInfo","comment":"Returns a string containing the tag and the program version it's associated\n with. This is used when displaying the conflict panel.","params":[{"type_long":"int","name":"version","comment":"","type_short":"int"},{"type_long":"java.lang.String","name":"tag","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String[]","comment":"","type_short":"java.lang.String[]"}},{"javadoc":"Merges the tag currently being resolved in the conflict panel according to the\n given conflict option. This is invoked when the user has made a merge \n selection (keep Original, My, or Latest) in the conflict resolution panel.\n@param addr the location of the conflict\n@param chosenConflictOption KEEP_ORIGINAL, KEEP_LATEST, KEEP_MY\n@param monitor\n@throws CancelledException","static":false,"name":"mergeConflictingTag","comment":"Merges the tag currently being resolved in the conflict panel according to the\n given conflict option. This is invoked when the user has made a merge \n selection (keep Original, My, or Latest) in the conflict resolution panel.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the location of the conflict","type_short":"Address"},{"type_long":"int","name":"chosenConflictOption","comment":"KEEP_ORIGINAL, KEEP_LATEST, KEEP_MY","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Displays the conflict resolution panel for a single tag ID at the specified\n address.\n@param listingPanel the listing panel to display\n@param addr the address where the merge is occurring\n@param tagID the tag id being merged\n@param monitor the task monitor","static":false,"name":"showMergePanel","comment":"Displays the conflict resolution panel for a single tag ID at the specified\n address.","params":[{"type_long":"ghidra.app.merge.tool.ListingMergePanel","name":"listingPanel","comment":"the listing panel to display","type_short":"ListingMergePanel"},{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address where the merge is occurring","type_short":"Address"},{"type_long":"java.lang.Long","name":"tagID","comment":"the tag id being merged","type_short":"Long"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the {@link FunctionTag} for the tag ID given.\n@param id the tag ID\n@param program the program version\n@return null if tag not found for the given id\n@throws IOException","static":false,"name":"getTag","comment":"Returns the FunctionTag for the tag ID given.","params":[{"type_long":"java.lang.Long","name":"id","comment":"the tag ID","type_short":"Long"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"the program version","type_short":"Program"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.program.model.listing.FunctionTag","comment":"null if tag not found for the given id","type_short":"FunctionTag"}}],"name":"FunctionTagListingMerger","comment":"Handles merging of function tags when they are added\/removed from \n functions. \n \n Most merging can be done automatically; the exception being when a\n tag has been added to a function by one user, but deleted from the\n program by another.\n \n Note that there are other tag related conflict cases, but they are \n handled by the FunctionTagMerger, which handles all aspects of\n creation\/deletion\/editing of tags independent of functions. \n \n THIS CLASS ONLY DEALS WITH FUNCTION-RELATED ADDS\/REMOVES.\n \n The specific cases handled by the class are described below:\n \n  - X and Y are tags\n  - ** indicates a conflict\n  \n \t\tUser A\t|\tAdd X\tAdd Y\tDelete X\tDelete Y\t\n \t\t\t\t|\n User B\t\t|\n -------------------------------------------------------\n Add X\t\t|\tX\t\tX,Y\t\t\t**\t\t\tX\t\t\n \t\t\t\t|\n Add Y\t\t|\tX,Y\t\tY\t\t\tY\t\t\t**\t\t\n \t\t\t\t|\n Delete X\t\t|\t**\t\tY\t\t\t-\t\t\t-\t\t\t\t\n \t\t\t\t|\n Delete Y\t\t|\tX\t\t**\t\t\t-\t\t\t-","fields":[{"type_long":"java.lang.String[]","javadoc":"","static":true,"name":"FUNCTION_TAG_LISTING_PHASE","comment":"","type_short":"java.lang.String[]","constant_value":null},{"type_long":"ghidra.app.merge.listing.VerticalChoicesPanel","javadoc":"","static":false,"name":"conflictPanel","comment":"","type_short":"VerticalChoicesPanel","constant_value":null},{"type_long":"java.util.Map<ghidra.program.model.address.Address,java.util.List<java.lang.Long>>","javadoc":"","static":false,"name":"conflictMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.lang.Long","javadoc":"","static":false,"name":"currentlyMergingTagID","comment":"","type_short":"Long","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"tagChoice","comment":"","type_short":"int","constant_value":null}]}
