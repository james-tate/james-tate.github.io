{"implements":["ghidra.app.plugin.assembler.AssemblerBuilder"],"javadoc":"An {@link AssemblerBuilder} capable of supporting almost any {@link SleighLanguage}\n \n To build an assembler, please use a static method of the {@link Assemblers} class.\n \n SLEIGH-based assembly is a bit of an experimental feature at this time. Nevertheless, it seems to\n have come along quite nicely. It's not quite as fast as disassembly, since after all, that's what\n SLEIGH was designed to do.\n \n Overall, the method is fairly simple, though its implementation is a bit more complex. First, we\n gather every pair of pattern and constructor by traversing the decision tree used by disassembly.\n We then use the \"print pieces\" to construct a context-free grammar. Each production is associated\n with the one-or-more constructors with the same sequence of print pieces. We then build a LALR(1)\n parser for the generated grammar. This now constitutes a generic parser for the given language.\n Note that this step takes some time, and may be better suited as a build-time step. Because\n SLEIGH specifications are not generally concerned with eliminating ambiguity of printed\n instructions (rather, it only does so for instruction bytes), we must consider that the grammar\n could be ambiguous. To handle this, the action\/goto table is permitted multiple entries per cell,\n and we allow backtracking. There are also cases where tokens are not actually separated by\n spaces. For example, in the {@code ia.sinc} file, there is JMP ... and J^cc, meaning, the lexer\n must consider J as a token as well as JMP, introducing another source of possible backtracking.\n Despite that, parsing is completed fairly quickly.\n \n To assemble, we first parse the textual instruction, yielding zero or more parse trees. No parse\n trees implies an error. For each parse tree, we attempt to resolve the instruction bytes,\n starting at the leaves and working upwards while tracking and solving context changes. The\n context changes must be considered in reverse. We <em>read<\/em> the context register of the\n children (a disassembler would write). We then assume there is at most one variable in the\n expression, solve for it, and <em>write<\/em> the solution to the appropriate field (a\n disassembler would read). If no solution exists, a semantic error is logged. Since it's possible\n a production in the parse tree is associated with multiple constructors, different combinations\n of constructors are explored as we move upward in the tree. If all possible combinations yield\n semantic errors, then the overall result is an error.\n \n Some productions are \"purely recursive,\" e.g., {@code :^instruction} lines in the SLEIGH. These\n are ignored during parser construction. Let such a production be given as I => I. When resolving\n the parse tree to bytes, and we encounter a production with I on the left hand side, we then\n consider the possible application of the production I => I and its consequential constructors.\n Ideally, we could repeat this indefinitely, stopping when all further applications result in\n semantic errors; however, there is no guarantee in the SLEIGH specification that such an\n algorithm will actually halt, so a maximum number (default of 1) of applications are attempted.\n \n After all the context changes and operands are resolved, we apply the constructor patterns and\n proceed up the tree. Thus, each branch yields zero or more \"resolved constructors,\" which each\n specify two masked blocks of data: one for the instruction, and one for the context. These are\n passed up to the parent production, which, having obtained results from all its children,\n attempts to apply the corresponding constructors.\n \n Once we've resolved the root node, any resolved constructors returned are taken as successfully\n assembled instruction bytes. If applicable, the corresponding context registers are compared to\n the context at the target address in the program and filtered for compatibility.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct an assembler builder for the given SLEIGH language\n@param lang the language","static":false,"name":"<init>","comment":"Construct an assembler builder for the given SLEIGH language","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","name":"lang","comment":"the language","type_short":"SleighLanguage"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Do the actual work to construct an assembler from a SLEIGH language\n@throws SleighException if there's an issue accessing the language","static":false,"name":"generateAssembler","comment":"Do the actual work to construct an assembler from a SLEIGH language","params":[],"throws":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighException","comment":"if there's an issue accessing the language","type_short":"SleighException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getLanguageID","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.lang.LanguageID","comment":"","type_short":"LanguageID"}},{"javadoc":"","static":false,"name":"getLanguage","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","comment":"","type_short":"SleighLanguage"}},{"javadoc":"","static":false,"name":"getAssembler","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.AssemblySelector","name":"selector","comment":"","type_short":"AssemblySelector"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.SleighAssembler","comment":"","type_short":"SleighAssembler"}},{"javadoc":"","static":false,"name":"getAssembler","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.AssemblySelector","name":"selector","comment":"","type_short":"AssemblySelector"},{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.SleighAssembler","comment":"","type_short":"SleighAssembler"}},{"javadoc":"Invert a varnode list to a map suitable for use with {@link AssemblyStringMapTerminal}\n@param vnlist the varnode list symbol\n@return the inverted string map","static":false,"name":"invVarnodeList","comment":"Invert a varnode list to a map suitable for use with AssemblyStringMapTerminal","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.VarnodeListSymbol","name":"vnlist","comment":"the varnode list symbol","type_short":"VarnodeListSymbol"}],"throws":[],"return":{"type_long":"org.apache.commons.collections4.MultiValuedMap<java.lang.String,java.lang.Integer>","comment":"the inverted string map","type_short":"MultiValuedMap"}},{"javadoc":"Invert a value map to a map suitable for use with {@link AssemblyNumericMapTerminal}\n@param vm the value map symbol\n@return the inverted numeric map","static":false,"name":"invValueMap","comment":"Invert a value map to a map suitable for use with AssemblyNumericMapTerminal","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.ValueMapSymbol","name":"vm","comment":"the value map symbol","type_short":"ValueMapSymbol"}],"throws":[],"return":{"type_long":"java.util.Map<java.lang.Long,java.lang.Integer>","comment":"the inverted numeric map","type_short":"Map"}},{"javadoc":"Invert a name table to a map suitable for use with {@link AssemblyStringMapTerminal}\n@param ns the name symbol\n@return the inverted string map","static":false,"name":"invNameSymbol","comment":"Invert a name table to a map suitable for use with AssemblyStringMapTerminal","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.NameSymbol","name":"ns","comment":"the name symbol","type_short":"NameSymbol"}],"throws":[],"return":{"type_long":"org.apache.commons.collections4.MultiValuedMap<java.lang.String,java.lang.Integer>","comment":"the inverted string map","type_short":"MultiValuedMap"}},{"javadoc":"Convert the given operand symbol to an {@link AssemblySymbol}\n \n For subtables, this results in a non-terminal, for all others, the result in a terminal.\n@param cons the constructor to which the operand belongs\n@param opsym the operand symbol to convert\n@return the converted assembly grammar symbol","static":false,"name":"getSymbolFor","comment":"Convert the given operand symbol to an AssemblySymbol\n \n For subtables, this results in a non-terminal, for all others, the result in a terminal.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.Constructor","name":"cons","comment":"the constructor to which the operand belongs","type_short":"Constructor"},{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.OperandSymbol","name":"opsym","comment":"the operand symbol to convert","type_short":"OperandSymbol"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol","comment":"the converted assembly grammar symbol","type_short":"AssemblySymbol"}},{"javadoc":"Obtain the size in bits of a textual operand.\n \n This is a little odd, since the variables in pattern expressions do not have an explicit\n size. However, the value exported by a constructor's pCode may have an explicit size given\n (in bytes). Thus, there is a special case, where a constructor prints just one operand and\n exports that same operand with an explicit size. In that case, the size of the operand is\n printed according to that exported size.\n \n For disassembly, this information is used simply to truncate the bits before they are\n displayed. For assembly, we must do two things: 1) Ensure that the provided value fits in the\n given size, and 2) Mask the goal when solving the pattern expression for the operand.\n@param cons the constructor from which the production is being derived\n@param opsym the operand symbol corresponding to the grammatical symbol, whose size we wish\n            to determine.\n@return the size of the operand in bits","static":false,"name":"getBitSize","comment":"Obtain the size in bits of a textual operand.\n \n This is a little odd, since the variables in pattern expressions do not have an explicit\n size. However, the value exported by a constructor's pCode may have an explicit size given\n (in bytes). Thus, there is a special case, where a constructor prints just one operand and\n exports that same operand with an explicit size. In that case, the size of the operand is\n printed according to that exported size.\n \n For disassembly, this information is used simply to truncate the bits before they are\n displayed. For assembly, we must do two things: 1) Ensure that the provided value fits in the\n given size, and 2) Mask the goal when solving the pattern expression for the operand.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.Constructor","name":"cons","comment":"the constructor from which the production is being derived","type_short":"Constructor"},{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.OperandSymbol","name":"opsym","comment":"the operand symbol corresponding to the grammatical symbol, whose size we wish\n            to determine.","type_short":"OperandSymbol"}],"throws":[],"return":{"type_long":"int","comment":"the size of the operand in bits","type_short":"int"}},{"javadoc":"Build a portion of the grammar representing a table of constructors\n@param subtable the table\n@return the partial grammar","static":false,"name":"buildSubGrammar","comment":"Build a portion of the grammar representing a table of constructors","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.symbol.SubtableSymbol","name":"subtable","comment":"the table","type_short":"SubtableSymbol"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","comment":"the partial grammar","type_short":"AssemblyGrammar"}},{"javadoc":"Build the full grammar for the language","static":false,"name":"buildGrammar","comment":"Build the full grammar for the language","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build the default context for the language","static":false,"name":"buildContext","comment":"Build the default context for the language","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build the context transition graph for the language","static":false,"name":"buildContextGraph","comment":"Build the context transition graph for the language","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build the parser for the language","static":false,"name":"buildParser","comment":"Build the parser for the language","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the built grammar for the language\n@return the grammar","static":false,"name":"getGrammar","comment":"Get the built grammar for the language","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","comment":"the grammar","type_short":"AssemblyGrammar"}},{"javadoc":"Get the built parser for the language\n@return the parser","static":false,"name":"getParser","comment":"Get the built parser for the language","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParser","comment":"the parser","type_short":"AssemblyParser"}}],"name":"SleighAssemblerBuilder","comment":"An AssemblerBuilder capable of supporting almost any SleighLanguage\n \n To build an assembler, please use a static method of the Assemblers class.\n \n SLEIGH-based assembly is a bit of an experimental feature at this time. Nevertheless, it seems to\n have come along quite nicely. It's not quite as fast as disassembly, since after all, that's what\n SLEIGH was designed to do.\n \n Overall, the method is fairly simple, though its implementation is a bit more complex. First, we\n gather every pair of pattern and constructor by traversing the decision tree used by disassembly.\n We then use the \"print pieces\" to construct a context-free grammar. Each production is associated\n with the one-or-more constructors with the same sequence of print pieces. We then build a LALR(1)\n parser for the generated grammar. This now constitutes a generic parser for the given language.\n Note that this step takes some time, and may be better suited as a build-time step. Because\n SLEIGH specifications are not generally concerned with eliminating ambiguity of printed\n instructions (rather, it only does so for instruction bytes), we must consider that the grammar\n could be ambiguous. To handle this, the action\/goto table is permitted multiple entries per cell,\n and we allow backtracking. There are also cases where tokens are not actually separated by\n spaces. For example, in the  file, there is JMP ... and J^cc, meaning, the lexer\n must consider J as a token as well as JMP, introducing another source of possible backtracking.\n Despite that, parsing is completed fairly quickly.\n \n To assemble, we first parse the textual instruction, yielding zero or more parse trees. No parse\n trees implies an error. For each parse tree, we attempt to resolve the instruction bytes,\n starting at the leaves and working upwards while tracking and solving context changes. The\n context changes must be considered in reverse. We read the context register of the\n children (a disassembler would write). We then assume there is at most one variable in the\n expression, solve for it, and write the solution to the appropriate field (a\n disassembler would read). If no solution exists, a semantic error is logged. Since it's possible\n a production in the parse tree is associated with multiple constructors, different combinations\n of constructors are explored as we move upward in the tree. If all possible combinations yield\n semantic errors, then the overall result is an error.\n \n Some productions are \"purely recursive,\" e.g.,  lines in the SLEIGH. These\n are ignored during parser construction. Let such a production be given as I = I. When resolving\n the parse tree to bytes, and we encounter a production with I on the left hand side, we then\n consider the possible application of the production I = I and its consequential constructors.\n Ideally, we could repeat this indefinitely, stopping when all further applications result in\n semantic errors; however, there is no guarantee in the SLEIGH specification that such an\n algorithm will actually halt, so a maximum number (default of 1) of applications are attempted.\n \n After all the context changes and operands are resolved, we apply the constructor patterns and\n proceed up the tree. Thus, each branch yields zero or more \"resolved constructors,\" which each\n specify two masked blocks of data: one for the instruction, and one for the context. These are\n passed up to the parent production, which, having obtained results from all its children,\n attempts to apply the corresponding constructors.\n \n Once we've resolved the root node, any resolved constructors returned are taken as successfully\n assembled instruction bytes. If applicable, the corresponding context registers are compared to\n the context at the target address in the program and filtered for compatibility.","fields":[{"type_long":"ghidra.app.plugin.assembler.sleigh.util.DbgTimer","javadoc":"","static":true,"name":"dbg","comment":"","type_short":"DbgTimer","constant_value":null},{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","javadoc":"","static":false,"name":"lang","comment":"","type_short":"SleighLanguage","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","javadoc":"","static":false,"name":"grammar","comment":"","type_short":"AssemblyGrammar","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyDefaultContext","javadoc":"","static":false,"name":"defaultContext","comment":"","type_short":"AssemblyDefaultContext","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph","javadoc":"","static":false,"name":"ctxGraph","comment":"","type_short":"AssemblyContextGraph","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParser","javadoc":"","static":false,"name":"parser","comment":"","type_short":"AssemblyParser","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"generated","comment":"","type_short":"boolean","constant_value":null},{"type_long":"java.util.Map<java.lang.String,ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol>","javadoc":"","static":false,"name":"builtSymbols","comment":"","type_short":"Map","constant_value":null}]}
