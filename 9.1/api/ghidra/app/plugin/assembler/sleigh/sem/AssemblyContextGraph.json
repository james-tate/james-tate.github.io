{"implements":["ghidra.graph.GImplicitDirectedGraph"],"javadoc":"A graph of possible context changes via the application of various constructors\n \n This is used primarily to find optimal paths for the application of recursive rules, i.e., those\n of the form I => I. These cannot be resolved without some form of semantic analysis. The most\n notable disadvantage to all of this is that you no longer get all of the possible assemblies,\n but only those with the fewest rule applications.\n \n Conceivably, this may also be used to prune some possibilities during semantic resolution of a\n parse tree. Even better, it may be possible to derive a grammar which accounts for the context\n changes already; however, it's unclear how many rules this will generate, and consequently, how\n much larger its LALR(1) parser would become.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Build the context change graph for a given language and grammar\n \n The grammar must have been constructed from the given language. The language is used just to\n obtain the most common default context.\n \n At the moment, this graph only expands the recursive rules at the root constructor table,\n i.e., \"instruction\". Thus, the assembler will not be able to process any language that has\n <i>purely<\/i>-recursive rules at subconstructors.\n@param lang the language\n@param grammar the grammar derived from the given language","static":false,"name":"<init>","comment":"Build the context change graph for a given language and grammar\n \n The grammar must have been constructed from the given language. The language is used just to\n obtain the most common default context.\n \n At the moment, this graph only expands the recursive rules at the root constructor table,\n i.e., \"instruction\". Thus, the assembler will not be able to process any language that has\n purely-recursive rules at subconstructors.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","name":"lang","comment":"the language","type_short":"SleighLanguage"},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","name":"grammar","comment":"the grammar derived from the given language","type_short":"AssemblyGrammar"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Compute the optimal, i.e., fewest, sequences of applications to resolve a given context to\n the language's default context.\n@param src presumably, the language's default context\n@param srcTable the name of the SLEIGH constructor table, presumably \"instruction\"\n@param dst the context block being resolved\n@param dstTable the name of the SLEIGH constructor table being resolved\n@return a collection of sequences of constructor applications from {@code src} to\n         {@code dst}\n@note For assembly, the sequences will need to be applied right-to-left.","static":false,"name":"computeOptimalApplications","comment":"Compute the optimal, i.e., fewest, sequences of applications to resolve a given context to\n the language's default context.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"src","comment":"presumably, the language's default context","type_short":"AssemblyPatternBlock"},{"type_long":"java.lang.String","name":"srcTable","comment":"the name of the SLEIGH constructor table, presumably \"instruction\"","type_short":"String"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"dst","comment":"the context block being resolved","type_short":"AssemblyPatternBlock"},{"type_long":"java.lang.String","name":"dstTable","comment":"the name of the SLEIGH constructor table being resolved","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.Collection<java.util.Deque<ghidra.app.plugin.assembler.sleigh.sem.AssemblyConstructorSemantic>>","comment":"a collection of sequences of constructor applications from  to\n         ","type_short":"Collection"}},{"javadoc":"Gather all the semantics that can be used as state transitions\n \n Currently, only semantics from {@code :^instruction} constructors are taken.","static":false,"name":"gatherSemantics","comment":"Gather all the semantics that can be used as state transitions\n \n Currently, only semantics from  constructors are taken.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"computeOutEdges","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex","name":"from","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>","comment":"","type_short":"Set"}},{"javadoc":"This operation is not supported.\n \n I could implement this using the cached edges, but that may not be semantically, what a path\n computation algorithm actually requires. Instead, I will assume the algorithm only explores\n the graph in the same direction as its edges. If not, I will hear about it quickly.","static":false,"name":"getInEdges","comment":"This operation is not supported.\n \n I could implement this using the cached edges, but that may not be semantically, what a path\n computation algorithm actually requires. Instead, I will assume the algorithm only explores\n the graph in the same direction as its edges. If not, I will hear about it quickly.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>","comment":"","type_short":"Collection"}},{"javadoc":"","static":false,"name":"getOutEdges","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex","name":"v","comment":"","type_short":"Vertex"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>","comment":"","type_short":"Collection"}},{"javadoc":"Returns a copy of the graph explored so far","static":false,"name":"copy","comment":"Returns a copy of the graph explored so far","params":[],"throws":[],"return":{"type_long":"ghidra.graph.GDirectedGraph<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex,ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>","comment":"","type_short":"GDirectedGraph"}}],"name":"AssemblyContextGraph","comment":"A graph of possible context changes via the application of various constructors\n \n This is used primarily to find optimal paths for the application of recursive rules, i.e., those\n of the form I = I. These cannot be resolved without some form of semantic analysis. The most\n notable disadvantage to all of this is that you no longer get all of the possible assemblies,\n but only those with the fewest rule applications.\n \n Conceivably, this may also be used to prune some possibilities during semantic resolution of a\n parse tree. Even better, it may be possible to derive a grammar which accounts for the context\n changes already; however, it's unclear how many rules this will generate, and consequently, how\n much larger its LALR(1) parser would become.","fields":[{"type_long":"java.util.Map<java.lang.String,java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyConstructorSemantic>>","javadoc":"","static":false,"name":"semantics","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","javadoc":"","static":false,"name":"grammar","comment":"","type_short":"AssemblyGrammar","constant_value":null},{"type_long":"ghidra.app.plugin.processors.sleigh.SleighLanguage","javadoc":"","static":false,"name":"lang","comment":"","type_short":"SleighLanguage","constant_value":null},{"type_long":"ghidra.graph.algo.DijkstraShortestPathsAlgorithm<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex,ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>","javadoc":"","static":false,"name":"dijkstra","comment":"","type_short":"DijkstraShortestPathsAlgorithm","constant_value":null},{"type_long":"java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex>","javadoc":"","static":false,"name":"cachedVertices","comment":"","type_short":"Set","constant_value":null},{"type_long":"java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>","javadoc":"","static":false,"name":"cachedEdges","comment":"","type_short":"Set","constant_value":null},{"type_long":"java.util.Map<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Vertex,java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyContextGraph.Edge>>","javadoc":"","static":false,"name":"cachedOutEdges","comment":"","type_short":"Map","constant_value":null}]}
