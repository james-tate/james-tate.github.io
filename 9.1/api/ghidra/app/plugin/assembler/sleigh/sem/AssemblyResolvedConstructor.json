{"implements":[],"javadoc":"A {@link AssemblyResolution} indicating successful application of a constructor\n \n This is almost analogous to {@link DisjointPattern}, in that is joins an instruction\n {@link AssemblyPatternBlock} with a corresponding context {@link AssemblyPatternBlock}. However,\n this object is mutable, and it collects backfill records, as well as forbidden patterns.\n \n When the applied constructor is from the \"instruction\" subtable, this represents a fully-\n constructed instruction with required context. All backfill records ought to be resolved and\n applied before the final result is given to the user, i.e., passed into the\n {@link AssemblySelector}. If at any time during the resolution or backfill process, the result\n becomes confined to one of the forbidden patterns, it must be dropped, since the encoding will\n actually invoke a more specific SLEIGH constructor.","static":false,"extends":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","methods":[{"javadoc":"","static":false,"name":"computeHash","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"obj","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"@see AssemblyResolution#resolved(AssemblyPatternBlock, AssemblyPatternBlock, String, List)","static":false,"name":"<init>","comment":"","params":[{"type_long":"java.lang.String","name":"description","comment":"","type_short":"String"},{"type_long":"com.google.common.collect.ImmutableList<? extends ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution>","name":"children","comment":"","type_short":"ImmutableList"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"ins","comment":"","type_short":"AssemblyPatternBlock"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"ctx","comment":"","type_short":"AssemblyPatternBlock"},{"type_long":"com.google.common.collect.ImmutableSet<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedBackfill>","name":"backfills","comment":"","type_short":"ImmutableSet"},{"type_long":"com.google.common.collect.ImmutableSet<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","name":"forbids","comment":"","type_short":"ImmutableSet"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Build a new successful SLEIGH constructor resolution from a string representation\n \n This was used primarily in testing, to specify expected results.\n@param str the string representation: \"{@code ins:[pattern],ctx:[pattern]}\"\n@see StringUtilities#convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int, String)\n@param description a description of the resolution\n@param children any children involved in the resolution\n@return the decoded resolution","static":true,"name":"fromString","comment":"Build a new successful SLEIGH constructor resolution from a string representation\n \n This was used primarily in testing, to specify expected results.","params":[{"type_long":"java.lang.String","name":"str","comment":"the string representation: \"\"","type_short":"String"},{"type_long":"java.lang.String","name":"description","comment":"a description of the resolution","type_short":"String"},{"type_long":"com.google.common.collect.ImmutableList<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution>","name":"children","comment":"any children involved in the resolution","type_short":"ImmutableList"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the decoded resolution","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Shift the resolved instruction pattern to the right\n \n This also shifts any backfill and forbidden pattern records.\n@param amt the number of bytes to shift.\n@return the result","static":false,"name":"shift","comment":"Shift the resolved instruction pattern to the right\n \n This also shifts any backfill and forbidden pattern records.","params":[{"type_long":"int","name":"amt","comment":"the number of bytes to shift.","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Truncate (unshift) the resolved instruction pattern from the left\n@note This drops all backfill and forbidden pattern records, since this method is typically\n       used to read token fields rather than passed around for resolution.\n@param amt the number of bytes to remove from the left\n@return the result","static":false,"name":"truncate","comment":"Truncate (unshift) the resolved instruction pattern from the left","params":[{"type_long":"int","name":"amt","comment":"the number of bytes to remove from the left","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Check if the current encoding is forbidden by one of the attached patterns\n \n The pattern become forbidden if this encoding's known bits are an overset of any forbidden\n pattern's known bits.\n@return false if the pattern is forbidden (and thus in error), true if permitted","static":false,"name":"checkNotForbidden","comment":"Check if the current encoding is forbidden by one of the attached patterns\n \n The pattern become forbidden if this encoding's known bits are an overset of any forbidden\n pattern's known bits.","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","comment":"false if the pattern is forbidden (and thus in error), true if permitted","type_short":"AssemblyResolution"}},{"javadoc":"Check if this and another resolution have equal encodings\n \n This is like {@link #equals(Object)}, but it ignores backfills records and forbidden\n patterns.\n@param that the other resolution\n@return true if both have equal encodings","static":false,"name":"bitsEqual","comment":"Check if this and another resolution have equal encodings\n \n This is like #equals(Object), but it ignores backfills records and forbidden\n patterns.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"that","comment":"the other resolution","type_short":"AssemblyResolvedConstructor"}],"throws":[],"return":{"type_long":"boolean","comment":"true if both have equal encodings","type_short":"boolean"}},{"javadoc":"Combine the encodings and backfills of the given resolution into this one\n \n This combines corresponding pattern blocks (assuming they agree), collects backfill\n records, and collects forbidden patterns.\n@param that the other resolution\n@return the result if successful, or null","static":false,"name":"combine","comment":"Combine the encodings and backfills of the given resolution into this one\n \n This combines corresponding pattern blocks (assuming they agree), collects backfill\n records, and collects forbidden patterns.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"that","comment":"the other resolution","type_short":"AssemblyResolvedConstructor"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result if successful, or null","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Combine a backfill result\n@param that the result from backfilling\n@param bf the resolved backfilled record\n@return the result if successful, or null\n \n When a backfill is successful, the result should be combined with the owning resolution. In\n addition, for bookkeeping's sake, the resolved record should be removed from the list of\n backfills.","static":false,"name":"combineLessBackfill","comment":"Combine a backfill result","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"that","comment":"the result from backfilling","type_short":"AssemblyResolvedConstructor"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedBackfill","name":"bf","comment":"the resolved backfilled record","type_short":"AssemblyResolvedBackfill"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result if successful, or null\n \n When a backfill is successful, the result should be combined with the owning resolution. In\n addition, for bookkeeping's sake, the resolved record should be removed from the list of\n backfills.","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Combine the given backfill record into this resolution\n@param bf the backfill record\n@return the result","static":false,"name":"combine","comment":"Combine the given backfill record into this resolution","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedBackfill","name":"bf","comment":"the backfill record","type_short":"AssemblyResolvedBackfill"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Create a new resolution from this one with the given forbidden patterns recorded\n@param more the additional forbidden patterns to record\n@return the new resolution","static":false,"name":"withForbids","comment":"Create a new resolution from this one with the given forbidden patterns recorded","params":[{"type_long":"java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","name":"more","comment":"the additional forbidden patterns to record","type_short":"Set"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the new resolution","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Create a copy of this resolution with a new description\n@param desc the new description\n@return the copy","static":false,"name":"withDescription","comment":"Create a copy of this resolution with a new description","params":[{"type_long":"java.lang.String","name":"desc","comment":"the new description","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the copy","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Encode the given value into the context block as specified by an operation\n@param cop the context operation specifying the location of the value to encode\n@param val the masked value to encode\n@return the result\n \n This is the forward (as in disassembly) direction of applying context operations. The\n pattern expression is evaluated, and the result is written as specified.","static":false,"name":"writeContextOp","comment":"Encode the given value into the context block as specified by an operation","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.ContextOp","name":"cop","comment":"the context operation specifying the location of the value to encode","type_short":"ContextOp"},{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","name":"val","comment":"the masked value to encode","type_short":"MaskedLong"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result\n \n This is the forward (as in disassembly) direction of applying context operations. The\n pattern expression is evaluated, and the result is written as specified.","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Decode the value from the context located where the given context operation would write\n \n This is used to read the value from the left-hand-side \"variable\" of a context operation.\n It seems backward, because it is. When assembling, the right-hand-side expression of a\n context operation must be solved. This means the \"variable\" is known from the context(s) of\n the resolved children constructors. The value read is then used as the goal in solving the\n expression.\n@param cop the context operation whose \"variable\" to read.\n@return the masked result.","static":false,"name":"readContextOp","comment":"Decode the value from the context located where the given context operation would write\n \n This is used to read the value from the left-hand-side \"variable\" of a context operation.\n It seems backward, because it is. When assembling, the right-hand-side expression of a\n context operation must be solved. This means the \"variable\" is known from the context(s) of\n the resolved children constructors. The value read is then used as the goal in solving the\n expression.","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.ContextOp","name":"cop","comment":"the context operation whose \"variable\" to read.","type_short":"ContextOp"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","comment":"the masked result.","type_short":"MaskedLong"}},{"javadoc":"Duplicate this resolution, with additional description text appended\n@param append the text to append\n@return the duplicate\n@note An additional separator {@code \": \"} is inserted","static":false,"name":"copyAppendDescription","comment":"Duplicate this resolution, with additional description text appended","params":[{"type_long":"java.lang.String","name":"append","comment":"the text to append","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the duplicate","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Set all bits read by a given context operation to unknown\n@param cop the context operation\n@return the result\n@see AssemblyPatternBlock#maskOut(ContextOp)","static":false,"name":"maskOut","comment":"Set all bits read by a given context operation to unknown","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.ContextOp","name":"cop","comment":"the context operation","type_short":"ContextOp"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Apply as many backfill records as possible\n \n Each backfill record is resolved in turn, if the record cannot be resolved, it remains\n listed. If the record can be resolved, but it conflicts, an error record is returned. Each\n time a record is resolved and combined successfully, all remaining records are tried again.\n The result is the combined resolved backfills, with only the unresolved backfill records\n listed.\n@param solver the solver, usually the same as the original attempt to solve.\n@param vals the values.\n@return the result, or an error.","static":false,"name":"backfill","comment":"Apply as many backfill records as possible\n \n Each backfill record is resolved in turn, if the record cannot be resolved, it remains\n listed. If the record can be resolved, but it conflicts, an error record is returned. Each\n time a record is resolved and combined successfully, all remaining records are tried again.\n The result is the combined resolved backfills, with only the unresolved backfill records\n listed.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.RecursiveDescentSolver","name":"solver","comment":"the solver, usually the same as the original attempt to solve.","type_short":"RecursiveDescentSolver"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"vals","comment":"the values.","type_short":"Map"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","comment":"the result, or an error.","type_short":"AssemblyResolution"}},{"javadoc":"","static":false,"name":"lineToString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Check if this resolution has pending backfills to apply\n@return true if there are backfills","static":false,"name":"hasBackfills","comment":"Check if this resolution has pending backfills to apply","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there are backfills","type_short":"boolean"}},{"javadoc":"Check if this resolution includes forbidden patterns\n@return true if there are forbidden patterns","static":false,"name":"hasForbids","comment":"Check if this resolution includes forbidden patterns","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there are forbidden patterns","type_short":"boolean"}},{"javadoc":"Solve and apply context changes in reverse to forbidden patterns\n \n To avoid circumstances where a context change during disassembly would invoke a more\n specific subconstructor than was used to assembly the instruction, we must solve the\n forbidden patterns in tandem with the overall resolution. If the context of any forbidden\n pattern cannot be solved, we simply drop the forbidden pattern -- the lack of a solution\n implies there is no way the context change could produce the forbidden pattern.\n@param sem the constructor whose context changes to solve\n@param vals any defined symbols\n@param opvals the operand values\n@return the result\n@see AssemblyConstructorSemantic#solveContextChanges(AssemblyResolvedConstructor, Map, Map)","static":false,"name":"solveContextChangesForForbids","comment":"Solve and apply context changes in reverse to forbidden patterns\n \n To avoid circumstances where a context change during disassembly would invoke a more\n specific subconstructor than was used to assembly the instruction, we must solve the\n forbidden patterns in tandem with the overall resolution. If the context of any forbidden\n pattern cannot be solved, we simply drop the forbidden pattern -- the lack of a solution\n implies there is no way the context change could produce the forbidden pattern.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyConstructorSemantic","name":"sem","comment":"the constructor whose context changes to solve","type_short":"AssemblyConstructorSemantic"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"vals","comment":"any defined symbols","type_short":"Map"},{"type_long":"java.util.Map<java.lang.Integer,java.lang.Object>","name":"opvals","comment":"the operand values","type_short":"Map"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the result","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Get the length of the instruction encoding\n \n This is used to ensure each operand is encoded at the correct offset\n@return the length of the instruction block\n@note this DOES include the offset\n@note this DOES include pending backfills","static":false,"name":"getInstructionLength","comment":"Get the length of the instruction encoding\n \n This is used to ensure each operand is encoded at the correct offset","params":[],"throws":[],"return":{"type_long":"int","comment":"the length of the instruction block","type_short":"int"}},{"javadoc":"Get the length of the instruction encoding, excluding trailing undefined bytes\n@return the length of the defined bytes in the instruction block\n@note this DOES include the offset\n@note this DOES NOT include pending backfills","static":false,"name":"getDefinedInstructionLength","comment":"Get the length of the instruction encoding, excluding trailing undefined bytes","params":[],"throws":[],"return":{"type_long":"int","comment":"the length of the defined bytes in the instruction block","type_short":"int"}},{"javadoc":"Get the instruction block\n@return the instruction block","static":false,"name":"getInstruction","comment":"Get the instruction block","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the instruction block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Get the context block\n@return the context block","static":false,"name":"getContext","comment":"Get the context block","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the context block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Decode a portion of the instruction block\n@param start the first byte to decode\n@param len the number of bytes to decode\n@return the read masked value\n@see AssemblyPatternBlock#readBytes(int, int)","static":false,"name":"readInstruction","comment":"Decode a portion of the instruction block","params":[{"type_long":"int","name":"start","comment":"the first byte to decode","type_short":"int"},{"type_long":"int","name":"len","comment":"the number of bytes to decode","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","comment":"the read masked value","type_short":"MaskedLong"}},{"javadoc":"Decode a portion of the context block\n@param start the first byte to decode\n@param len the number of bytes to decode\n@return the read masked value\n@see AssemblyPatternBlock#readBytes(int, int)","static":false,"name":"readContext","comment":"Decode a portion of the context block","params":[{"type_long":"int","name":"start","comment":"the first byte to decode","type_short":"int"},{"type_long":"int","name":"len","comment":"the number of bytes to decode","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","comment":"the read masked value","type_short":"MaskedLong"}},{"javadoc":"","static":false,"name":"isError","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"isBackfill","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"hasChildren","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"childrenToString","comment":"","params":[{"type_long":"java.lang.String","name":"indent","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Used for testing and diagnostics: list the constructor line numbers used to resolve this\n encoding\n \n This includes braces to describe the tree structure\n@see ConstructState#dumpConstructorTree()\n@return the constructor tree","static":false,"name":"dumpConstructorTree","comment":"Used for testing and diagnostics: list the constructor line numbers used to resolve this\n encoding\n \n This includes braces to describe the tree structure","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the constructor tree","type_short":"String"}},{"javadoc":"Count the number of bits specified in the resolution patterns\n \n Totals the specificity of the instruction and context pattern blocks.\n@return the number of bits in the resulting patterns\n@see AssemblyPatternBlock#getSpecificity()","static":false,"name":"getSpecificity","comment":"Count the number of bits specified in the resolution patterns\n \n Totals the specificity of the instruction and context pattern blocks.","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of bits in the resulting patterns","type_short":"int"}},{"javadoc":"Get an iterable over all the possible fillings of the instruction pattern given a context\n \n This is meant to be used idiomatically, as in an enhanced for loop:\n \n <pre>\n {@code\n for (byte[] ins : rcon.possibleInsVals(ctx)) {\n     System.out.println(format(ins));\n }\n }\n <\/pre>\n \n This is similar to calling\n {@link #getInstruction()}.{@link AssemblyPatternBlock#possibleVals()}, <em>but<\/em> with\n forbidden patterns removed. A context is required so that only those forbidden patterns\n matching the given context are actually removed. This method should always be preferred to\n the sequence mentioned above, since {@link AssemblyPatternBlock#possibleVals()} on its own\n may yield bytes that do not produce the desired instruction.\n@note The implementation is based on {@link AssemblyPatternBlock#possibleVals()}, so be\n aware that a single array is reused for each iterate. You should not retain a pointer to the\n array, but rather make a copy.\n@param forCtx the context at the assembly address\n@return the iterable","static":false,"name":"possibleInsVals","comment":"Get an iterable over all the possible fillings of the instruction pattern given a context\n \n This is meant to be used idiomatically, as in an enhanced for loop:\n \n \n \n \n \n This is similar to calling\n #getInstruction().AssemblyPatternBlock#possibleVals(), but with\n forbidden patterns removed. A context is required so that only those forbidden patterns\n matching the given context are actually removed. This method should always be preferred to\n the sequence mentioned above, since AssemblyPatternBlock#possibleVals() on its own\n may yield bytes that do not produce the desired instruction.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"forCtx","comment":"the context at the assembly address","type_short":"AssemblyPatternBlock"}],"throws":[],"return":{"type_long":"java.lang.Iterable<byte[]>","comment":"the iterable","type_short":"Iterable"}}],"name":"AssemblyResolvedConstructor","comment":"A AssemblyResolution indicating successful application of a constructor\n \n This is almost analogous to DisjointPattern, in that is joins an instruction\n AssemblyPatternBlock with a corresponding context AssemblyPatternBlock. However,\n this object is mutable, and it collects backfill records, as well as forbidden patterns.\n \n When the applied constructor is from the \"instruction\" subtable, this represents a fully-\n constructed instruction with required context. All backfill records ought to be resolved and\n applied before the final result is given to the user, i.e., passed into the\n AssemblySelector. If at any time during the resolution or backfill process, the result\n becomes confined to one of the forbidden patterns, it must be dropped, since the encoding will\n actually invoke a more specific SLEIGH constructor.","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"INS","comment":"","type_short":"String","constant_value":"\"ins:\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"CTX","comment":"","type_short":"String","constant_value":"\"ctx:\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"SEP","comment":"","type_short":"String","constant_value":"\",\""},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","javadoc":"","static":false,"name":"ins","comment":"","type_short":"AssemblyPatternBlock","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","javadoc":"","static":false,"name":"ctx","comment":"","type_short":"AssemblyPatternBlock","constant_value":null},{"type_long":"com.google.common.collect.ImmutableSet<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedBackfill>","javadoc":"","static":false,"name":"backfills","comment":"","type_short":"ImmutableSet","constant_value":null},{"type_long":"com.google.common.collect.ImmutableSet<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","javadoc":"","static":false,"name":"forbids","comment":"","type_short":"ImmutableSet","constant_value":null},{"type_long":"java.util.regex.Pattern","javadoc":"","static":true,"name":"pat","comment":"","type_short":"Pattern","constant_value":null}]}
