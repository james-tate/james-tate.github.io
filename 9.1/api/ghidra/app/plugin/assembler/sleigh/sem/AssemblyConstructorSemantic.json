{"implements":["java.lang.Comparable"],"javadoc":"Describes a SLEIGH constructor semantic\n \n These are collected and associated with productions in the grammar based on the given\n constructor's print pieces.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Build a new SLEIGH constructor semantic\n@param pattern the encoding pattern associated with the constructor\n@param cons the SLEIGH constructor\n@param indices the indices of RHS non-terminals in the associated production that represent an\n                operand in the SLEIGH constructor","static":false,"name":"<init>","comment":"Build a new SLEIGH constructor semantic","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.Constructor","name":"cons","comment":"the SLEIGH constructor","type_short":"Constructor"},{"type_long":"java.util.List<java.lang.Integer>","name":"indices","comment":"the indices of RHS non-terminals in the associated production that represent an\n                operand in the SLEIGH constructor","type_short":"List"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"addPattern","comment":"","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.pattern.DisjointPattern","name":"pat","comment":"","type_short":"DisjointPattern"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"addPattern","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"pat","comment":"","type_short":"AssemblyResolvedConstructor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Get the SLEIGH constructor\n@return the constructor","static":false,"name":"getConstructor","comment":"Get the SLEIGH constructor","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.processors.sleigh.Constructor","comment":"the constructor","type_short":"Constructor"}},{"javadoc":"Get the associated encoding patterns for the constructor\n@return the patterns","static":false,"name":"getPatterns","comment":"Get the associated encoding patterns for the constructor","params":[],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","comment":"the patterns","type_short":"Collection"}},{"javadoc":"Convert the index of a print piece to its associated operand index\n@param printpos position excluding whitespace and string tokens.\n@return the operand index","static":false,"name":"getOperandIndex","comment":"Convert the index of a print piece to its associated operand index","params":[{"type_long":"int","name":"printpos","comment":"position excluding whitespace and string tokens.","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the operand index","type_short":"int"}},{"javadoc":"Get the list of operand indices in print piece order\n@return the list","static":false,"name":"getOperandIndices","comment":"Get the list of operand indices in print piece order","params":[],"throws":[],"return":{"type_long":"com.google.common.collect.ImmutableList<java.lang.Integer>","comment":"the list","type_short":"ImmutableList"}},{"javadoc":"Get an iterator over the operand indices\n \n If this iterator is advanced for each non-terminal, while simultaneously iterating over the\n RHS of the associated production, then this will identify the corresponding operand index\n for each non-terminal\n@return the iterator","static":false,"name":"getOperandIndexIterator","comment":"Get an iterator over the operand indices\n \n If this iterator is advanced for each non-terminal, while simultaneously iterating over the\n RHS of the associated production, then this will identify the corresponding operand index\n for each non-terminal","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<java.lang.Integer>","comment":"the iterator","type_short":"Iterator"}},{"javadoc":"Initialize upatterns with an unmodifiable copy of patterns, with forbidden patterns added","static":false,"name":"computeAllForbids","comment":"Initialize upatterns with an unmodifiable copy of patterns, with forbidden patterns added","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add the list of forbidden patterns to one of the constructor's patterns\n \n SLEIGH disambiguates multiple matching pattern by two rules. First, if one is more specific\n than (\"specializes\") another, i.e., it matches on more bits than another pattern, the more\n specific pattern is chosen. Second, if the two are equally special, then the one that occurs\n first in the SLEIGH specification is taken. So, during resolution, if a less-special or\n later-occurring constructor is chosen, we must prevent continued resolution from matching\n the more-special  or earlier-occurring pattern(s).\n \n Essentially, this states, \"you may choose any value matching my pattern, except those that\n match these forbidden patterns.\"\n \n This takes a given pattern, and searches the rest of the language for any patterns that\n would take precedence, and combines them as forbidden patterns with the given pattern.\n@param pat2 the given pattern\n@returns the same pattern with forbidden records added","static":false,"name":"withComputedForbids","comment":"Add the list of forbidden patterns to one of the constructor's patterns\n \n SLEIGH disambiguates multiple matching pattern by two rules. First, if one is more specific\n than (\"specializes\") another, i.e., it matches on more bits than another pattern, the more\n specific pattern is chosen. Second, if the two are equally special, then the one that occurs\n first in the SLEIGH specification is taken. So, during resolution, if a less-special or\n later-occurring constructor is chosen, we must prevent continued resolution from matching\n the more-special  or earlier-occurring pattern(s).\n \n Essentially, this states, \"you may choose any value matching my pattern, except those that\n match these forbidden patterns.\"\n \n This takes a given pattern, and searches the rest of the language for any patterns that\n would take precedence, and combines them as forbidden patterns with the given pattern.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"pat","comment":"","type_short":"AssemblyResolvedConstructor"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"Solve this constructor's context changes\n@param res the combined resolution requirements derived from the subconstructors\n@param vals any defined symbols (usually {@code inst_start}, and {@code inst_next})\n@param opvals a map from operand index to operand value\n@return the resolution with context changes applied in reverse, or an error\n \n Each value in {@code opvals} must either be a numeric value, e.g., an index from a varnode\n list, or another {@link AssemblyResolvedConstructor} for a subconstructor operand.\n \n It's helpful to think of the SLEIGH disassembly process here. Normally, once the appropriate\n constructor has been identified (by matching patterns), its context changes are applied, and\n then its operands parsed (possibly parsing subconstructor operands). Thus, {@code res} can\n be thought of as the intermediate result between applying context changes and parsing\n operands, except in reverse. The output of this method corresponds to the state before\n context changes were applied, i.e., immediately after selecting the constructor. Thus, in\n reverse, the context is solved immediately before applying the selected constructor\n patterns.\n@see AssemblyTreeResolver#resolveSelectedChildren(AssemblyProduction, List, List, Collection)","static":false,"name":"solveContextChanges","comment":"Solve this constructor's context changes","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"res","comment":"the combined resolution requirements derived from the subconstructors","type_short":"AssemblyResolvedConstructor"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"vals","comment":"any defined symbols (usually , and )","type_short":"Map"},{"type_long":"java.util.Map<java.lang.Integer,java.lang.Object>","name":"opvals","comment":"a map from operand index to operand value","type_short":"Map"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution","comment":"the resolution with context changes applied in reverse, or an error\n \n Each value in  must either be a numeric value, e.g., an index from a varnode\n list, or another AssemblyResolvedConstructor for a subconstructor operand.\n \n It's helpful to think of the SLEIGH disassembly process here. Normally, once the appropriate\n constructor has been identified (by matching patterns), its context changes are applied, and\n then its operands parsed (possibly parsing subconstructor operands). Thus,  can\n be thought of as the intermediate result between applying context changes and parsing\n operands, except in reverse. The output of this method corresponds to the state before\n context changes were applied, i.e., immediately after selecting the constructor. Thus, in\n reverse, the context is solved immediately before applying the selected constructor\n patterns.","type_short":"AssemblyResolution"}},{"javadoc":"Apply just context transformations in the forward (disassembly) direction\n@param outer the state before context changes\n@return the state after context changes\n \n Unlike the usual disassembly process, this method does not take into account any information\n from the instruction encoding. Any context bits that depend on it are set to unknown\n ({@code x}) in the output. This method is used to pre-compute a context transition graph in\n order to quickly resolve purely-recursive semantics on the root constructor table.","static":false,"name":"applyForward","comment":"Apply just context transformations in the forward (disassembly) direction","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"outer","comment":"the state before context changes","type_short":"AssemblyResolvedConstructor"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","comment":"the state after context changes\n \n Unlike the usual disassembly process, this method does not take into account any information\n from the instruction encoding. Any context bits that depend on it are set to unknown\n () in the output. This method is used to pre-compute a context transition graph in\n order to quickly resolve purely-recursive semantics on the root constructor table.","type_short":"AssemblyResolvedConstructor"}},{"javadoc":"","static":false,"name":"compareTo","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyConstructorSemantic","name":"that","comment":"","type_short":"AssemblyConstructorSemantic"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}}],"name":"AssemblyConstructorSemantic","comment":"Describes a SLEIGH constructor semantic\n \n These are collected and associated with productions in the grammar based on the given\n constructor's print pieces.","fields":[{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.RecursiveDescentSolver","javadoc":"","static":true,"name":"solver","comment":"","type_short":"RecursiveDescentSolver","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.util.DbgTimer","javadoc":"","static":true,"name":"dbg","comment":"","type_short":"DbgTimer","constant_value":null},{"type_long":"java.util.Set<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","javadoc":"","static":false,"name":"patterns","comment":"","type_short":"Set","constant_value":null},{"type_long":"ghidra.app.plugin.processors.sleigh.Constructor","javadoc":"","static":false,"name":"cons","comment":"","type_short":"Constructor","constant_value":null},{"type_long":"com.google.common.collect.ImmutableList<java.lang.Integer>","javadoc":"","static":false,"name":"indices","comment":"","type_short":"ImmutableList","constant_value":null},{"type_long":"com.google.common.collect.ImmutableSet<ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor>","javadoc":"","static":false,"name":"upatterns","comment":"","type_short":"ImmutableSet","constant_value":null}]}
