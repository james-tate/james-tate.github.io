{"implements":["java.lang.Comparable"],"javadoc":"The analog of {@link PatternBlock}, designed for use by the assembler\n \n It is suitable for the assembler because it is represented byte-by-byte, and it offers a number\n of useful conversions and operations.\n@TODO A lot of this could probably be factored into the {@link PatternBlock} class, but it was\n best to experiment in another class altogether to avoid breaking things.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a new pattern block with the given mask, values, and offset\n@param offset an offset (0-up, left-to-right) where the pattern actually starts\n@param mask a mask: only {@code 1} bits are included in the pattern\n@param vals the value, excluding corresponding {@code 0} bits in the mask","static":false,"name":"<init>","comment":"Construct a new pattern block with the given mask, values, and offset","params":[{"type_long":"int","name":"offset","comment":"an offset (0-up, left-to-right) where the pattern actually starts","type_short":"int"},{"type_long":"byte[]","name":"mask","comment":"a mask: only  bits are included in the pattern","type_short":"byte[]"},{"type_long":"byte[]","name":"vals","comment":"the value, excluding corresponding  bits in the mask","type_short":"byte[]"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Construct a new empty pattern block at the given offset, prepared with the given capacity\n@param offset an offset (0-up, left-to-right) where the pattern will start\n@param capacity the space to allocate for the mask and values","static":false,"name":"<init>","comment":"Construct a new empty pattern block at the given offset, prepared with the given capacity","params":[{"type_long":"int","name":"offset","comment":"an offset (0-up, left-to-right) where the pattern will start","type_short":"int"},{"type_long":"int","name":"capacity","comment":"the space to allocate for the mask and values","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get an empty pattern block\n@return the pattern block","static":true,"name":"nop","comment":"Get an empty pattern block","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the pattern block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Get a pattern block with the given (fully-included) values at the given offset\n@param offset the offset (0-up, left-to-right)\n@param vals the values\n@return a pattern block (having a full mask)","static":true,"name":"fromBytes","comment":"Get a pattern block with the given (fully-included) values at the given offset","params":[{"type_long":"int","name":"offset","comment":"the offset (0-up, left-to-right)","type_short":"int"},{"type_long":"byte[]","name":"vals","comment":"the values","type_short":"byte[]"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"a pattern block (having a full mask)","type_short":"AssemblyPatternBlock"}},{"javadoc":"Convert the given long to a pattern block (having offset 0 and a full mask)\n@note The result will be 8 bytes in length\n@param value the value to convert\n@return the pattern block containing the big-endian representation of the value","static":true,"name":"fromLong","comment":"Convert the given long to a pattern block (having offset 0 and a full mask)","params":[{"type_long":"long","name":"value","comment":"the value to convert","type_short":"long"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the pattern block containing the big-endian representation of the value","type_short":"AssemblyPatternBlock"}},{"javadoc":"Convert the given masked long to a pattern block (having offset 0)\n@note The result will be 8 bytes in length\n@param ml the masked long, whose values and mask to convert\n@return the pattern block containing the big-endian representation of the value","static":true,"name":"fromMaskedLong","comment":"Convert the given masked long to a pattern block (having offset 0)","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","name":"ml","comment":"the masked long, whose values and mask to convert","type_short":"MaskedLong"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the pattern block containing the big-endian representation of the value","type_short":"AssemblyPatternBlock"}},{"javadoc":"Convert a string representation to a pattern block\n@see StringUtilities#convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int, String)\n@param str the string to convert\n@return the resulting pattern block","static":true,"name":"fromString","comment":"Convert a string representation to a pattern block","params":[{"type_long":"java.lang.String","name":"str","comment":"the string to convert","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the resulting pattern block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Convert a block from a disjoint pattern into an assembly pattern block\n@param pat the pattern to convert\n@param context true to select the context block, false to select the instruction block\n@return the converted pattern block","static":true,"name":"fromPattern","comment":"Convert a block from a disjoint pattern into an assembly pattern block","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.pattern.DisjointPattern","name":"pat","comment":"the pattern to convert","type_short":"DisjointPattern"},{"type_long":"int","name":"minLen","comment":"","type_short":"int"},{"type_long":"boolean","name":"context","comment":"true to select the context block, false to select the instruction block","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the converted pattern block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Encode the given masked long into a pattern block as specified by a given token field\n@param tf the token field specifying the location of the value to encode\n@param val the value to encode\n@return the pattern block with the encoded value","static":true,"name":"fromTokenField","comment":"Encode the given masked long into a pattern block as specified by a given token field","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.expression.TokenField","name":"tf","comment":"the token field specifying the location of the value to encode","type_short":"TokenField"},{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","name":"val","comment":"the value to encode","type_short":"MaskedLong"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the pattern block with the encoded value","type_short":"AssemblyPatternBlock"}},{"javadoc":"Encode the given masked long into a pattern block as specified by a given context field\n@param cf the context field specifying the location of the value to encode\n@param val the value to encode\n@return the pattern block with the encoded value","static":true,"name":"fromContextField","comment":"Encode the given masked long into a pattern block as specified by a given context field","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.expression.ContextField","name":"cf","comment":"the context field specifying the location of the value to encode","type_short":"ContextField"},{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","name":"val","comment":"the value to encode","type_short":"MaskedLong"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the pattern block with the encoded value","type_short":"AssemblyPatternBlock"}},{"javadoc":"Convert a register value into a pattern block\n@param rv the register value\n@return the pattern block\n \n This is used primarily to compute default context register values, and pass them into an\n assembler.","static":true,"name":"fromRegisterValue","comment":"Convert a register value into a pattern block","params":[{"type_long":"ghidra.program.model.lang.RegisterValue","name":"rv","comment":"the register value","type_short":"RegisterValue"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the pattern block\n \n This is used primarily to compute default context register values, and pass them into an\n assembler.","type_short":"AssemblyPatternBlock"}},{"javadoc":"Allocate a fully-undefined pattern block of the given length\n@param length the length in bytes\n@return the block of all unknown bits","static":true,"name":"fromLength","comment":"Allocate a fully-undefined pattern block of the given length","params":[{"type_long":"int","name":"length","comment":"the length in bytes","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the block of all unknown bits","type_short":"AssemblyPatternBlock"}},{"javadoc":"Duplicate this pattern block\n@return the duplicate","static":false,"name":"copy","comment":"Duplicate this pattern block","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the duplicate","type_short":"AssemblyPatternBlock"}},{"javadoc":"Get the length (plus the offset) of this pattern block\n@return the total length","static":false,"name":"length","comment":"Get the length (plus the offset) of this pattern block","params":[],"throws":[],"return":{"type_long":"int","comment":"the total length","type_short":"int"}},{"javadoc":"Shift, i.e., increase the offset of, this pattern block\n@param amt the amount to shift right\n@return the shifted pattern block","static":false,"name":"shift","comment":"Shift, i.e., increase the offset of, this pattern block","params":[{"type_long":"int","name":"amt","comment":"the amount to shift right","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the shifted pattern block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Truncate (unshift) this pattern block by removing bytes from the left\n@param amt the amount to truncate or shift left\n@return the truncated pattern block","static":false,"name":"truncate","comment":"Truncate (unshift) this pattern block by removing bytes from the left","params":[{"type_long":"int","name":"amt","comment":"the amount to truncate or shift left","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the truncated pattern block","type_short":"AssemblyPatternBlock"}},{"javadoc":"Combine this pattern block with another given block\n \n Two blocks can be combined in their corresponding defined bits agree. When blocks are\n combined, their bytes are aligned according to their shifts, and the defined bits are taken\n from either block. If neither block defines a bit (i.e., the mask bit at that position is\n {@code 0} for both input blocks, then the output has an undefined bit in the corresponding\n position. If both blocks define the bit, but they have opposite values, then the result is\n an error.\n@param that the other block\n@return the new combined block, or null if the blocks disagree for any bit","static":false,"name":"combine","comment":"Combine this pattern block with another given block\n \n Two blocks can be combined in their corresponding defined bits agree. When blocks are\n combined, their bytes are aligned according to their shifts, and the defined bits are taken\n from either block. If neither block defines a bit (i.e., the mask bit at that position is\n  for both input blocks, then the output has an undefined bit in the corresponding\n position. If both blocks define the bit, but they have opposite values, then the result is\n an error.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"that","comment":"the other block","type_short":"AssemblyPatternBlock"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the new combined block, or null if the blocks disagree for any bit","type_short":"AssemblyPatternBlock"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"obj","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"compareTo","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"that","comment":"","type_short":"AssemblyPatternBlock"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Read an array, returning a default if the index is out of bounds\n@param arr the array to read\n@param idx the index\n@param def the default value\n@return the read value","static":true,"name":"checkRead","comment":"Read an array, returning a default if the index is out of bounds","params":[{"type_long":"byte[]","name":"arr","comment":"the array to read","type_short":"byte[]"},{"type_long":"int","name":"idx","comment":"the index","type_short":"int"},{"type_long":"int","name":"def","comment":"the default value","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the read value","type_short":"int"}},{"javadoc":"Encode the given value into a copy of this pattern block as specified by a context operation\n@note this method is given as a special operation, instead of a conversion factory method,\n because this is a write operation, not a combine operation. As such, the bits (including\n undefined bits) replace the bits in the existing pattern block. Were this a conversion\n method, we would lose the distinction between unknown bits being written, and bits whose\n values are simply not included in the write.\n@param cop the context operation specifying the location of the value to encode\n@param val the value to encode\n@return the new copy with the encoded value","static":false,"name":"writeContextOp","comment":"Encode the given value into a copy of this pattern block as specified by a context operation","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.ContextOp","name":"cop","comment":"the context operation specifying the location of the value to encode","type_short":"ContextOp"},{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","name":"val","comment":"the value to encode","type_short":"MaskedLong"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the new copy with the encoded value","type_short":"AssemblyPatternBlock"}},{"javadoc":"Read the input of a context operation from this pattern block\n@param cop the context operation\n@return the decoded input, as a masked value","static":false,"name":"readContextOp","comment":"Read the input of a context operation from this pattern block","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.ContextOp","name":"cop","comment":"the context operation","type_short":"ContextOp"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","comment":"the decoded input, as a masked value","type_short":"MaskedLong"}},{"javadoc":"Set all bits read by a given context operation to unknown\n@param cop the context operation\n@return the result\n \n This is used during resolution to remove a context requirement passed upward by a child.\n When a parent constructor writes the required value to the context register, that\n requirement need not be passed further upward, since the write satisfies the requirement.","static":false,"name":"maskOut","comment":"Set all bits read by a given context operation to unknown","params":[{"type_long":"ghidra.app.plugin.processors.sleigh.ContextOp","name":"cop","comment":"the context operation","type_short":"ContextOp"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the result\n \n This is used during resolution to remove a context requirement passed upward by a child.\n When a parent constructor writes the required value to the context register, that\n requirement need not be passed further upward, since the write satisfies the requirement.","type_short":"AssemblyPatternBlock"}},{"javadoc":"Get the values array\n@return the array","static":false,"name":"getVals","comment":"Get the values array","params":[],"throws":[],"return":{"type_long":"byte[]","comment":"the array","type_short":"byte[]"}},{"javadoc":"Get the mask array\n@return the array","static":false,"name":"getMask","comment":"Get the mask array","params":[],"throws":[],"return":{"type_long":"byte[]","comment":"the array","type_short":"byte[]"}},{"javadoc":"Get the number of undefined bytes preceding the mask and values arrays\n@return the offset","static":false,"name":"getOffset","comment":"Get the number of undefined bytes preceding the mask and values arrays","params":[],"throws":[],"return":{"type_long":"int","comment":"the offset","type_short":"int"}},{"javadoc":"Decode {@code} len value bytes in big-endian format, beginning at {@code start}\n@param start the first byte to decode\n@param len the number of bytes to decode\n@return the decoded long","static":false,"name":"readValBytes","comment":"Decode  len value bytes in big-endian format, beginning at ","params":[{"type_long":"int","name":"start","comment":"the first byte to decode","type_short":"int"},{"type_long":"int","name":"len","comment":"the number of bytes to decode","type_short":"int"}],"throws":[],"return":{"type_long":"long","comment":"the decoded long","type_short":"long"}},{"javadoc":"Decode {@code} len mask bytes in big-endian format, beginning at {@code start}\n@param start the first byte to decode\n@param len the number of bytes to decode\n@return the decoded long","static":false,"name":"readMaskBytes","comment":"Decode  len mask bytes in big-endian format, beginning at ","params":[{"type_long":"int","name":"start","comment":"the first byte to decode","type_short":"int"},{"type_long":"int","name":"len","comment":"the number of bytes to decode","type_short":"int"}],"throws":[],"return":{"type_long":"long","comment":"the decoded long","type_short":"long"}},{"javadoc":"Decode {@code} len bytes (values and mask) in big-endian format, beginning at {@code start}\n@param start the first byte to decode\n@param len the number of bytes to decode\n@return the decoded masked long","static":false,"name":"readBytes","comment":"Decode  len bytes (values and mask) in big-endian format, beginning at ","params":[{"type_long":"int","name":"start","comment":"the first byte to decode","type_short":"int"},{"type_long":"int","name":"len","comment":"the number of bytes to decode","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.expr.MaskedLong","comment":"the decoded masked long","type_short":"MaskedLong"}},{"javadoc":"Fill all unknown bits with {@code 0} bits\n@return the result","static":false,"name":"fillMask","comment":"Fill all unknown bits with  bits","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the result","type_short":"AssemblyPatternBlock"}},{"javadoc":"Check if there are any unknown bits\n@return true if no unknown bits are present, false otherwise","static":false,"name":"isFullMask","comment":"Check if there are any unknown bits","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if no unknown bits are present, false otherwise","type_short":"boolean"}},{"javadoc":"Check if all bits are {@code 0} bits\n@return true if all are {@code 0}, false otherwise","static":false,"name":"isZero","comment":"Check if all bits are  bits","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if all are , false otherwise","type_short":"boolean"}},{"javadoc":"Decode the values array into a {@link BigInteger} of length {@code n} bytes\n \n The array is either truncated or zero-extended <em>on the right<\/em> to match the requested\n number of bytes, then decoded in big-endian format as an unsigned value.\n@param n the number of bytes (left-to-right) to decode\n@return the decoded big integer","static":false,"name":"toBigInteger","comment":"Decode the values array into a BigInteger of length  bytes\n \n The array is either truncated or zero-extended on the right to match the requested\n number of bytes, then decoded in big-endian format as an unsigned value.","params":[{"type_long":"int","name":"n","comment":"the number of bytes (left-to-right) to decode","type_short":"int"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"the decoded big integer","type_short":"BigInteger"}},{"javadoc":"Counts the total number of known bits in the pattern\n \n At a slightly lower level, counts the number of 1-bits in the mask.\n@return the count","static":false,"name":"getSpecificity","comment":"Counts the total number of known bits in the pattern\n \n At a slightly lower level, counts the number of 1-bits in the mask.","params":[],"throws":[],"return":{"type_long":"int","comment":"the count","type_short":"int"}},{"javadoc":"","static":false,"name":"countPossibleVals","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Get an iterable over all the possible fillings of the value, given a partial mask\n \n This is meant to be used idiomatically, as in an enhanced for loop:\n \n <pre>\n {@code\n for (byte[] val : pattern.possibleVals()) {\n     System.out.println(format(val));\n }\n }\n <\/pre>\n@note A single byte array is instantiated with the call to {@link Iterable#iterator()}. Each\n call to {@link Iterator#next()} modifies the one byte array and returns it. As such, if you\n intend to preserve the value in the array for later use, you <em>must<\/em> make a copy.\n@return the iterable.","static":false,"name":"possibleVals","comment":"Get an iterable over all the possible fillings of the value, given a partial mask\n \n This is meant to be used idiomatically, as in an enhanced for loop:\n \n \n \n ","params":[],"throws":[],"return":{"type_long":"java.lang.Iterable<byte[]>","comment":"the iterable.","type_short":"Iterable"}}],"name":"AssemblyPatternBlock","comment":"The analog of PatternBlock, designed for use by the assembler\n \n It is suitable for the assembler because it is represented byte-by-byte, and it offers a number\n of useful conversions and operations.","fields":[{"type_long":"java.lang.String","javadoc":"","static":true,"name":"SHIFT_STR","comment":"","type_short":"String","constant_value":"\"SS:\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"SHIFT_STR_END","comment":"","type_short":"String","constant_value":"\"SS\""},{"type_long":"int","javadoc":"","static":false,"name":"offset","comment":"","type_short":"int","constant_value":null},{"type_long":"byte[]","javadoc":"","static":false,"name":"mask","comment":"","type_short":"byte[]","constant_value":null},{"type_long":"byte[]","javadoc":"","static":false,"name":"vals","comment":"","type_short":"byte[]","constant_value":null}]}
