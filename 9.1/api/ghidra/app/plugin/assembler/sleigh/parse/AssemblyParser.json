{"implements":[],"javadoc":"A class to encapsulate LALR(1) parsing for a given grammar\n \n This class constructs the Action\/Goto table (and all the other trappings) of a LALR(1) parser\n and provides a {@link #parse(String)} method to parse actual sentences.\n \n This implementation is somewhat unconventional in that it permits ambiguous grammars. Instead of\n complaining, it produces the set of all possible parse trees. Of course, this comes at the cost\n of some efficiency.\n \n See Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman, <i>Compilers: Principles,\n Techniques, &amp; Tools<\/i>. Bostom, MA: Pearson, 2007.\n \n See Jackson, Stephen. <a href=\"http:\/\/web.cs.dal.ca\/~sjackson\/lalr1.html\">LALR(1) Parsing<\/a>.\n Halifax, Nova Scotia, Canada: Dalhousie University.\n &lt;http:\/\/web.cs.dal.ca\/~sjackson\/lalr1.html&gt;","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a LALR(1) parser from the given grammar\n@param grammar the grammar","static":false,"name":"<init>","comment":"Construct a LALR(1) parser from the given grammar","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","name":"grammar","comment":"the grammar","type_short":"AssemblyGrammar"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"buildLR0Machine","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add a newly-constructed LR0 state, and return it's assigned number\n@param state the newly-constructed state\n@return the assigned number\n \n If the state already exists, this just returns its previously assigned number","static":false,"name":"addLR0State","comment":"Add a newly-constructed LR0 state, and return it's assigned number","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseState","name":"state","comment":"the newly-constructed state","type_short":"AssemblyParseState"}],"throws":[],"return":{"type_long":"int","comment":"the assigned number\n \n If the state already exists, this just returns its previously assigned number","type_short":"int"}},{"javadoc":"","static":false,"name":"buildExtendedGrammar","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Extend a production, using the given LR0 start state\n@param prod the production to extend\n@param start the starting LR0 state\n@return the extended production, if the start state is valid for it","static":false,"name":"extend","comment":"Extend a production, using the given LR0 start state","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction","name":"prod","comment":"the production to extend","type_short":"AssemblyProduction"},{"type_long":"int","name":"start","comment":"the starting LR0 state","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyExtendedProduction","comment":"the extended production, if the start state is valid for it","type_short":"AssemblyExtendedProduction"}},{"javadoc":"","static":false,"name":"buildActionGotoTable","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Parse the given sentence\n@param input the sentence to parse\n@return all possible parse trees (and possible errors)","static":false,"name":"parse","comment":"Parse the given sentence","params":[{"type_long":"java.lang.String","name":"input","comment":"the sentence to parse","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.Iterable<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult>","comment":"all possible parse trees (and possible errors)","type_short":"Iterable"}},{"javadoc":"Parse the given sentence with the given defined labels\n@param input the sentence to parser\n@param labels a map of label to number substitutions\n@return all possible parse results (trees and errors)\n \n The tokenizer for numeric terminals also accepts any key in {@code labels.} In such cases,\n the resulting token is assigned the value of the label.","static":false,"name":"parse","comment":"Parse the given sentence with the given defined labels","params":[{"type_long":"java.lang.String","name":"input","comment":"the sentence to parser","type_short":"String"},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","name":"labels","comment":"a map of label to number substitutions","type_short":"Map"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult>","comment":"all possible parse results (trees and errors)\n \n The tokenizer for numeric terminals also accepts any key in  In such cases,\n the resulting token is assigned the value of the label.","type_short":"Collection"}},{"javadoc":"For debugging","static":false,"name":"printGrammar","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printLR0States","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printLR0TransitionTable","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printExtendedGrammar","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printGeneralFF","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printExtendedFF","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printMergers","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printParseTable","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"For debugging","static":false,"name":"printStuff","comment":"For debugging","params":[{"type_long":"java.io.PrintStream","name":"out","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the grammar used to construct this parser\n@return the grammar","static":false,"name":"getGrammar","comment":"Get the grammar used to construct this parser","params":[],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","comment":"the grammar","type_short":"AssemblyGrammar"}}],"name":"AssemblyParser","comment":"A class to encapsulate LALR(1) parsing for a given grammar\n \n This class constructs the Action\/Goto table (and all the other trappings) of a LALR(1) parser\n and provides a #parse(String) method to parse actual sentences.\n \n This implementation is somewhat unconventional in that it permits ambiguous grammars. Instead of\n complaining, it produces the set of all possible parse trees. Of course, this comes at the cost\n of some efficiency.\n \n See Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman, Compilers: Principles,\n Techniques,  Tools. Bostom, MA: Pearson, 2007.\n \n See Jackson, Stephen. LALR(1) Parsing.\n Halifax, Nova Scotia, Canada: Dalhousie University.\n http:\/\/web.cs.dal.ca\/~sjackson\/lalr1.html","fields":[{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar","javadoc":"","static":false,"name":"grammar","comment":"","type_short":"AssemblyGrammar","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyFirstFollow","javadoc":"","static":false,"name":"ff","comment":"","type_short":"AssemblyFirstFollow","constant_value":null},{"type_long":"java.util.ArrayList<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseState>","javadoc":"","static":false,"name":"states","comment":"","type_short":"ArrayList","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseTransitionTable","javadoc":"","static":false,"name":"table","comment":"","type_short":"AssemblyParseTransitionTable","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyExtendedGrammar","javadoc":"","static":false,"name":"extendedGrammar","comment":"","type_short":"AssemblyExtendedGrammar","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyFirstFollow","javadoc":"","static":false,"name":"extff","comment":"","type_short":"AssemblyFirstFollow","constant_value":null},{"type_long":"java.util.Map<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParser.MergeKey,ghidra.app.plugin.assembler.sleigh.parse.AssemblyParser.MergeValue>","javadoc":"","static":false,"name":"mergers","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseActionGotoTable","javadoc":"","static":false,"name":"actions","comment":"","type_short":"AssemblyParseActionGotoTable","constant_value":null},{"type_long":"java.util.Map<java.lang.String,java.lang.Long>","javadoc":"A convenience to specify no labels in {@link #parse(String, Map)}","static":true,"name":"EMPTY_LABELS","comment":"A convenience to specify no labels in #parse(String, Map)","type_short":"Map","constant_value":null},{"type_long":"ghidra.app.plugin.assembler.sleigh.util.DbgTimer","javadoc":"","static":true,"name":"dbg","comment":"","type_short":"DbgTimer","constant_value":null},{"type_long":"boolean","javadoc":"","static":true,"name":"dbg_detail","comment":"","type_short":"boolean","constant_value":"false"}]}
