{"implements":[],"javadoc":"The Action\/Goto table for a LALR(1) parser\n \n This table is unconventional in that it permits a single cell to be populated by more than one\n action. Typically, such a situation would indicate an ambiguity, or the need for a longer\n look-ahead value. Because we do not presume to control the grammar (which was automatically\n derived from another source), the parsing algorithm will simply branch, eventually trying both\n options.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add an action entry to the given cell\n@param fromState the state (row) in the table\n@param next the symbol (column) in the table\n@param action the entry to add to the cell\n@return true, if the given entry was not already present","static":false,"name":"put","comment":"Add an action entry to the given cell","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"},{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol","name":"next","comment":"the symbol (column) in the table","type_short":"AssemblySymbol"},{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseActionGotoTable.Action","name":"action","comment":"the entry to add to the cell","type_short":"Action"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if the given entry was not already present","type_short":"boolean"}},{"javadoc":"Add a SHIFT (S<i>n<\/i>) entry to the given cell\n@param fromState the state (row) in the table\n@param next the symbol (column) in the table\n@param newState the state (<i>n<\/i>) after the shift is applied\n@return true, if the given entry was not already present","static":false,"name":"putShift","comment":"Add a SHIFT (Sn) entry to the given cell","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"},{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal","name":"next","comment":"the symbol (column) in the table","type_short":"AssemblyTerminal"},{"type_long":"int","name":"newState","comment":"the state (n) after the shift is applied","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if the given entry was not already present","type_short":"boolean"}},{"javadoc":"Add a REDUCE (R<i>n<\/i>) entry to the given cell\n@param fromState the state (row) in the table\n@param next the symbol (column) in the table\n@param prod the production (having index <i>n<\/i>) associated with the reduction\n@return true, if the given entry was not already present","static":false,"name":"putReduce","comment":"Add a REDUCE (Rn) entry to the given cell","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"},{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal","name":"next","comment":"the symbol (column) in the table","type_short":"AssemblyTerminal"},{"type_long":"ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction","name":"prod","comment":"the production (having index n) associated with the reduction","type_short":"AssemblyProduction"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if the given entry was not already present","type_short":"boolean"}},{"javadoc":"Add a GOTO entry to the given cell\n@param fromState the state (row) in the table\n@param next the symbol (column) in the table\n@param newState the target state\n@return true, if the given entry was not already present","static":false,"name":"putGoto","comment":"Add a GOTO entry to the given cell","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"},{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblyNonTerminal","name":"next","comment":"the symbol (column) in the table","type_short":"AssemblyNonTerminal"},{"type_long":"int","name":"newState","comment":"the target state","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if the given entry was not already present","type_short":"boolean"}},{"javadoc":"Add an ACCEPT entry for the given state at the end of input\n@param fromState the state (row) in the table\n@return true, if the state does not already accept on end of input","static":false,"name":"putAccept","comment":"Add an ACCEPT entry for the given state at the end of input","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"true, if the state does not already accept on end of input","type_short":"boolean"}},{"javadoc":"Get the terminals that are expected, i.e., have entries for the given state\n@param fromState the state (row) in the table\n@return the collection of populated columns (terminals) for the given state","static":false,"name":"getExpected","comment":"Get the terminals that are expected, i.e., have entries for the given state","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal>","comment":"the collection of populated columns (terminals) for the given state","type_short":"Collection"}},{"javadoc":"Get all entries in a given cell\n@param fromState the state (row) in the table\n@param next the symbol (column) in the table\n@return all action entries in the given cell","static":false,"name":"get","comment":"Get all entries in a given cell","params":[{"type_long":"int","name":"fromState","comment":"the state (row) in the table","type_short":"int"},{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol","name":"next","comment":"the symbol (column) in the table","type_short":"AssemblySymbol"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseActionGotoTable.Action>","comment":"all action entries in the given cell","type_short":"Collection"}}],"name":"AssemblyParseActionGotoTable","comment":"The Action\/Goto table for a LALR(1) parser\n \n This table is unconventional in that it permits a single cell to be populated by more than one\n action. Typically, such a situation would indicate an ambiguity, or the need for a longer\n look-ahead value. Because we do not presume to control the grammar (which was automatically\n derived from another source), the parsing algorithm will simply branch, eventually trying both\n options.","fields":[{"type_long":"org.apache.commons.collections4.MultiValuedMap<ghidra.app.plugin.assembler.sleigh.util.TableEntryKey,ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseActionGotoTable.Action>","javadoc":"","static":false,"name":"map","comment":"","type_short":"MultiValuedMap","constant_value":null},{"type_long":"org.apache.commons.collections4.MultiValuedMap<java.lang.Integer,ghidra.app.plugin.assembler.sleigh.symbol.AssemblyTerminal>","javadoc":"","static":false,"name":"possibleTerms","comment":"","type_short":"MultiValuedMap","constant_value":null}]}
