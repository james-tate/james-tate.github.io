{"implements":["java.lang.Comparable"],"javadoc":"A symbol in a context-free grammar\n \n Symbols can be either terminals or non-terminals. Non-terminals must have a defining production,\n i.e., it must appear as the left-hand side of some production in the grammar. \n \n Traditionally, when displayed, non-terminals should be immediately distinguishable from\n terminals. In classic CS literature, this usually means non-terminals are in CAPS, and terminals\n are in lower-case. Because the assembler doesn't control the names provided by SLEIGH, we\n surround non-terminals in [brackets].\n@see AbstractAssemblyGrammar","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Construct a new symbol with the given name\n@param name the name","static":false,"name":"<init>","comment":"Construct a new symbol with the given name","params":[{"type_long":"java.lang.String","name":"name","comment":"the name","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Get the name of this symbol\n@return the name","static":false,"name":"getName","comment":"Get the name of this symbol","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name","type_short":"String"}},{"javadoc":"","static":false,"name":"compareTo","comment":"","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol","name":"that","comment":"","type_short":"AssemblySymbol"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"that","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"Check if this symbol consumes an operand index of its constructor\n@return true if the symbol represents an operand","static":false,"name":"takesOperandIndex","comment":"Check if this symbol consumes an operand index of its constructor","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if the symbol represents an operand","type_short":"boolean"}}],"name":"AssemblySymbol","comment":"A symbol in a context-free grammar\n \n Symbols can be either terminals or non-terminals. Non-terminals must have a defining production,\n i.e., it must appear as the left-hand side of some production in the grammar. \n \n Traditionally, when displayed, non-terminals should be immediately distinguishable from\n terminals. In classic CS literature, this usually means non-terminals are in CAPS, and terminals\n are in lower-case. Because the assembler doesn't control the names provided by SLEIGH, we\n surround non-terminals in [brackets].","fields":[{"type_long":"java.lang.String","javadoc":"","static":false,"name":"name","comment":"","type_short":"String","constant_value":null}]}
