{"implements":[],"javadoc":"The primary interface for performing assembly in Ghidra.\n \n Use the {@link Assemblers} class to obtain a suitable implementation for a given program or\n language.","static":false,"methods":[{"javadoc":"Assemble a sequence of instructions and place them at the given address.\n \n This method is only valid if the assembler is bound to a program. An instance may optionally\n implement this method without a program binding. In that case, the returned instruction\n block will refer to pseudo instructions.\n@note There must be an active transaction on the bound program for this method to succeed.\n@param at the location where the resulting instructions should be placed\n@param listing a new-line separated or array sequence of instructions\n@return the block of resulting instructions\n@throws AssemblySyntaxException a textual instruction is non well-formed\n@throws AssemblySemanticException a well-formed instruction cannot be assembled\n@throws MemoryAccessException there is an issue writing the result to program memory\n@throws AddressOverflowException the resulting block is beyond the valid address range","static":false,"name":"assemble","comment":"Assemble a sequence of instructions and place them at the given address.\n \n This method is only valid if the assembler is bound to a program. An instance may optionally\n implement this method without a program binding. In that case, the returned instruction\n block will refer to pseudo instructions.","params":[{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location where the resulting instructions should be placed","type_short":"Address"},{"type_long":"java.lang.String[]","name":"listing","comment":"a new-line separated or array sequence of instructions","type_short":"java.lang.String[]"}],"throws":[{"type_long":"ghidra.app.plugin.assembler.AssemblySyntaxException","comment":"a textual instruction is non well-formed","type_short":"AssemblySyntaxException"},{"type_long":"ghidra.app.plugin.assembler.AssemblySemanticException","comment":"a well-formed instruction cannot be assembled","type_short":"AssemblySemanticException"},{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"there is an issue writing the result to program memory","type_short":"MemoryAccessException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"the resulting block is beyond the valid address range","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.lang.InstructionBlock","comment":"the block of resulting instructions","type_short":"InstructionBlock"}},{"javadoc":"Assemble a line instruction at the given address.\n \n This method is valid with or without a bound program. Even if bound, the program is not\n modified; however, the appropriate context information is taken from the bound program.\n Without a program, the language's default context is taken at the given location.\n@param at the location of the start of the instruction\n@param line the textual assembly code\n@return the binary machine code, suitable for placement at the given address\n@throws AssemblySyntaxException the textual instruction is not well-formed\n@throws AssemblySemanticException the the well-formed instruction cannot be assembled","static":false,"name":"assembleLine","comment":"Assemble a line instruction at the given address.\n \n This method is valid with or without a bound program. Even if bound, the program is not\n modified; however, the appropriate context information is taken from the bound program.\n Without a program, the language's default context is taken at the given location.","params":[{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"},{"type_long":"java.lang.String","name":"line","comment":"the textual assembly code","type_short":"String"}],"throws":[{"type_long":"ghidra.app.plugin.assembler.AssemblySyntaxException","comment":"the textual instruction is not well-formed","type_short":"AssemblySyntaxException"},{"type_long":"ghidra.app.plugin.assembler.AssemblySemanticException","comment":"the the well-formed instruction cannot be assembled","type_short":"AssemblySemanticException"}],"return":{"type_long":"byte[]","comment":"the binary machine code, suitable for placement at the given address","type_short":"byte[]"}},{"javadoc":"Assemble a line instruction at the given address, assuming the given context.\n \n This method works like {@link #assembleLine(Address, String)} except that it allows you to\n override the assumed context at that location.\n@param at the location of the start of the instruction\n@param line the textual assembly code\n@param ctx the context register value at the start of the instruction\n@return the results of semantic resolution (from all parse results)\n@throws AssemblySyntaxException the textual instruction is not well-formed\n@throws AssemblySemanticException the well-formed instruction cannot be assembled","static":false,"name":"assembleLine","comment":"Assemble a line instruction at the given address, assuming the given context.\n \n This method works like #assembleLine(Address, String) except that it allows you to\n override the assumed context at that location.","params":[{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"},{"type_long":"java.lang.String","name":"line","comment":"the textual assembly code","type_short":"String"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"ctx","comment":"the context register value at the start of the instruction","type_short":"AssemblyPatternBlock"}],"throws":[{"type_long":"ghidra.app.plugin.assembler.AssemblySemanticException","comment":"the well-formed instruction cannot be assembled","type_short":"AssemblySemanticException"},{"type_long":"ghidra.app.plugin.assembler.AssemblySyntaxException","comment":"the textual instruction is not well-formed","type_short":"AssemblySyntaxException"}],"return":{"type_long":"byte[]","comment":"the results of semantic resolution (from all parse results)","type_short":"byte[]"}},{"javadoc":"Parse a line instruction.\n \n Generally, you should just use {@link #assembleLine(Address, String)}, but if you'd like\n access to the parse trees outside of an {@link AssemblySelector}, then this may be an\n acceptable option. Most notably, this is an excellent way to obtain suggestions for\n auto-completion.\n \n Each item in the returned collection is either a complete parse tree, or a syntax error\n Because all parse paths are attempted, it's possible to get many mixed results. For example,\n The input line may be a valid instruction; however, there may be suggestions to continue the\n line toward another valid instruction.\n@param line the line (or partial line) to parse\n@return the results of parsing","static":false,"name":"parseLine","comment":"Parse a line instruction.\n \n Generally, you should just use #assembleLine(Address, String), but if you'd like\n access to the parse trees outside of an AssemblySelector, then this may be an\n acceptable option. Most notably, this is an excellent way to obtain suggestions for\n auto-completion.\n \n Each item in the returned collection is either a complete parse tree, or a syntax error\n Because all parse paths are attempted, it's possible to get many mixed results. For example,\n The input line may be a valid instruction; however, there may be suggestions to continue the\n line toward another valid instruction.","params":[{"type_long":"java.lang.String","name":"line","comment":"the line (or partial line) to parse","type_short":"String"}],"throws":[],"return":{"type_long":"java.util.Collection<ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult>","comment":"the results of parsing","type_short":"Collection"}},{"javadoc":"Resolve a given parse tree at the given address, assuming the given context\n \n Each item in the returned collection is either a completely resolved instruction, or a\n semantic error. Because all resolutions are attempted, it's possible to get many mixed\n results.\n \n NOTE: The resolved instructions are given as masks and values. Where the mask does not\n cover, you can choose any value.\n@param parse a parse result giving a valid tree\n@param at the location of the start of the instruction\n@param ctx the context register value at the start of the instruction\n@return the results of semantic resolution","static":false,"name":"resolveTree","comment":"Resolve a given parse tree at the given address, assuming the given context\n \n Each item in the returned collection is either a completely resolved instruction, or a\n semantic error. Because all resolutions are attempted, it's possible to get many mixed\n results.\n \n NOTE: The resolved instructions are given as masks and values. Where the mask does not\n cover, you can choose any value.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult","name":"parse","comment":"a parse result giving a valid tree","type_short":"AssemblyParseResult"},{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"ctx","comment":"the context register value at the start of the instruction","type_short":"AssemblyPatternBlock"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the results of semantic resolution","type_short":"AssemblyResolutionResults"}},{"javadoc":"Resolve a given parse tree at the given address.\n \n Each item in the returned collection is either a completely resolved instruction, or a\n semantic error. Because all resolutions are attempted, it's possible to get many mixed\n results.\n \n NOTE: The resolved instructions are given as masks and values. Where the mask does not\n cover, you can choose any value.\n@param parse a parse result giving a valid tree\n@param at the location of the start of the instruction\n@return the results of semantic resolution","static":false,"name":"resolveTree","comment":"Resolve a given parse tree at the given address.\n \n Each item in the returned collection is either a completely resolved instruction, or a\n semantic error. Because all resolutions are attempted, it's possible to get many mixed\n results.\n \n NOTE: The resolved instructions are given as masks and values. Where the mask does not\n cover, you can choose any value.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult","name":"parse","comment":"a parse result giving a valid tree","type_short":"AssemblyParseResult"},{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the results of semantic resolution","type_short":"AssemblyResolutionResults"}},{"javadoc":"Assemble a line instruction at the given address.\n \n This method works like {@link #resolveLine(Address, String, AssemblyPatternBlock), except\n that it derives the context using {@link #getContextAt(Address)}.\n@param at the location of the start of the instruction\n@param line the textual assembly code\n@return the collection of semantic resolution results\n@throws AssemblySyntaxException the textual instruction is not well-formed","static":false,"name":"resolveLine","comment":"Assemble a line instruction at the given address.\n \n This method works like  except\n that it derives the context using #getContextAt(Address).","params":[{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"},{"type_long":"java.lang.String","name":"line","comment":"the textual assembly code","type_short":"String"}],"throws":[{"type_long":"ghidra.app.plugin.assembler.AssemblySyntaxException","comment":"the textual instruction is not well-formed","type_short":"AssemblySyntaxException"}],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the collection of semantic resolution results","type_short":"AssemblyResolutionResults"}},{"javadoc":"Assemble a line instruction at the given address, assuming the given context.\n \n This method works like {@link #assembleLine(Address,String,AssemblyPatternBlock}, except\n that it returns all possible resolutions for the parse trees that pass the\n {@link AssemblySelector}.\n@param at the location of the start of the instruction\n@param line the textual assembly code\n@param ctx the context register value at the start of the instruction\n@return the collection of semantic resolution results\n@throws AssemblySyntaxException the textual instruction is not well-formed","static":false,"name":"resolveLine","comment":"Assemble a line instruction at the given address, assuming the given context.\n \n This method works like }, except\n that it returns all possible resolutions for the parse trees that pass the\n AssemblySelector.","params":[{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"},{"type_long":"java.lang.String","name":"line","comment":"the textual assembly code","type_short":"String"},{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","name":"ctx","comment":"the context register value at the start of the instruction","type_short":"AssemblyPatternBlock"}],"throws":[{"type_long":"ghidra.app.plugin.assembler.AssemblySyntaxException","comment":"the textual instruction is not well-formed","type_short":"AssemblySyntaxException"}],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults","comment":"the collection of semantic resolution results","type_short":"AssemblyResolutionResults"}},{"javadoc":"Place a resolved (and fully-masked) instruction into the bound program.\n \n This method is not valid without a program binding. Also, this method must be called during\n a program database transaction.\n@param res the resolved and fully-masked instruction\n@param at the location of the start of the instruction\n@return the new {@link Instruction} code unit\n@throws MemoryAccessException there is an issue writing the result to program memory","static":false,"name":"patchProgram","comment":"Place a resolved (and fully-masked) instruction into the bound program.\n \n This method is not valid without a program binding. Also, this method must be called during\n a program database transaction.","params":[{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedConstructor","name":"res","comment":"the resolved and fully-masked instruction","type_short":"AssemblyResolvedConstructor"},{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"there is an issue writing the result to program memory","type_short":"MemoryAccessException"}],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the new Instruction code unit","type_short":"Instruction"}},{"javadoc":"Place an instruction into the bound program.\n \n This method is not valid without a program binding. Also, this method must be called during\n a program database transaction.\n@param insbytes the instruction data\n@param at the location of the start of the instruction\n@return the new {@link Instruction} code unit\n@throws MemoryAccessException there is an issue writing the result to program memory","static":false,"name":"patchProgram","comment":"Place an instruction into the bound program.\n \n This method is not valid without a program binding. Also, this method must be called during\n a program database transaction.","params":[{"type_long":"byte[]","name":"insbytes","comment":"the instruction data","type_short":"byte[]"},{"type_long":"ghidra.program.model.address.Address","name":"at","comment":"the location of the start of the instruction","type_short":"Address"}],"throws":[{"type_long":"ghidra.program.model.mem.MemoryAccessException","comment":"there is an issue writing the result to program memory","type_short":"MemoryAccessException"}],"return":{"type_long":"ghidra.program.model.listing.Instruction","comment":"the new Instruction code unit","type_short":"Instruction"}},{"javadoc":"Get the context at a given address\n \n If there is a program binding, this will extract the actual context at the given address.\n Otherwise, it will obtain the default context at the given address for the language.\n@param addr the address\n@return the context","static":false,"name":"getContextAt","comment":"Get the context at a given address\n \n If there is a program binding, this will extract the actual context at the given address.\n Otherwise, it will obtain the default context at the given address for the language.","params":[{"type_long":"ghidra.program.model.address.Address","name":"addr","comment":"the address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock","comment":"the context","type_short":"AssemblyPatternBlock"}}],"name":"Assembler","comment":"The primary interface for performing assembly in Ghidra.\n \n Use the Assemblers class to obtain a suitable implementation for a given program or\n language.","fields":[]}
