{"implements":["ghidra.app.util.bin.StructConverter","java.lang.Comparable","ghidra.app.util.bin.format.Writeable","ghidra.app.util.bin.format.MemoryLoadable"],"javadoc":"An executable or shared object file's program header table is an \n array of structures, each describing a segment\n or other information the system needs to prepare the program for execution. \n An object file segment contains one or more sections. \n Program headers are meaningful only for executable \n and shared object files. A file specifies its \n own program header size with the ELF\n header's e_phentsize and e_phnum members.\n Some entries describe process segments; others give supplementary information and do not contribute to\n the process image. Segment entries may appear in any order. Except for PT_LOAD segment \n entries which must appear in ascending order, sorted on the p_vaddr member.\n <br>\n <pre>\n typedef struct {\n     Elf32_Word   p_type;\n     Elf32_Off    p_offset;\n     Elf32_Addr   p_vaddr;\n     Elf32_Addr   p_paddr;\n     Elf32_Word   p_filesz;\n     Elf32_Word   p_memsz;\n     Elf32_Word   p_flags;\n     Elf32_Word   p_align;\n } Elf32_Phdr;\n \n typedef struct {\n     Elf64_Word   p_type;         \/\/Segment type\n     Elf64_Word   p_flags;        \/\/Segment flags\n     Elf64_Off    p_offset;       \/\/Segment file offset\n     Elf64_Addr   p_vaddr;        \/\/Segment virtual address\n     Elf64_Addr   p_paddr;        \/\/Segment physical address\n     Elf64_Xword  p_filesz;       \/\/Segment size in file\n     Elf64_Xword  p_memsz;        \/\/Segment size in memory\n     Elf64_Xword  p_align;        \/\/Segment alignment\n } Elf64_Phdr;\n <\/pre>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":true,"name":"createElfProgramHeader","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","comment":"","type_short":"ElfProgramHeader"}},{"javadoc":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","static":false,"name":"<init>","comment":"DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"initElfProgramHeader","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader"},{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new program header with the specified type.\n@param type the new type of the program header","static":false,"name":"<init>","comment":"Constructs a new program header with the specified type.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"header","comment":"","type_short":"ElfHeader"},{"type_long":"int","name":"type","comment":"the new type of the program header","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Return ElfHeader associated with this program header\n@return ElfHeader","static":false,"name":"getElfHeader","comment":"Return ElfHeader associated with this program header","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","comment":"ElfHeader","type_short":"ElfHeader"}},{"javadoc":"@see ghidra.app.util.bin.format.Writeable#write(java.io.RandomAccessFile, ghidra.util.DataConverter)","static":false,"name":"write","comment":"","params":[{"type_long":"java.io.RandomAccessFile","name":"raf","comment":"","type_short":"RandomAccessFile"},{"type_long":"ghidra.util.DataConverter","name":"dc","comment":"","type_short":"DataConverter"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get header type as string.  ElfProgramHeaderType name will be returned\n if know, otherwise a numeric name of the form \"PT_0x12345678\" will be returned.\n@return header type as string","static":false,"name":"getTypeAsString","comment":"Get header type as string.  ElfProgramHeaderType name will be returned\n if know, otherwise a numeric name of the form \"PT_0x12345678\" will be returned.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"header type as string","type_short":"String"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Get header description\n@return header description","static":false,"name":"getDescription","comment":"Get header description","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"header description","type_short":"String"}},{"javadoc":"Get descriptive comment which includes type and description\n@return descriptive comment","static":false,"name":"getComment","comment":"Get descriptive comment which includes type and description","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"descriptive comment","type_short":"String"}},{"javadoc":"As ''Program Loading'' later in this part describes, loadable process segments must have\n congruent values for p_vaddr and p_offset, modulo the page size. This member\n gives the value to which the segments are aligned in memory and in the file. Values 0\n and 1 mean no alignment is required. Otherwise, p_align should be a positive, integral\n power of 2, and p_vaddr should equal p_offset, modulo p_align.\n@return the segment alignment value","static":false,"name":"getAlign","comment":"As ''Program Loading'' later in this part describes, loadable process segments must have\n congruent values for p_vaddr and p_offset, modulo the page size. This member\n gives the value to which the segments are aligned in memory and in the file. Values 0\n and 1 mean no alignment is required. Otherwise, p_align should be a positive, integral\n power of 2, and p_vaddr should equal p_offset, modulo p_align.","params":[],"throws":[],"return":{"type_long":"long","comment":"the segment alignment value","type_short":"long"}},{"javadoc":"This member gives the number of bytes in the file image of the segment; it may be zero.\n@return the number of bytes in the file image","static":false,"name":"getFileSize","comment":"This member gives the number of bytes in the file image of the segment; it may be zero.","params":[],"throws":[],"return":{"type_long":"long","comment":"the number of bytes in the file image","type_short":"long"}},{"javadoc":"This member gives flags relevant to the segment. Defined flag values appear below.\n@return the segment flags","static":false,"name":"getFlags","comment":"This member gives flags relevant to the segment. Defined flag values appear below.","params":[],"throws":[],"return":{"type_long":"int","comment":"the segment flags","type_short":"int"}},{"javadoc":"","static":false,"name":"setFlags","comment":"","params":[{"type_long":"int","name":"flags","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if this segment is readable when loaded\n@return true if this segment is readable when loaded","static":false,"name":"isRead","comment":"Returns true if this segment is readable when loaded","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this segment is readable when loaded","type_short":"boolean"}},{"javadoc":"Returns true if this segment is writable when loaded\n@return true if this segment is writable when loaded","static":false,"name":"isWrite","comment":"Returns true if this segment is writable when loaded","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this segment is writable when loaded","type_short":"boolean"}},{"javadoc":"Returns true if this segment is executable when loaded\n@return true if this segment is executable when loaded","static":false,"name":"isExecute","comment":"Returns true if this segment is executable when loaded","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if this segment is executable when loaded","type_short":"boolean"}},{"javadoc":"Get the unadjusted memory size in bytes specified by this program header; it may be zero.\n@return the unadjusted memory size in bytes specified by this program header","static":false,"name":"getMemorySize","comment":"Get the unadjusted memory size in bytes specified by this program header; it may be zero.","params":[],"throws":[],"return":{"type_long":"long","comment":"the unadjusted memory size in bytes specified by this program header","type_short":"long"}},{"javadoc":"Get the adjusted memory size in bytes of the memory block which relates to this program header; it may be zero\n if no block should be created.  The returned value reflects any adjustment the ElfExtension may require\n based upon the specific processor\/language implementation which may require filtering of file bytes\n as loaded into memory.\n@return the number of bytes in the resulting memory block","static":false,"name":"getAdjustedMemorySize","comment":"Get the adjusted memory size in bytes of the memory block which relates to this program header; it may be zero\n if no block should be created.  The returned value reflects any adjustment the ElfExtension may require\n based upon the specific processor\/language implementation which may require filtering of file bytes\n as loaded into memory.","params":[],"throws":[],"return":{"type_long":"long","comment":"the number of bytes in the resulting memory block","type_short":"long"}},{"javadoc":"Get the adjusted file load size (i.e., filtered load size) to be loaded into memory block which relates to \n this program header; it may be zero if no block should be created.  The returned value reflects any adjustment \n the ElfExtension may require based upon the specific processor\/language implementation which may \n require filtering of file bytes as loaded into memory.\n@return the number of bytes to be loaded into the resulting memory block","static":false,"name":"getAdjustedLoadSize","comment":"Get the adjusted file load size (i.e., filtered load size) to be loaded into memory block which relates to \n this program header; it may be zero if no block should be created.  The returned value reflects any adjustment \n the ElfExtension may require based upon the specific processor\/language implementation which may \n require filtering of file bytes as loaded into memory.","params":[],"throws":[],"return":{"type_long":"long","comment":"the number of bytes to be loaded into the resulting memory block","type_short":"long"}},{"javadoc":"Returns the binary reader.\n@return the binary reader","static":false,"name":"getReader","comment":"Returns the binary reader.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.BinaryReader","comment":"the binary reader","type_short":"BinaryReader"}},{"javadoc":"This member gives the offset from the beginning of the file at which \n the first byte of the segment resides.\n@return the offset from the beginning of the file","static":false,"name":"getOffset","comment":"This member gives the offset from the beginning of the file at which \n the first byte of the segment resides.","params":[],"throws":[],"return":{"type_long":"long","comment":"the offset from the beginning of the file","type_short":"long"}},{"javadoc":"Compute the file offset associated with the specified loaded virtual address \n defined by this PT_LOAD program header.  This can be useful when attempting to locate\n addresses defined by the PT_DYNAMIC section.\n@param virtualAddress a memory address which has already had the PRElink adjustment applied\n@return computed file offset or -1 if virtual address not contained within this header\n@see ElfHeader#getProgramLoadHeaderContaining(long) for obtaining PT_LOAD segment which contains\n virtualAddress","static":false,"name":"getOffset","comment":"Compute the file offset associated with the specified loaded virtual address \n defined by this PT_LOAD program header.  This can be useful when attempting to locate\n addresses defined by the PT_DYNAMIC section.","params":[{"type_long":"long","name":"virtualAddress","comment":"a memory address which has already had the PRElink adjustment applied","type_short":"long"}],"throws":[],"return":{"type_long":"long","comment":"computed file offset or -1 if virtual address not contained within this header","type_short":"long"}},{"javadoc":"Set the offset. This value is the byte offset into\n the ELF file.\n@param offset the new offset value","static":false,"name":"setOffset","comment":"Set the offset. This value is the byte offset into\n the ELF file.","params":[{"type_long":"long","name":"offset","comment":"the new offset value","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the file and memory size.\n Note: the file size can be less than or\n equal to the memory size. It cannot be larger.\n If the file size is less than the memory size,\n then the rest of the space is considered to be\n uninitialized.\n@param fileSize the new file size\n@param memSize the new memory size","static":false,"name":"setSize","comment":"Sets the file and memory size.\n Note: the file size can be less than or\n equal to the memory size. It cannot be larger.\n If the file size is less than the memory size,\n then the rest of the space is considered to be\n uninitialized.","params":[{"type_long":"long","name":"fileSize","comment":"the new file size","type_short":"long"},{"type_long":"long","name":"memSize","comment":"the new memory size","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"On systems for which physical addressing is relevant, this member is reserved for the\n segment's physical address. Because System V ignores physical addressing for application\n programs, this member has unspecified contents for executable files and shared objects.\n@return the segment's physical address","static":false,"name":"getPhysicalAddress","comment":"On systems for which physical addressing is relevant, this member is reserved for the\n segment's physical address. Because System V ignores physical addressing for application\n programs, this member has unspecified contents for executable files and shared objects.","params":[],"throws":[],"return":{"type_long":"long","comment":"the segment's physical address","type_short":"long"}},{"javadoc":"This member tells what kind of segment this array element describes or how to interpret\n the array element's information. Type values and their meanings appear below.\n@return the program header type","static":false,"name":"getType","comment":"This member tells what kind of segment this array element describes or how to interpret\n the array element's information. Type values and their meanings appear below.","params":[],"throws":[],"return":{"type_long":"int","comment":"the program header type","type_short":"int"}},{"javadoc":"This member gives the virtual address at which the first \n byte of the segment resides in memory.\n@return the virtual address","static":false,"name":"getVirtualAddress","comment":"This member gives the virtual address at which the first \n byte of the segment resides in memory.","params":[],"throws":[],"return":{"type_long":"long","comment":"the virtual address","type_short":"long"}},{"javadoc":"@see ghidra.app.util.bin.StructConverter#toDataType()","static":false,"name":"toDataType","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"","static":false,"name":"getTypeDataType","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}},{"javadoc":"Sets the new physical and virtual addresses\n@param paddr the new physical address\n@param vaddr the new virtual address","static":false,"name":"setAddress","comment":"Sets the new physical and virtual addresses","params":[{"type_long":"long","name":"paddr","comment":"the new physical address","type_short":"long"},{"type_long":"long","name":"vaddr","comment":"the new virtual address","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"@see java.lang.Comparable#compareTo(java.lang.Object)","static":false,"name":"compareTo","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"that","comment":"","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"hashCode","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"equals","comment":"","params":[{"type_long":"java.lang.Object","name":"obj","comment":"","type_short":"Object"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"ElfProgramHeader","comment":"An executable or shared object file's program header table is an \n array of structures, each describing a segment\n or other information the system needs to prepare the program for execution. \n An object file segment contains one or more sections. \n Program headers are meaningful only for executable \n and shared object files. A file specifies its \n own program header size with the ELF\n header's e_phentsize and e_phnum members.\n Some entries describe process segments; others give supplementary information and do not contribute to\n the process image. Segment entries may appear in any order. Except for PT_LOAD segment \n entries which must appear in ascending order, sorted on the p_vaddr member.\n \n \n typedef struct {\n     Elf32_Word   p_type;\n     Elf32_Off    p_offset;\n     Elf32_Addr   p_vaddr;\n     Elf32_Addr   p_paddr;\n     Elf32_Word   p_filesz;\n     Elf32_Word   p_memsz;\n     Elf32_Word   p_flags;\n     Elf32_Word   p_align;\n } Elf32_Phdr;\n \n typedef struct {\n     Elf64_Word   p_type;         \/\/Segment type\n     Elf64_Word   p_flags;        \/\/Segment flags\n     Elf64_Off    p_offset;       \/\/Segment file offset\n     Elf64_Addr   p_vaddr;        \/\/Segment virtual address\n     Elf64_Addr   p_paddr;        \/\/Segment physical address\n     Elf64_Xword  p_filesz;       \/\/Segment size in file\n     Elf64_Xword  p_memsz;        \/\/Segment size in memory\n     Elf64_Xword  p_align;        \/\/Segment alignment\n } Elf64_Phdr;\n ","fields":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","javadoc":"","static":false,"name":"header","comment":"","type_short":"ElfHeader","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"p_type","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"p_flags","comment":"","type_short":"int","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"p_offset","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"p_vaddr","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"p_paddr","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"p_filesz","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"p_memsz","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"p_align","comment":"","type_short":"long","constant_value":null},{"type_long":"ghidra.app.util.bin.format.FactoryBundledWithBinaryReader","javadoc":"","static":false,"name":"reader","comment":"","type_short":"FactoryBundledWithBinaryReader","constant_value":null}]}
