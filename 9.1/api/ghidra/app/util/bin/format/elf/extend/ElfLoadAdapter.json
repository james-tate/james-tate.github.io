{"implements":[],"javadoc":"<code>ElfLoadAdapter<\/code> provides the base ELF load adapter implementation \n which may be extended to facilitate target specific behavior.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add all extension specific Dynamic table entry types (e.g., DT_ prefix).\n This method will add all those statically defined ElfDynamicType fields\n within this class.\n@param dynamicTypeMap map to which ElfDynamicType definitions should be added","static":false,"name":"addDynamicTypes","comment":"Add all extension specific Dynamic table entry types (e.g., DT_ prefix).\n This method will add all those statically defined ElfDynamicType fields\n within this class.","params":[{"type_long":"java.util.Map<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfDynamicType>","name":"dynamicTypeMap","comment":"map to which ElfDynamicType definitions should be added","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add all extension specific Program Header types (e.g., PT_ prefix).\n This method will add all those statically defined ElfProgramHeaderType fields\n within this class.\n@param programHeaderTypeMap map to which ElfProgramHeaderType definitions should be added","static":false,"name":"addProgramHeaderTypes","comment":"Add all extension specific Program Header types (e.g., PT_ prefix).\n This method will add all those statically defined ElfProgramHeaderType fields\n within this class.","params":[{"type_long":"java.util.Map<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfProgramHeaderType>","name":"programHeaderTypeMap","comment":"map to which ElfProgramHeaderType definitions should be added","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add all extension specific Section Header types (e.g., SHT_ prefix).\n This method will add all those statically defined ElfSectionHeaderType fields\n within this class.\n@param sectionHeaderTypeMap map to which ElfSectionHeaderType definitions should be added","static":false,"name":"addSectionHeaderTypes","comment":"Add all extension specific Section Header types (e.g., SHT_ prefix).\n This method will add all those statically defined ElfSectionHeaderType fields\n within this class.","params":[{"type_long":"java.util.HashMap<java.lang.Integer,ghidra.app.util.bin.format.elf.ElfSectionHeaderType>","name":"sectionHeaderTypeMap","comment":"map to which ElfSectionHeaderType definitions should be added","type_short":"HashMap"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Get the preferred load address space for an allocated program segment.\n The OTHER space is reserved and should not be returned by this method.\n@param elfLoadHelper load helper object\n@param elfProgramHeader elf program segment header\n@return preferred load address space","static":false,"name":"getPreferredSegmentAddressSpace","comment":"Get the preferred load address space for an allocated program segment.\n The OTHER space is reserved and should not be returned by this method.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"elfProgramHeader","comment":"elf program segment header","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"preferred load address space","type_short":"AddressSpace"}},{"javadoc":"Get the preferred load address for a program segment\n@param elfLoadHelper load helper object\n@param elfProgramHeader elf program segment header\n@return preferred load address","static":false,"name":"getPreferredSegmentAddress","comment":"Get the preferred load address for a program segment","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"elfProgramHeader","comment":"elf program segment header","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"preferred load address","type_short":"Address"}},{"javadoc":"Get the default alignment within the default address space.\n@param load helper object\n@return default alignment within the default address space.","static":false,"name":"getDefaultAlignment","comment":"Get the default alignment within the default address space.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"","type_short":"ElfLoadHelper"}],"throws":[],"return":{"type_long":"int","comment":"default alignment within the default address space.","type_short":"int"}},{"javadoc":"Get the preferred load address space for an allocated section.   The OTHER space\n is reserved and should not be returned by this method.\n@param elfLoadHelper load helper object\n@param elfSectionHeader elf section header\n@return preferred load address space","static":false,"name":"getPreferredSectionAddressSpace","comment":"Get the preferred load address space for an allocated section.   The OTHER space\n is reserved and should not be returned by this method.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"elfSectionHeader","comment":"elf section header","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSpace","comment":"preferred load address space","type_short":"AddressSpace"}},{"javadoc":"Get the preferred load address for an allocated program section.\n@param elfLoadHelper load helper object\n@param elfSectionHeader elf program section header\n@return preferred load address","static":false,"name":"getPreferredSectionAddress","comment":"Get the preferred load address for an allocated program section.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"elfSectionHeader","comment":"elf program section header","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"preferred load address","type_short":"Address"}},{"javadoc":"Check if this extension can handle the specified elf header.  If this method returns \n true, this extension will be used to obtain extended types definitions and to perform\n additional load processing.\n@param elf elf header\n@return true if this extension should be used when loading the elf image which\n corresponds to the specified header.","static":false,"name":"canHandle","comment":"Check if this extension can handle the specified elf header.  If this method returns \n true, this extension will be used to obtain extended types definitions and to perform\n additional load processing.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"elf","comment":"elf header","type_short":"ElfHeader"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this extension should be used when loading the elf image which\n corresponds to the specified header.","type_short":"boolean"}},{"javadoc":"Check if this extension can handle the specified elf image.  This method can provide\n a more accurate check based upon the actual language utilized.  While the ELF header\n may have stipulated a specific processor via the machine-id, a completely different\n and incompatible language may have been used.\n@param elf elf header\n@return true if this extension can properly support the ELF header and the \n current program\/language.","static":false,"name":"canHandle","comment":"Check if this extension can handle the specified elf image.  This method can provide\n a more accurate check based upon the actual language utilized.  While the ELF header\n may have stipulated a specific processor via the machine-id, a completely different\n and incompatible language may have been used.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"","type_short":"ElfLoadHelper"}],"throws":[],"return":{"type_long":"boolean","comment":"true if this extension can properly support the ELF header and the \n current program\/language.","type_short":"boolean"}},{"javadoc":"Return the data type naming suffix which should be used when creating types derived \n from data supplied by this extension.\n@return type naming suffix or null","static":false,"name":"getDataTypeSuffix","comment":"Return the data type naming suffix which should be used when creating types derived \n from data supplied by this extension.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"type naming suffix or null","type_short":"String"}},{"javadoc":"Perform extension specific processing of Elf image during program load.\n The following loading steps will have already been completed:\n <pre>\n 1. default processing of all program headers and section headers\n 2. memory resolution and loading of all program headers and section headers\n 3. Markup completed of Elf header, program headers, section headers, dynamic table,\n    string tables, and symbol tables.\n <\/pre>\n Markup and application of relocation tables will NOT have been done yet.\n@param elfLoadHelper load helper object\n@param monitor\n@throws CancelledException","static":false,"name":"processElf","comment":"Perform extension specific processing of Elf image during program load.\n The following loading steps will have already been completed:\n \n 1. default processing of all program headers and section headers\n 2. memory resolution and loading of all program headers and section headers\n 3. Markup completed of Elf header, program headers, section headers, dynamic table,\n    string tables, and symbol tables.\n \n Markup and application of relocation tables will NOT have been done yet.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Perform extension specific processing of Elf GOT\/PLT tables and any other \n related function relocation mechanism (e.g., function descriptors, etc) after\n normal REL\/RELA relocation fix-ups have been applied.\n@param elfLoadHelper load helper object\n@param monitor\n@throws CancelledException","static":false,"name":"processGotPlt","comment":"Perform extension specific processing of Elf GOT\/PLT tables and any other \n related function relocation mechanism (e.g., function descriptors, etc) after\n normal REL\/RELA relocation fix-ups have been applied.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Prior to the ELF loader creating a function this method will be invoked to permit an \n extension to adjust the address and\/or apply context to the intended location.\n@param elfLoadHelper load helper object\n@param functionAddress function address\n@return adjusted function address (required)","static":false,"name":"creatingFunction","comment":"Prior to the ELF loader creating a function this method will be invoked to permit an \n extension to adjust the address and\/or apply context to the intended location.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.program.model.address.Address","name":"functionAddress","comment":"function address","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"adjusted function address (required)","type_short":"Address"}},{"javadoc":"During symbol processing this method will be invoked to permit an extension to\n adjust the address and\/or apply context to the intended symbol location.\n@param elfLoadHelper load helper object\n@param elfSymbol elf symbol\n@param address program memory address where symbol will be created\n@param isExternal true if symbol treated as external to the program and has been\n assigned a fake memory address in the EXTERNAL memory block.\n@return adjusted symbol address or null if extension will handle applying the elfSymbol\n to the program (must also invoke {@link ElfLoadHelper#setElfSymbolAddress(ElfSymbol, Address)},\n or symbol should not be applied.","static":false,"name":"evaluateElfSymbol","comment":"During symbol processing this method will be invoked to permit an extension to\n adjust the address and\/or apply context to the intended symbol location.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"load helper object","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.elf.ElfSymbol","name":"elfSymbol","comment":"elf symbol","type_short":"ElfSymbol"},{"type_long":"ghidra.program.model.address.Address","name":"address","comment":"program memory address where symbol will be created","type_short":"Address"},{"type_long":"boolean","name":"isExternal","comment":"true if symbol treated as external to the program and has been\n assigned a fake memory address in the EXTERNAL memory block.","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.Address","comment":"adjusted symbol address or null if extension will handle applying the elfSymbol\n to the program (must also invoke ElfLoadHelper#setElfSymbolAddress(ElfSymbol, Address),\n or symbol should not be applied.","type_short":"Address"}},{"javadoc":"Get the write permission for the specified segment.\n@param segment program header object\n@return true if write enabled, else false or null to use standard Elf program header\n flags to make the determination.","static":false,"name":"isSegmentWritable","comment":"Get the write permission for the specified segment.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"segment","comment":"program header object","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"java.lang.Boolean","comment":"true if write enabled, else false or null to use standard Elf program header\n flags to make the determination.","type_short":"Boolean"}},{"javadoc":"Get the read permission for the specified segment.\n@param segment program header object\n@return true if read enabled, else false or null to use standard Elf program header\n flags to make the determination.","static":false,"name":"isSegmentReadable","comment":"Get the read permission for the specified segment.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"segment","comment":"program header object","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"java.lang.Boolean","comment":"true if read enabled, else false or null to use standard Elf program header\n flags to make the determination.","type_short":"Boolean"}},{"javadoc":"Get the execute permission for the specified segment.\n@param segment program header object\n@return true if execute enabled, else false or null to use standard Elf program header\n flags to make the determination.","static":false,"name":"isSegmentExecutable","comment":"Get the execute permission for the specified segment.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"segment","comment":"program header object","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"java.lang.Boolean","comment":"true if execute enabled, else false or null to use standard Elf program header\n flags to make the determination.","type_short":"Boolean"}},{"javadoc":"Get the write permission for the specified section.\n@param section section header object\n@return true if write enabled, else false or null to use standard Elf section\n flags to make the determination.","static":false,"name":"isSectionWritable","comment":"Get the write permission for the specified section.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"section header object","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"java.lang.Boolean","comment":"true if write enabled, else false or null to use standard Elf section\n flags to make the determination.","type_short":"Boolean"}},{"javadoc":"Get the execute permission for the specified section (i.e., instructions permitted).\n@param section section header object\n@return true if execute enabled, else false or null to use standard Elf section\n flags to make the determination.","static":false,"name":"isSectionExecutable","comment":"Get the execute permission for the specified section (i.e., instructions permitted).","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"section header object","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"java.lang.Boolean","comment":"true if execute enabled, else false or null to use standard Elf section\n flags to make the determination.","type_short":"Boolean"}},{"javadoc":"Determine if the specified section is \"allocated\" within memory.\n@param section section header object\n@return true if section should be allocated, else false or null to use standard Elf section\n flags to make the determination.","static":false,"name":"isSectionAllocated","comment":"Determine if the specified section is \"allocated\" within memory.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"section header object","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"java.lang.Boolean","comment":"true if section should be allocated, else false or null to use standard Elf section\n flags to make the determination.","type_short":"Boolean"}},{"javadoc":"Return the memory bytes to be loaded from the underlying file for the specified program header.\n The returned value will be consistent with any byte filtering which may be required.\n@param elfProgramHeader\n@return preferred memory block size in bytes which corresponds to the specified program header","static":false,"name":"getAdjustedLoadSize","comment":"Return the memory bytes to be loaded from the underlying file for the specified program header.\n The returned value will be consistent with any byte filtering which may be required.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"elfProgramHeader","comment":"","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"long","comment":"preferred memory block size in bytes which corresponds to the specified program header","type_short":"long"}},{"javadoc":"Return the memory segment size in bytes for the specified program header.\n The returned value will be consistent with any byte filtering which may be required.\n@param elfProgramHeader\n@return preferred memory block size in bytes which corresponds to the specified program header","static":false,"name":"getAdjustedMemorySize","comment":"Return the memory segment size in bytes for the specified program header.\n The returned value will be consistent with any byte filtering which may be required.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfProgramHeader","name":"elfProgramHeader","comment":"","type_short":"ElfProgramHeader"}],"throws":[],"return":{"type_long":"long","comment":"preferred memory block size in bytes which corresponds to the specified program header","type_short":"long"}},{"javadoc":"Get the dynamic memory block allocation alignment as addressable units\n within the default memory space.\n@return dynamic memory block allocation alignment.","static":false,"name":"getLinkageBlockAlignment","comment":"Get the dynamic memory block allocation alignment as addressable units\n within the default memory space.","params":[],"throws":[],"return":{"type_long":"int","comment":"dynamic memory block allocation alignment.","type_short":"int"}},{"javadoc":"Get the preferred free range size for the EXTERNAL memory block as addressable units\n within the default memory space.\n@return minimum free range size for EXTERNAL memory block as addressable units","static":false,"name":"getPreferredExternalBlockSize","comment":"Get the preferred free range size for the EXTERNAL memory block as addressable units\n within the default memory space.","params":[],"throws":[],"return":{"type_long":"int","comment":"minimum free range size for EXTERNAL memory block as addressable units","type_short":"int"}},{"javadoc":"Get reserve size of the EXTERNAL memory block as addressable units\n within the default memory space.  This size represents the largest \n expansion size to the block which could occur during relocation\n processing.\n@return reserve size of the EXTERNAL memory block as addressable units","static":false,"name":"getExternalBlockReserveSize","comment":"Get reserve size of the EXTERNAL memory block as addressable units\n within the default memory space.  This size represents the largest \n expansion size to the block which could occur during relocation\n processing.","params":[],"throws":[],"return":{"type_long":"int","comment":"reserve size of the EXTERNAL memory block as addressable units","type_short":"int"}},{"javadoc":"Return the memory section size in bytes for the specified section header.\n The returned value will be consistent with any byte filtering which may be required.\n@param ElfSectionHeader\n@return preferred memory block size in bytes which corresponds to the specified section header","static":false,"name":"getAdjustedSize","comment":"Return the memory section size in bytes for the specified section header.\n The returned value will be consistent with any byte filtering which may be required.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfSectionHeader","name":"section","comment":"","type_short":"ElfSectionHeader"}],"throws":[],"return":{"type_long":"long","comment":"preferred memory block size in bytes which corresponds to the specified section header","type_short":"long"}},{"javadoc":"Return filtered InputStream for loading a memory block (includes non-loaded OTHER blocks).\n NOTE: If this method is overriden, the {@link #hasFilteredLoadInputStream(ElfLoadHelper, MemoryLoadable, Address)}\n must also be overriden in a consistent fashion.\n@param elfLoadHelper\n@param loadable Corresponding ElfSectionHeader or ElfProgramHeader for the memory block to be created.\n@param start memory load address\n@param dataLength the in-memory data length in bytes (actual bytes read from dataInput may be more)\n@param dataInput the source input stream\n@return filtered input stream or original input stream","static":false,"name":"getFilteredLoadInputStream","comment":"Return filtered InputStream for loading a memory block (includes non-loaded OTHER blocks).\n NOTE: If this method is overriden, the #hasFilteredLoadInputStream(ElfLoadHelper, MemoryLoadable, Address)\n must also be overriden in a consistent fashion.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"loadable","comment":"Corresponding ElfSectionHeader or ElfProgramHeader for the memory block to be created.","type_short":"MemoryLoadable"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"memory load address","type_short":"Address"},{"type_long":"long","name":"dataLength","comment":"the in-memory data length in bytes (actual bytes read from dataInput may be more)","type_short":"long"},{"type_long":"java.io.InputStream","name":"dataInput","comment":"the source input stream","type_short":"InputStream"}],"throws":[],"return":{"type_long":"java.io.InputStream","comment":"filtered input stream or original input stream","type_short":"InputStream"}},{"javadoc":"Determine if the use of {@link #getFilteredLoadInputStream(ElfLoadHelper, MemoryLoadable, Address, long, InputStream)} \n is required when loading a memory block.  If a filtered input stream is required this will prevent the use of a direct \n mapping to file bytes.\n@param elfLoadHelper\n@param loadable Corresponding ElfSectionHeader or ElfProgramHeader for the memory block to be loaded.\n@param start memory load address\n@return true if the use of a filtered input stream is required","static":false,"name":"hasFilteredLoadInputStream","comment":"Determine if the use of #getFilteredLoadInputStream(ElfLoadHelper, MemoryLoadable, Address, long, InputStream) \n is required when loading a memory block.  If a filtered input stream is required this will prevent the use of a direct \n mapping to file bytes.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfLoadHelper","name":"elfLoadHelper","comment":"","type_short":"ElfLoadHelper"},{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"loadable","comment":"Corresponding ElfSectionHeader or ElfProgramHeader for the memory block to be loaded.","type_short":"MemoryLoadable"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"memory load address","type_short":"Address"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the use of a filtered input stream is required","type_short":"boolean"}},{"javadoc":"Get the ElfRelocation class which should be used to properly parse\n the relocation tables.\n@param elfHeader ELF header object (for header field access only)\n@return ElfRelocation class or null for default behavior","static":false,"name":"getRelocationClass","comment":"Get the ElfRelocation class which should be used to properly parse\n the relocation tables.","params":[{"type_long":"ghidra.app.util.bin.format.elf.ElfHeader","name":"elfHeader","comment":"ELF header object (for header field access only)","type_short":"ElfHeader"}],"throws":[],"return":{"type_long":"java.lang.Class<? extends ghidra.app.util.bin.format.elf.ElfRelocation>","comment":"ElfRelocation class or null for default behavior","type_short":"Class"}}],"name":"ElfLoadAdapter","comment":"ElfLoadAdapter provides the base ELF load adapter implementation \n which may be extended to facilitate target specific behavior.","fields":[]}
