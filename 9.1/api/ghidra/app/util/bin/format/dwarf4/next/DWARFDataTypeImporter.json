{"implements":[],"javadoc":"Creates Ghidra {@link DataType}s using information from DWARF debug entries.  The caller\n is responsible for writing the resulting temporary DataType instances into the database.\n <p>\n Create a new instance of this class for each {@link DIEAggregate} datatype that you wish\n to convert into a DataType.\n <p>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Create a new data type importer.\n@param prog {@link DWARFProgram} that is being imported\n@param dwarfDTM {@link DWARFDataTypeManager} helper\n@param importOptions {@link DWARFImportOptions} control optional features during import","static":false,"name":"<init>","comment":"Create a new data type importer.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFProgram","name":"prog","comment":"DWARFProgram that is being imported","type_short":"DWARFProgram"},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeManager","name":"dwarfDTM","comment":"DWARFDataTypeManager helper","type_short":"DWARFDataTypeManager"},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFImportOptions","name":"importOptions","comment":"DWARFImportOptions control optional features during import","type_short":"DWARFImportOptions"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getDDTByInstance","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dtInstance","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"","static":false,"name":"trackRecursion","comment":"","params":[{"type_long":"long","name":"id","comment":"","type_short":"long"},{"type_long":"int","name":"delta","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Converts the specified DWARF debug entry into a Ghidra {@link DataType} (wrapped\n in a simple holder object to also return associated metadata).\n@param diea DWARF {@link DIEAggregate} to convert into Ghidra DataType.\n@param defaultValue value to return if the specified DIEA is null or there is a problem\n with the DWARF debug data.\n@return a {@link DWARFDataType} wrapper around the new Ghidra {@link DataType}.\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"getDataType","comment":"Converts the specified DWARF debug entry into a Ghidra DataType (wrapped\n in a simple holder object to also return associated metadata).","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"DWARF DIEAggregate to convert into Ghidra DataType.","type_short":"DIEAggregate"},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"defaultValue","comment":"value to return if the specified DIEA is null or there is a problem\n with the DWARF debug data.","type_short":"DWARFDataType"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"a DWARFDataType wrapper around the new Ghidra DataType.","type_short":"DWARFDataType"}},{"javadoc":"","static":false,"name":"updateMapping","comment":"","params":[{"type_long":"ghidra.program.model.data.DataType","name":"prevDT","comment":"","type_short":"DataType"},{"type_long":"ghidra.program.model.data.DataType","name":"newDT","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"recordTempDataType","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"makeDataTypeForFunctionDefinition","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"},{"type_long":"boolean","name":"mangleAnonFuncNames","comment":"","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Gets the corresponding Ghidra base type.\n <p>\n@param diea\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"makeDataTypeForBaseType","comment":"Gets the corresponding Ghidra base type.\n ","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Simple passthru, returns whatever type this \"const\" modifier applies to.\n <p>\n@param diea\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"makeDataTypeForConst","comment":"Simple passthru, returns whatever type this \"const\" modifier applies to.\n ","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Mash parameter datatype names together to make a mangling suffix to append to\n a function def name.\n <p>\n@param returnTypeDT\n@param parameters\n@return ","static":false,"name":"getMangledFuncDefName","comment":"Mash parameter datatype names together to make a mangling suffix to append to\n a function def name.\n ","params":[{"type_long":"ghidra.program.model.data.DataType","name":"returnTypeDT","comment":"","type_short":"DataType"},{"type_long":"java.util.List<ghidra.program.model.data.ParameterDefinition>","name":"parameters","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"mangleDTName","comment":"","params":[{"type_long":"java.lang.String","name":"s","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Creates a Ghidra {@link Enum} datatype.\n <p>\n If an existing Enum with the same name is found in the DTM, and it doesn't have\n any conflicting enum values, merge this enum into the existing enum.\n <p>\n This method takes liberties with the normal DWARF->Ghidra Impl DataType->Ghidra DB DataType\n workflow to be able to merge values into previous db enum datatypes.\n <p>\n@param diea\n@return ","static":false,"name":"makeDataTypeForEnum","comment":"Creates a Ghidra Enum datatype.\n \n If an existing Enum with the same name is found in the DTM, and it doesn't have\n any conflicting enum values, merge this enum into the existing enum.\n \n This method takes liberties with the normal DWARF-Ghidra Impl DataType-Ghidra DB DataType\n workflow to be able to merge values into previous db enum datatypes.\n ","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"","static":false,"name":"populateStubEnum","comment":"","params":[{"type_long":"ghidra.program.model.data.Enum","name":"enumDT","comment":"","type_short":"Enum"},{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"mergeEnumValues","comment":"","params":[{"type_long":"ghidra.program.model.data.Enum","name":"destEnum","comment":"","type_short":"Enum"},{"type_long":"ghidra.program.model.data.Enum","name":"srcEnum","comment":"","type_short":"Enum"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if there are no values in destEnum that conflict with srcEnum.\n@param srcEnum\n@param destEnum\n@return ","static":false,"name":"isCompatEnumValues","comment":"Returns true if there are no values in destEnum that conflict with srcEnum.","params":[{"type_long":"ghidra.program.model.data.Enum","name":"srcEnum","comment":"","type_short":"Enum"},{"type_long":"ghidra.program.model.data.Enum","name":"destEnum","comment":"","type_short":"Enum"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Creates an empty stub structure\/union for the DIEA.\n <p>\n Use {@link #finishStruct(DIEAggregate, DataType)} (which calls\n {@link #populateStubStruct(StructureDataType, DIEAggregate)} and\n {@link #populateStubEnum(Enum, DIEAggregate)}) to fill in the fields of the structure.\n <p>\n This is done in two steps to enable ending recursive loops by publishing the empty\n struct in the {@link #dieOffsetToDataTypeMap} map, where it will be found and returned by\n {@link #getDataTypeWorker(DIEAggregate, DataType)}, instead of calling back\n into this method.\n@param diea\n@return ","static":false,"name":"makeDataTypeForStruct","comment":"Creates an empty stub structure\/union for the DIEA.\n \n Use #finishStruct(DIEAggregate, DataType) (which calls\n #populateStubStruct(StructureDataType, DIEAggregate) and\n #populateStubEnum(Enum, DIEAggregate)) to fill in the fields of the structure.\n \n This is done in two steps to enable ending recursive loops by publishing the empty\n struct in the #dieOffsetToDataTypeMap map, where it will be found and returned by\n #getDataTypeWorker(DIEAggregate, DataType), instead of calling back\n into this method.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Returns true if the DWARF struct is larger than Ghidra allows (ie. bigger than MAX_INT).\n@param structSize long int size of the DWARF struct\n@return true if bigger than Ghidra can handle","static":false,"name":"isStructTooBigForGhidra","comment":"Returns true if the DWARF struct is larger than Ghidra allows (ie. bigger than MAX_INT).","params":[{"type_long":"long","name":"structSize","comment":"long int size of the DWARF struct","type_short":"long"}],"throws":[],"return":{"type_long":"boolean","comment":"true if bigger than Ghidra can handle","type_short":"boolean"}},{"javadoc":"Populates stub structs or unions with there fields.\n@param diea\n@param dataType\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"finishStruct","comment":"Populates stub structs or unions with there fields.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Populates an empty {@link UnionDataType} with its fields.\n@param union\n@param diea\n@param rec\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"populateStubUnion","comment":"Populates an empty UnionDataType with its fields.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"},{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Populates an empty {@link StructureDataType} with its fields.\n@param structure\n@param diea\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"populateStubStruct","comment":"Populates an empty StructureDataType with its fields.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"},{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Restore structure fields to their regular size (if there is room) to ensure\n future DataType equiv and comparisons are successful.\n <p>\n (ie. undoes {@link #getUnpaddedDataTypeLength(DataType)} if there is room)\n@param structure","static":false,"name":"removeUneededStructMemberShrinkage","comment":"Restore structure fields to their regular size (if there is room) to ensure\n future DataType equiv and comparisons are successful.\n \n (ie. undoes #getUnpaddedDataTypeLength(DataType) if there is room)","params":[{"type_long":"ghidra.program.model.data.StructureDataType","name":"structure","comment":"","type_short":"StructureDataType"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Detect the real length of a DataType (ie. drop any trailing padding).\n@param dt\n@return ","static":false,"name":"getUnpaddedDataTypeLength","comment":"Detect the real length of a DataType (ie. drop any trailing padding).","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"","type_short":"DataType"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"populateStubStruct_worker","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"},{"type_long":"ghidra.program.model.data.StructureDataType","name":"structure","comment":"","type_short":"StructureDataType"},{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"},{"type_long":"int","name":"childTagType","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":true,"name":"memberDesc","comment":"","params":[{"type_long":"java.lang.String","name":"prefix","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"errorStr","comment":"","type_short":"String"},{"type_long":"java.lang.String","name":"memberName","comment":"","type_short":"String"},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"},{"type_long":"int","name":"memberOffset","comment":"","type_short":"int"},{"type_long":"int","name":"bitSize","comment":"","type_short":"int"},{"type_long":"int","name":"bitOffset","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"Creates a Ghidra {@link ArrayDataType}.\n <p>\n Multi-dim DWARF arrays will result in nested Ghidra array types.\n <p>\n@param diea\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"makeDataTypeForArray","comment":"Creates a Ghidra ArrayDataType.\n \n Multi-dim DWARF arrays will result in nested Ghidra array types.\n ","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Creates a {@link Pointer} datatype.\n <p>\n If there is no pointer size specified in the DWARF DIE, use the default pointer size\n from the DWARF compilation unit.\n <p>\n There is some hacky logic here to handle situations where a pointer refers back to\n itself via a struct:\n <pre>\n PTRa\n   +-> STRUCT1 (creates empty struct)\n         +-> Field1: PTRa\n               +-> STRUCT1 (empty struct returned from cache)\n               ( ptr instance created pointing to empty struct)\n         ( struct fields populated )\n <\/pre>\n The struct creation code will stop the recursive loop after the second time\n makeDataTypeForPointer() is hit because there will be an empty struct in the cache.\n@param diea\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"makeDataTypeForPointer","comment":"Creates a Pointer datatype.\n \n If there is no pointer size specified in the DWARF DIE, use the default pointer size\n from the DWARF compilation unit.\n \n There is some hacky logic here to handle situations where a pointer refers back to\n itself via a struct:\n \n PTRa\n   +- STRUCT1 (creates empty struct)\n         +- Field1: PTRa\n               +- STRUCT1 (empty struct returned from cache)\n               ( ptr instance created pointing to empty struct)\n         ( struct fields populated )\n \n The struct creation code will stop the recursive loop after the second time\n makeDataTypeForPointer() is hit because there will be an empty struct in the cache.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"","static":false,"name":"makeDataTypeForPtrToMemberType","comment":"","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Creates a {@link TypeDef} datatype.\n <p>\n If the typedef has the same name as the destination type, create an equiv mapping\n pointing to the destination and omit creating a Ghidra typedef.\n <p>\n If the typedef points (via a pointer) to a function definition type that doesn't\n have a name yet, update the function defintion with the name from this typedef\n and elide this typedef.\n@param diea\n@param rec\n@throws IOException\n@throws DWARFExpressionException","static":false,"name":"makeDataTypeForTypedef","comment":"Creates a TypeDef datatype.\n \n If the typedef has the same name as the destination type, create an equiv mapping\n pointing to the destination and omit creating a Ghidra typedef.\n \n If the typedef points (via a pointer) to a function definition type that doesn't\n have a name yet, update the function defintion with the name from this typedef\n and elide this typedef.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.app.util.bin.format.dwarf4.expression.DWARFExpressionException","comment":"","type_short":"DWARFExpressionException"}],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Creates a datatype representing the string in the unspecifiedtype dwarf definition.\n <p>\n Most likely will be a void type.\n@param diea\n@return ","static":false,"name":"makeDataTypeForUnspecifiedType","comment":"Creates a datatype representing the string in the unspecifiedtype dwarf definition.\n \n Most likely will be a void type.","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.DIEAggregate","name":"diea","comment":"","type_short":"DIEAggregate"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","comment":"","type_short":"DWARFDataType"}},{"javadoc":"Returns true if the specified {@link DataType} (or if its a pointer, the pointed to\n DataType) is a data type that did not have a name and was assigned an name in the form\n \"anon_datatype\".\n@param dt\n@return ","static":true,"name":"isAnonDataType","comment":"Returns true if the specified DataType (or if its a pointer, the pointed to\n DataType) is a data type that did not have a name and was assigned an name in the form\n \"anon_datatype\".","params":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","name":"ddt","comment":"","type_short":"DWARFDataType"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Copy an anon Datatype (or a chain of pointers to a anon DataType) into a new CategoryPath\n with a new name that is appropriate for a structure member field.\n <p>\n Use this method when a struct has a field with an anon datatype.  The new copied\n datatype will be called \"anonorigname_for_structurefieldname\"\n <p>\n@param dt - DataType to copy\n@param destCategory {@link CategoryPath} to copy to\n@param membername the name of the structure member that uses this anon datatype.\n@return new DataType that is a copy of the old type, but in a new location and name.","static":false,"name":"copyAnonTypeForMember","comment":"Copy an anon Datatype (or a chain of pointers to a anon DataType) into a new CategoryPath\n with a new name that is appropriate for a structure member field.\n \n Use this method when a struct has a field with an anon datatype.  The new copied\n datatype will be called \"anonorigname_for_structurefieldname\"\n ","params":[{"type_long":"ghidra.program.model.data.DataType","name":"dt","comment":"- DataType to copy","type_short":"DataType"},{"type_long":"ghidra.program.model.data.CategoryPath","name":"destCategory","comment":"CategoryPath to copy to","type_short":"CategoryPath"},{"type_long":"java.lang.String","name":"membername","comment":"the name of the structure member that uses this anon datatype.","type_short":"String"}],"throws":[],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"new DataType that is a copy of the old type, but in a new location and name.","type_short":"DataType"}}],"name":"DWARFDataTypeImporter","comment":"Creates Ghidra DataTypes using information from DWARF debug entries.  The caller\n is responsible for writing the resulting temporary DataType instances into the database.\n \n Create a new instance of this class for each DIEAggregate datatype that you wish\n to convert into a DataType.\n ","fields":[{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFProgram","javadoc":"","static":false,"name":"prog","comment":"","type_short":"DWARFProgram","constant_value":null},{"type_long":"ghidra.program.model.data.DataTypeManager","javadoc":"","static":false,"name":"dataTypeManager","comment":"","type_short":"DataTypeManager","constant_value":null},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeManager","javadoc":"","static":false,"name":"dwarfDTM","comment":"","type_short":"DWARFDataTypeManager","constant_value":null},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFImportOptions","javadoc":"","static":false,"name":"importOptions","comment":"","type_short":"DWARFImportOptions","constant_value":null},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType","javadoc":"","static":false,"name":"voidDDT","comment":"","type_short":"DWARFDataType","constant_value":null},{"type_long":"ghidra.app.util.bin.format.dwarf4.next.DWARFNameInfo","javadoc":"","static":false,"name":"rootDNI","comment":"","type_short":"DWARFNameInfo","constant_value":null},{"type_long":"java.util.Map<java.lang.Long,java.lang.Integer>","javadoc":"Tracks which {@link DIEAggregate DIEAs} have been visited by {@link #getDataTypeWorker(DIEAggregate, DataType)}\n during the current {@link #getDataType(DIEAggregate, DataType)} session.\n <p>\n Some recursive calls are permitted to handle loops in the data types, but are limited\n to 2 recursions.","static":false,"name":"recursionTrackingOffsetToLoopCount","comment":"Tracks which DIEAggregate have been visited by #getDataTypeWorker(DIEAggregate, DataType)\n during the current #getDataType(DIEAggregate, DataType) session.\n \n Some recursive calls are permitted to handle loops in the data types, but are limited\n to 2 recursions.","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<java.lang.Long,ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType>","javadoc":"Maps {@link DIEAggregate DIEA} offset to live {@link DataType} objects, for the\n current session of this importer.","static":false,"name":"dieOffsetToDataTypeMap","comment":"Maps DIEAggregate offset to live DataType objects, for the\n current session of this importer.","type_short":"Map","constant_value":null},{"type_long":"java.util.IdentityHashMap<ghidra.program.model.data.DataType,ghidra.app.util.bin.format.dwarf4.next.DWARFDataTypeImporter.DWARFDataType>","javadoc":"Maps {@link DataType} instances to the {@link DWARFDataType} record that\n holds metadata about this datatype during the current session.\n <p>\n This identity mapping doesn't always work because datatype instances are often clone()'d\n which will break this mapping.\n <p>\n Places where we know clone()ing happens the mapping is\n {@link #updateMapping(DataType, DataType) updated}.","static":false,"name":"dataTypeInstanceToDDTMap","comment":"Maps DataType instances to the DWARFDataType record that\n holds metadata about this datatype during the current session.\n \n This identity mapping doesn't always work because datatype instances are often clone()'d\n which will break this mapping.\n \n Places where we know clone()ing happens the mapping is\n #updateMapping(DataType, DataType).","type_short":"IdentityHashMap","constant_value":null}]}
