{"implements":["ghidra.app.util.bin.StructConverter"],"javadoc":"See Apple's -- PEFBinaryFormat.h\n <pre>\n struct PEFLoaderInfoHeader {\n     SInt32  mainSection;              \/\/ Section containing the main symbol, -1 => none.\n     UInt32  mainOffset;               \/\/ Offset of main symbol.\n     SInt32  initSection;              \/\/ Section containing the init routine's TVector, -1 => none.\n     UInt32  initOffset;               \/\/ Offset of the init routine's TVector.\n     SInt32  termSection;              \/\/ Section containing the term routine's TVector, -1 => none.\n     UInt32  termOffset;               \/\/ Offset of the term routine's TVector.\n     UInt32  importedLibraryCount;     \/\/ Number of imported libraries.  ('l')\n     UInt32  totalImportedSymbolCount; \/\/ Total number of imported symbols.  ('i')\n     UInt32  relocSectionCount;        \/\/ Number of sections with relocations.  ('r')\n     UInt32  relocInstrOffset;         \/\/ Offset of the relocation instructions.\n     UInt32  loaderStringsOffset;      \/\/ Offset of the loader string table.\n     UInt32  exportHashOffset;         \/\/ Offset of the export hash table.\n     UInt32  exportHashTablePower;     \/\/ Export hash table size as log 2.  (Log2('h'))\n     UInt32  exportedSymbolCount;      \/\/ Number of exported symbols.  ('e')\n };\n <\/pre>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.app.util.bin.BinaryReader","name":"reader","comment":"","type_short":"BinaryReader"},{"type_long":"ghidra.app.util.bin.format.pef.SectionHeader","name":"section","comment":"","type_short":"SectionHeader"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"The mainSection field (4 bytes) specifies the number \n of the section in this container that contains the main \n symbol. If the fragment does not have a main symbol, \n this field is set to -1.\n@return number of section containing main symbol","static":false,"name":"getMainSection","comment":"The mainSection field (4 bytes) specifies the number \n of the section in this container that contains the main \n symbol. If the fragment does not have a main symbol, \n this field is set to -1.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of section containing main symbol","type_short":"int"}},{"javadoc":"The mainOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the main symbol.\n@return offset to the main symbol","static":false,"name":"getMainOffset","comment":"The mainOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the main symbol.","params":[],"throws":[],"return":{"type_long":"int","comment":"offset to the main symbol","type_short":"int"}},{"javadoc":"The initSection field (4 bytes) contains the number of the \n section containing the initialization function's transition \n vector. If no initialization function exists, this field is set to -1.\n@return number of the section containing the initialization function's transition vector","static":false,"name":"getInitSection","comment":"The initSection field (4 bytes) contains the number of the \n section containing the initialization function's transition \n vector. If no initialization function exists, this field is set to -1.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of the section containing the initialization function's transition vector","type_short":"int"}},{"javadoc":"The initOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the initialization function's transition vector.\n@return offset to initialization function's transition vector","static":false,"name":"getInitOffset","comment":"The initOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the section to the initialization function's transition vector.","params":[],"throws":[],"return":{"type_long":"int","comment":"offset to initialization function's transition vector","type_short":"int"}},{"javadoc":"The termSection field (4 bytes) contains the number of the section containing \n the termination routine's transition vector. If no termination routine exists, \n this field is set to -1.\n@return number of the section containing the termination routine's transition vector","static":false,"name":"getTermSection","comment":"The termSection field (4 bytes) contains the number of the section containing \n the termination routine's transition vector. If no termination routine exists, \n this field is set to -1.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of the section containing the termination routine's transition vector","type_short":"int"}},{"javadoc":"The termOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the section to the termination routine's \n transition vector.\n@return offset to termination routine's transition vector","static":false,"name":"getTermOffset","comment":"The termOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the section to the termination routine's \n transition vector.","params":[],"throws":[],"return":{"type_long":"int","comment":"offset to termination routine's transition vector","type_short":"int"}},{"javadoc":"The importedLibraryCount field (4 bytes) indicates the \n number of imported libraries.\n@return number of imported libraries","static":false,"name":"getImportedLibraryCount","comment":"The importedLibraryCount field (4 bytes) indicates the \n number of imported libraries.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of imported libraries","type_short":"int"}},{"javadoc":"The totalImportedSymbolCount field (4 bytes) \n indicates the total number of imported symbols.\n@return number of imported symbols","static":false,"name":"getTotalImportedSymbolCount","comment":"The totalImportedSymbolCount field (4 bytes) \n indicates the total number of imported symbols.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of imported symbols","type_short":"int"}},{"javadoc":"The relocSectionCount field (4 bytes) indicates the \n number of sections containing load-time relocations.\n@return number of sections containing load-time relocations","static":false,"name":"getRelocSectionCount","comment":"The relocSectionCount field (4 bytes) indicates the \n number of sections containing load-time relocations.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of sections containing load-time relocations","type_short":"int"}},{"javadoc":"The relocInstrOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the loader section to the start of the relocations area.\n@return offset to the relocations","static":false,"name":"getRelocInstrOffset","comment":"The relocInstrOffset field (4 bytes) indicates the offset (in bytes) from the \n beginning of the loader section to the start of the relocations area.","params":[],"throws":[],"return":{"type_long":"int","comment":"offset to the relocations","type_short":"int"}},{"javadoc":"The loaderStringsOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader \n section to the start of the loader string table.\n@return offset to the loader string table","static":false,"name":"getLoaderStringsOffset","comment":"The loaderStringsOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader \n section to the start of the loader string table.","params":[],"throws":[],"return":{"type_long":"int","comment":"offset to the loader string table","type_short":"int"}},{"javadoc":"The exportHashOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader section \n to the start of the export hash table. The hash table should be 4-byte aligned \n with padding added if necessary.\n@return offset to the export hash table","static":false,"name":"getExportHashOffset","comment":"The exportHashOffset field (4 bytes) indicates the offset \n (in bytes) from the beginning of the loader section \n to the start of the export hash table. The hash table should be 4-byte aligned \n with padding added if necessary.","params":[],"throws":[],"return":{"type_long":"int","comment":"offset to the export hash table","type_short":"int"}},{"javadoc":"The exportHashTablePower field (4 bytes) indicates the \n number of hash index values (that is, the number of entries in the \n hash table). The number of entries is specified as a power of two. For example, \n a value of 0 indicates one entry, while a value of 2 indicates four entries. If \n no exports exist, the hash table still contains one entry, and the value of this \n field is 0.\n@return number of hash index values","static":false,"name":"getExportHashTablePower","comment":"The exportHashTablePower field (4 bytes) indicates the \n number of hash index values (that is, the number of entries in the \n hash table). The number of entries is specified as a power of two. For example, \n a value of 0 indicates one entry, while a value of 2 indicates four entries. If \n no exports exist, the hash table still contains one entry, and the value of this \n field is 0.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of hash index values","type_short":"int"}},{"javadoc":"The exportedSymbolCount field (4 bytes) indicates the number of \n symbols exported from this container.\n@return number of symbols exported from this container","static":false,"name":"getExportedSymbolCount","comment":"The exportedSymbolCount field (4 bytes) indicates the number of \n symbols exported from this container.","params":[],"throws":[],"return":{"type_long":"int","comment":"number of symbols exported from this container","type_short":"int"}},{"javadoc":"Returns the section corresponding to this loader.\n@return the section corresponding to this loader","static":false,"name":"getSection","comment":"Returns the section corresponding to this loader.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.pef.SectionHeader","comment":"the section corresponding to this loader","type_short":"SectionHeader"}},{"javadoc":"Finds the PEF library that contains the specified imported symbol index.\n@param loader the PEF loader info header\n@param symbolIndex the imported symbol index\n@return PEF library that contains the specified imported symbol index","static":false,"name":"findLibrary","comment":"Finds the PEF library that contains the specified imported symbol index.","params":[{"type_long":"int","name":"symbolIndex","comment":"the imported symbol index","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.format.pef.ImportedLibrary","comment":"PEF library that contains the specified imported symbol index","type_short":"ImportedLibrary"}},{"javadoc":"","static":false,"name":"getImportedLibraries","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ImportedLibrary>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getImportedSymbols","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ImportedSymbol>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getRelocations","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.LoaderRelocationHeader>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getExportedHashSlots","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ExportedSymbolHashSlot>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getExportedSymbolKeys","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ExportedSymbolKey>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"getExportedSymbols","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ExportedSymbol>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"toDataType","comment":"","params":[],"throws":[{"type_long":"ghidra.util.exception.DuplicateNameException","comment":"","type_short":"DuplicateNameException"},{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"ghidra.program.model.data.DataType","comment":"","type_short":"DataType"}}],"name":"LoaderInfoHeader","comment":"See Apple's -- PEFBinaryFormat.h\n \n struct PEFLoaderInfoHeader {\n     SInt32  mainSection;              \/\/ Section containing the main symbol, -1 = none.\n     UInt32  mainOffset;               \/\/ Offset of main symbol.\n     SInt32  initSection;              \/\/ Section containing the init routine's TVector, -1 = none.\n     UInt32  initOffset;               \/\/ Offset of the init routine's TVector.\n     SInt32  termSection;              \/\/ Section containing the term routine's TVector, -1 = none.\n     UInt32  termOffset;               \/\/ Offset of the term routine's TVector.\n     UInt32  importedLibraryCount;     \/\/ Number of imported libraries.  ('l')\n     UInt32  totalImportedSymbolCount; \/\/ Total number of imported symbols.  ('i')\n     UInt32  relocSectionCount;        \/\/ Number of sections with relocations.  ('r')\n     UInt32  relocInstrOffset;         \/\/ Offset of the relocation instructions.\n     UInt32  loaderStringsOffset;      \/\/ Offset of the loader string table.\n     UInt32  exportHashOffset;         \/\/ Offset of the export hash table.\n     UInt32  exportHashTablePower;     \/\/ Export hash table size as log 2.  (Log2('h'))\n     UInt32  exportedSymbolCount;      \/\/ Number of exported symbols.  ('e')\n };\n ","fields":[{"type_long":"int","javadoc":"","static":true,"name":"SIZEOF","comment":"","type_short":"int","constant_value":"56"},{"type_long":"ghidra.app.util.bin.format.pef.SectionHeader","javadoc":"","static":false,"name":"_section","comment":"","type_short":"SectionHeader","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"mainSection","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"mainOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"initSection","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"initOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"termSection","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"termOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"importedLibraryCount","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"totalImportedSymbolCount","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"relocSectionCount","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"relocInstrOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"loaderStringsOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"exportHashOffset","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"exportHashTablePower","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"exportedSymbolCount","comment":"","type_short":"int","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ImportedLibrary>","javadoc":"","static":false,"name":"_importedLibraries","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ImportedSymbol>","javadoc":"","static":false,"name":"_importedSymbols","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.LoaderRelocationHeader>","javadoc":"","static":false,"name":"_relocations","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ExportedSymbolHashSlot>","javadoc":"","static":false,"name":"_exportedHashSlots","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ExportedSymbolKey>","javadoc":"","static":false,"name":"_exportedSymbolKeys","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.bin.format.pef.ExportedSymbol>","javadoc":"","static":false,"name":"_exportedSymbols","comment":"","type_short":"List","constant_value":null}]}
