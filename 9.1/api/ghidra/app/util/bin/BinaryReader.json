{"implements":[],"javadoc":"A class for reading data from a\n generic byte provider in either big-endian or little-endian.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a reader using the given\n file and endian-order.\n\n If isLittleEndian is true, then all values read\n from the file will be done so assuming\n little-endian order.\n\n Otherwise, if isLittleEndian\n is false, then all values will be read\n assuming big-endian order.\n@param provider the byte provider\n@param isLittleEndian the endian-order","static":false,"name":"<init>","comment":"Constructs a reader using the given\n file and endian-order.\n\n If isLittleEndian is true, then all values read\n from the file will be done so assuming\n little-endian order.\n\n Otherwise, if isLittleEndian\n is false, then all values will be read\n assuming big-endian order.","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"the byte provider","type_short":"ByteProvider"},{"type_long":"boolean","name":"isLittleEndian","comment":"the endian-order","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a clone of this reader positioned at the new index.\n@param newIndex the new index\n@return a clone of this reader positioned at the new index","static":false,"name":"clone","comment":"Returns a clone of this reader positioned at the new index.","params":[{"type_long":"int","name":"newIndex","comment":"the new index","type_short":"int"}],"throws":[],"return":{"type_long":"ghidra.app.util.bin.BinaryReader","comment":"a clone of this reader positioned at the new index","type_short":"BinaryReader"}},{"javadoc":"Returns true if this reader will extract values in little endian,\n otherwise in big endian.\n@return true is little endian, false is big endian","static":false,"name":"isLittleEndian","comment":"Returns true if this reader will extract values in little endian,\n otherwise in big endian.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true is little endian, false is big endian","type_short":"boolean"}},{"javadoc":"Sets the endian of this binary reader.\n@param isLittleEndian true for little-endian and false for big-endian","static":false,"name":"setLittleEndian","comment":"Sets the endian of this binary reader.","params":[{"type_long":"boolean","name":"isLittleEndian","comment":"true for little-endian and false for big-endian","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the length of the underlying file.\n@return returns the length of the underlying file\n@exception IOException if an I\/O error occurs","static":false,"name":"length","comment":"Returns the length of the underlying file.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"returns the length of the underlying file","type_short":"long"}},{"javadoc":"Returns true if the specified index into\n the underlying byte provider is valid.\n@param index the index in the byte provider\n@return returns true if the specified index is valid\n@exception IOException if an I\/O error occurs","static":false,"name":"isValidIndex","comment":"Returns true if the specified index into\n the underlying byte provider is valid.","params":[{"type_long":"int","name":"index","comment":"the index in the byte provider","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"returns true if the specified index is valid","type_short":"boolean"}},{"javadoc":"Returns true if the specified index into\n the underlying byte provider is valid.\n@param index the index in the byte provider\n@return returns true if the specified index is valid\n@exception IOException if an I\/O error occurs","static":false,"name":"isValidIndex","comment":"Returns true if the specified index into\n the underlying byte provider is valid.","params":[{"type_long":"long","name":"index","comment":"the index in the byte provider","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"boolean","comment":"returns true if the specified index is valid","type_short":"boolean"}},{"javadoc":"Aligns the current index on the specified alignment value.\n For example, if current index was 123 and align value was\n 16, then current index would become 128.\n@param alignValue\n@return the number of bytes required to align","static":false,"name":"align","comment":"Aligns the current index on the specified alignment value.\n For example, if current index was 123 and align value was\n 16, then current index would become 128.","params":[{"type_long":"int","name":"alignValue","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"the number of bytes required to align","type_short":"int"}},{"javadoc":"A convenience method for setting the index using\n an integer.","static":false,"name":"setPointerIndex","comment":"A convenience method for setting the index using\n an integer.","params":[{"type_long":"int","name":"index","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the current index to the specified value.\n The pointer index will allow the reader\n to operate as a psuedo-iterator.\n@param index the byte provider index value","static":false,"name":"setPointerIndex","comment":"Sets the current index to the specified value.\n The pointer index will allow the reader\n to operate as a psuedo-iterator.","params":[{"type_long":"long","name":"index","comment":"the byte provider index value","type_short":"long"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the current index value.\n@return the current index value","static":false,"name":"getPointerIndex","comment":"Returns the current index value.","params":[],"throws":[],"return":{"type_long":"long","comment":"the current index value","type_short":"long"}},{"javadoc":"Peeks at the next byte without incrementing\n the current index.\n@return the next byte\n@exception IOException if an I\/O error occurs","static":false,"name":"peekNextByte","comment":"Peeks at the next byte without incrementing\n the current index.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte","comment":"the next byte","type_short":"byte"}},{"javadoc":"Peeks at the next short without incrementing\n the current index.\n@return the next short\n@exception IOException if an I\/O error occurs","static":false,"name":"peekNextShort","comment":"Peeks at the next short without incrementing\n the current index.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short","comment":"the next short","type_short":"short"}},{"javadoc":"Peeks at the next integer without incrementing\n the current index.\n@return the next int\n@exception IOException if an I\/O error occurs","static":false,"name":"peekNextInt","comment":"Peeks at the next integer without incrementing\n the current index.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the next int","type_short":"int"}},{"javadoc":"Peeks at the next long without incrementing\n the current index.\n@return the next long\n@exception IOException if an I\/O error occurs","static":false,"name":"peekNextLong","comment":"Peeks at the next long without incrementing\n the current index.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"the next long","type_short":"long"}},{"javadoc":"Reads the byte at the current index and then increments the current\n index by <code>SIZEOF_BYTE<\/code>.\n@return the byte at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextByte","comment":"Reads the byte at the current index and then increments the current\n index by SIZEOF_BYTE.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte","comment":"the byte at the current index","type_short":"byte"}},{"javadoc":"Reads the unsigned byte at the current index and then increments the current\n index by <code>SIZEOF_BYTE<\/code>.\n@return the unsigned byte at the current index, as an int\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextUnsignedByte","comment":"Reads the unsigned byte at the current index and then increments the current\n index by SIZEOF_BYTE.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the unsigned byte at the current index, as an int","type_short":"int"}},{"javadoc":"Reads the short at the current index and then increments the current\n index by <code>SIZEOF_SHORT<\/code>.\n@return the short at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextShort","comment":"Reads the short at the current index and then increments the current\n index by SIZEOF_SHORT.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short","comment":"the short at the current index","type_short":"short"}},{"javadoc":"Reads the unsigned short at the current index and then increments the current\n index by <code>SIZEOF_SHORT<\/code>.\n@return the unsigned short at the current index, as an int\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextUnsignedShort","comment":"Reads the unsigned short at the current index and then increments the current\n index by SIZEOF_SHORT.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the unsigned short at the current index, as an int","type_short":"int"}},{"javadoc":"Reads the integer at the current index and then increments the current\n index by <code>SIZEOF_INT<\/code>.\n@return the integer at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextInt","comment":"Reads the integer at the current index and then increments the current\n index by SIZEOF_INT.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the integer at the current index","type_short":"int"}},{"javadoc":"Reads the unsigned integer at the current index and then increments the current\n index by <code>SIZEOF_INT<\/code>.\n@return the unsigned integer at the current index, as a long\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextUnsignedInt","comment":"Reads the unsigned integer at the current index and then increments the current\n index by SIZEOF_INT.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"the unsigned integer at the current index, as a long","type_short":"long"}},{"javadoc":"Reads the long at the current index and then increments the current\n index by <code>SIZEOF_LONG<\/code>.\n@return the long at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextLong","comment":"Reads the long at the current index and then increments the current\n index by SIZEOF_LONG.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"the long at the current index","type_short":"long"}},{"javadoc":"Reads the Ascii string at the current index and then increments the current\n index by the length of the Ascii string that was found. This method\n expects the string to be null-terminated.\n@return the null-terminated Ascii string at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextAsciiString","comment":"Reads the Ascii string at the current index and then increments the current\n index by the length of the Ascii string that was found. This method\n expects the string to be null-terminated.","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the null-terminated Ascii string at the current index","type_short":"String"}},{"javadoc":"Reads a null terminated Ascii string starting at the current index,\n ending at the first null character or when reaching the\n end of the underlying ByteProvider.\n <p>\n The current index is advanced to the next byte after the null terminator.\n <p>\n@return the null-terminated Ascii string at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextNullTerminatedAsciiString","comment":"Reads a null terminated Ascii string starting at the current index,\n ending at the first null character or when reaching the\n end of the underlying ByteProvider.\n \n The current index is advanced to the next byte after the null terminator.\n ","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the null-terminated Ascii string at the current index","type_short":"String"}},{"javadoc":"Reads an Ascii string of <code>length<\/code>\n characters starting at the current index and then increments the current\n index by <code>length<\/code>.\n@return the Ascii string at the current index","static":false,"name":"readNextAsciiString","comment":"Reads an Ascii string of length\n characters starting at the current index and then increments the current\n index by length.","params":[{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the Ascii string at the current index","type_short":"String"}},{"javadoc":"Reads the Unicode string at the current index and then increments the current\n index by the length of the Unicode string that was found. This method\n expects the string to be double null-terminated ('\\0\\0').\n@return the null-terminated Ascii string at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextUnicodeString","comment":"Reads the Unicode string at the current index and then increments the current\n index by the length of the Unicode string that was found. This method\n expects the string to be double null-terminated ('\\0\\0').","params":[],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the null-terminated Ascii string at the current index","type_short":"String"}},{"javadoc":"Reads fixed length UTF-16 Unicode string the current index and then increments the current\n {@link #setPointerIndex(int) pointer index} by <code>length<\/code> elements (length*2 bytes).\n@return the UTF-16 Unicode string at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextUnicodeString","comment":"Reads fixed length UTF-16 Unicode string the current index and then increments the current\n #setPointerIndex(int) by length elements (length*2 bytes).","params":[{"type_long":"int","name":"length","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the UTF-16 Unicode string at the current index","type_short":"String"}},{"javadoc":"Reads a byte array of <code>nElements<\/code>\n starting at the current index and then increments the current\n index by <code>SIZEOF_BYTE * nElements<\/code>.\n@return the byte array starting at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextByteArray","comment":"Reads a byte array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_BYTE * nElements.","params":[{"type_long":"int","name":"nElements","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte[]","comment":"the byte array starting at the current index","type_short":"byte[]"}},{"javadoc":"Reads a short array of <code>nElements<\/code>\n starting at the current index and then increments the current\n index by <code>SIZEOF_SHORT * nElements<\/code>.\n@return the short array starting at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextShortArray","comment":"Reads a short array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_SHORT * nElements.","params":[{"type_long":"int","name":"nElements","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short[]","comment":"the short array starting at the current index","type_short":"short[]"}},{"javadoc":"Reads an integer array of <code>nElements<\/code>\n starting at the current index and then increments the current\n index by <code>SIZEOF_INT * nElements<\/code>.\n@return the integer array starting at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextIntArray","comment":"Reads an integer array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_INT * nElements.","params":[{"type_long":"int","name":"nElements","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int[]","comment":"the integer array starting at the current index","type_short":"int[]"}},{"javadoc":"Reads a long array of <code>nElements<\/code>\n starting at the current index and then increments the current\n index by <code>SIZEOF_LONG * nElements<\/code>.\n@return the long array starting at the current index\n@exception IOException if an I\/O error occurs","static":false,"name":"readNextLongArray","comment":"Reads a long array of nElements\n starting at the current index and then increments the current\n index by SIZEOF_LONG * nElements.","params":[{"type_long":"int","name":"nElements","comment":"","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long[]","comment":"the long array starting at the current index","type_short":"long[]"}},{"javadoc":"Reads an Ascii string starting at <code>index<\/code>, ending\n at the next character outside the range [32..126] or when\n reaching the end of the underlying ByteProvider.\n <p>\n Leading and trailing spaces will be trimmed before the string is returned.\n@param index the index where the Ascii string begins\n@return the trimmed Ascii string\n@exception IOException if an I\/O error occurs","static":false,"name":"readAsciiString","comment":"Reads an Ascii string starting at index, ending\n at the next character outside the range [32..126] or when\n reaching the end of the underlying ByteProvider.\n \n Leading and trailing spaces will be trimmed before the string is returned.","params":[{"type_long":"long","name":"index","comment":"the index where the Ascii string begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the trimmed Ascii string","type_short":"String"}},{"javadoc":"Returns an Ascii string of <code>length<\/code> bytes\n starting at <code>index<\/code>. This method does not\n care about null-terminators.  Leading and trailing spaces\n will be trimmed before the string is returned.\n@param index the index where the Ascii string begins\n@param length the length of the Ascii string\n@return the trimmed Ascii string\n@exception IOException if an I\/O error occurs","static":false,"name":"readAsciiString","comment":"Returns an Ascii string of length bytes\n starting at index. This method does not\n care about null-terminators.  Leading and trailing spaces\n will be trimmed before the string is returned.","params":[{"type_long":"long","name":"index","comment":"the index where the Ascii string begins","type_short":"long"},{"type_long":"int","name":"length","comment":"the length of the Ascii string","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the trimmed Ascii string","type_short":"String"}},{"javadoc":"Reads an Ascii string starting at <code>index<\/code>, ending\n at the next {@code termChar} character byte or when  reaching the end of\n the underlying ByteProvider.\n <p>\n Does NOT trim the string.\n <p>\n@param index the index where the Ascii string begins\n@return the Ascii string (excluding the terminating character)\n@exception IOException if an I\/O error occurs","static":false,"name":"readTerminatedString","comment":"Reads an Ascii string starting at index, ending\n at the next  character byte or when  reaching the end of\n the underlying ByteProvider.\n \n Does NOT trim the string.\n ","params":[{"type_long":"long","name":"index","comment":"the index where the Ascii string begins","type_short":"long"},{"type_long":"char","name":"termChar","comment":"","type_short":"char"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the Ascii string (excluding the terminating character)","type_short":"String"}},{"javadoc":"Reads an Ascii string starting at <code>index<\/code>, ending\n at the next character that is one of the specified {@code termChars} or when\n reaching the end of the underlying ByteProvider.\n <p>\n Does NOT trim the string.\n <p>\n@param index the index where the Ascii string begins\n@return the Ascii string (excluding the terminating character)\n@exception IOException if an I\/O error occurs","static":false,"name":"readTerminatedString","comment":"Reads an Ascii string starting at index, ending\n at the next character that is one of the specified  or when\n reaching the end of the underlying ByteProvider.\n \n Does NOT trim the string.\n ","params":[{"type_long":"long","name":"index","comment":"the index where the Ascii string begins","type_short":"long"},{"type_long":"java.lang.String","name":"termChars","comment":"","type_short":"String"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the Ascii string (excluding the terminating character)","type_short":"String"}},{"javadoc":"Reads an fixed length Ascii string starting at <code>index<\/code>.\n <p>\n Does NOT trim the string.\n <p>\n@param index the index where the Ascii string begins\n@param len number of bytes to read\n@return the Ascii string\n@exception IOException if an I\/O error occurs","static":false,"name":"readFixedLenAsciiString","comment":"Reads an fixed length Ascii string starting at index.\n \n Does NOT trim the string.\n ","params":[{"type_long":"long","name":"index","comment":"the index where the Ascii string begins","type_short":"long"},{"type_long":"int","name":"len","comment":"number of bytes to read","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the Ascii string","type_short":"String"}},{"javadoc":"Reads a null-terminated UTF-16 Unicode string starting\n at <code>index<\/code> using the pre-specified\n {@link #setLittleEndian(boolean) endianness}.\n <p>\n The end of the string is denoted by a two-byte (ie. short) <code>null<\/code> character.\n <p>\n Leading and trailing spaces will be trimmed before the string is returned.\n <p>\n@param index the index where the UTF-16 Unicode string begins\n@return the trimmed UTF-16 Unicode string\n@exception IOException if an I\/O error occurs","static":false,"name":"readUnicodeString","comment":"Reads a null-terminated UTF-16 Unicode string starting\n at index using the pre-specified\n #setLittleEndian(boolean).\n \n The end of the string is denoted by a two-byte (ie. short) null character.\n \n Leading and trailing spaces will be trimmed before the string is returned.\n ","params":[{"type_long":"long","name":"index","comment":"the index where the UTF-16 Unicode string begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the trimmed UTF-16 Unicode string","type_short":"String"}},{"javadoc":"Reads a fixed length UTF-16 Unicode string of <code>length<\/code> characters\n starting at <code>index<\/code>, using the pre-specified\n {@link #setLittleEndian(boolean) endianness}.\n <p>\n This method does not care about null-terminators.\n <p>\n Leading and trailing spaces will be trimmed before the string is returned.\n <p>\n@param index the index where the UTF-16 Unicode string begins\n@param length the number of UTF-16 character elements to read.\n@return the trimmed UTF-16 Unicode string\n@exception IOException if an I\/O error occurs","static":false,"name":"readUnicodeString","comment":"Reads a fixed length UTF-16 Unicode string of length characters\n starting at index, using the pre-specified\n #setLittleEndian(boolean).\n \n This method does not care about null-terminators.\n \n Leading and trailing spaces will be trimmed before the string is returned.\n ","params":[{"type_long":"long","name":"index","comment":"the index where the UTF-16 Unicode string begins","type_short":"long"},{"type_long":"int","name":"length","comment":"the number of UTF-16 character elements to read.","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String","comment":"the trimmed UTF-16 Unicode string","type_short":"String"}},{"javadoc":"Returns the signed BYTE at <code>index<\/code>.\n@param index the index where the BYTE begins\n@return the signed BYTE\n@exception IOException if an I\/O error occurs","static":false,"name":"readByte","comment":"Returns the signed BYTE at index.","params":[{"type_long":"long","name":"index","comment":"the index where the BYTE begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte","comment":"the signed BYTE","type_short":"byte"}},{"javadoc":"Returns the unsigned BYTE at <code>index<\/code>.\n@param index the index where the BYTE begins\n@return the unsigned BYTE as an int\n@exception IOException if an I\/O error occurs","static":false,"name":"readUnsignedByte","comment":"Returns the unsigned BYTE at index.","params":[{"type_long":"long","name":"index","comment":"the index where the BYTE begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the unsigned BYTE as an int","type_short":"int"}},{"javadoc":"Returns the signed SHORT at <code>index<\/code>.\n@param index the index where the SHORT begins\n@return the signed SHORT\n@exception IOException if an I\/O error occurs","static":false,"name":"readShort","comment":"Returns the signed SHORT at index.","params":[{"type_long":"long","name":"index","comment":"the index where the SHORT begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short","comment":"the signed SHORT","type_short":"short"}},{"javadoc":"Returns the unsigned SHORT at <code>index<\/code>.\n@param index the index where the SHORT begins\n@return the unsigned SHORT as an int\n@exception IOException if an I\/O error occurs","static":false,"name":"readUnsignedShort","comment":"Returns the unsigned SHORT at index.","params":[{"type_long":"long","name":"index","comment":"the index where the SHORT begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the unsigned SHORT as an int","type_short":"int"}},{"javadoc":"Returns the signed INTEGER at <code>index<\/code>.\n@param index the index where the INTEGER begins\n@return the signed INTEGER\n@exception IOException if an I\/O error occurs","static":false,"name":"readInt","comment":"Returns the signed INTEGER at index.","params":[{"type_long":"long","name":"index","comment":"the index where the INTEGER begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the signed INTEGER","type_short":"int"}},{"javadoc":"Returns the unsigned INTEGER at <code>index<\/code>.\n@param index the index where the INTEGER begins\n@return the unsigned INTEGER as a long\n@exception IOException if an I\/O error occurs","static":false,"name":"readUnsignedInt","comment":"Returns the unsigned INTEGER at index.","params":[{"type_long":"long","name":"index","comment":"the index where the INTEGER begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"the unsigned INTEGER as a long","type_short":"long"}},{"javadoc":"Returns the INTEGER at <code>index<\/code>, after coercing it into the range\n [minClamp-maxClamp].\n@param index the index where the INTEGER begins\n@param minClamp minimum value that will be returned\n@param maxClamp maximum value that will be returned\n@return the INTEGER\n@exception IOException if an I\/O error occurs","static":false,"name":"readInt","comment":"Returns the INTEGER at index, after coercing it into the range\n [minClamp-maxClamp].","params":[{"type_long":"long","name":"index","comment":"the index where the INTEGER begins","type_short":"long"},{"type_long":"int","name":"minClamp","comment":"minimum value that will be returned","type_short":"int"},{"type_long":"int","name":"maxClamp","comment":"maximum value that will be returned","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int","comment":"the INTEGER","type_short":"int"}},{"javadoc":"Returns the LONG at <code>index<\/code>.\n@param index the index where the LONG begins\n@return the LONG\n@exception IOException if an I\/O error occurs","static":false,"name":"readLong","comment":"Returns the LONG at index.","params":[{"type_long":"long","name":"index","comment":"the index where the LONG begins","type_short":"long"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long","comment":"the LONG","type_short":"long"}},{"javadoc":"Returns the BYTE array of <code>nElements<\/code>\n starting at <code>index<\/code>.\n@param index the index where the BYTE begins\n@param nElements the number of array elements\n@return the BYTE array\n@exception IOException if an I\/O error occurs","static":false,"name":"readByteArray","comment":"Returns the BYTE array of nElements\n starting at index.","params":[{"type_long":"long","name":"index","comment":"the index where the BYTE begins","type_short":"long"},{"type_long":"int","name":"nElements","comment":"the number of array elements","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"byte[]","comment":"the BYTE array","type_short":"byte[]"}},{"javadoc":"Returns the SHORT array of <code>nElements<\/code>\n starting at <code>index<\/code>.\n@param index the index where the SHORT begins\n@param nElements the number of array elements\n@return the SHORT array\n@exception IOException if an I\/O error occurs","static":false,"name":"readShortArray","comment":"Returns the SHORT array of nElements\n starting at index.","params":[{"type_long":"long","name":"index","comment":"the index where the SHORT begins","type_short":"long"},{"type_long":"int","name":"nElements","comment":"the number of array elements","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"short[]","comment":"the SHORT array","type_short":"short[]"}},{"javadoc":"Returns the INTEGER array of <code>nElements<\/code>\n starting at <code>index<\/code>.\n@param index the index where the INTEGER begins\n@param nElements the number of array elements\n@return the INTEGER array\n@exception IOException if an I\/O error occurs","static":false,"name":"readIntArray","comment":"Returns the INTEGER array of nElements\n starting at index.","params":[{"type_long":"long","name":"index","comment":"the index where the INTEGER begins","type_short":"long"},{"type_long":"int","name":"nElements","comment":"the number of array elements","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"int[]","comment":"the INTEGER array","type_short":"int[]"}},{"javadoc":"Returns the LONG array of <code>nElements<\/code>\n starting at <code>index<\/code>.\n@param index the index where the LONG begins\n@param nElements the number of array elements\n@return the LONG array\n@exception IOException if an I\/O error occurs","static":false,"name":"readLongArray","comment":"Returns the LONG array of nElements\n starting at index.","params":[{"type_long":"long","name":"index","comment":"the index where the LONG begins","type_short":"long"},{"type_long":"int","name":"nElements","comment":"the number of array elements","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"long[]","comment":"the LONG array","type_short":"long[]"}},{"javadoc":"Returns the Ascii string array of <code>nElements<\/code>\n starting at <code>index<\/code>\n@param index the index where the Ascii Strings begin\n@param nElements the number of array elements\n@return the Ascii String array\n@exception IOException if an I\/O error occurs","static":false,"name":"readAsciiStringArray","comment":"Returns the Ascii string array of nElements\n starting at index","params":[{"type_long":"long","name":"index","comment":"the index where the Ascii Strings begin","type_short":"long"},{"type_long":"int","name":"nElements","comment":"the number of array elements","type_short":"int"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"}],"return":{"type_long":"java.lang.String[]","comment":"the Ascii String array","type_short":"java.lang.String[]"}},{"javadoc":"Returns the underlying byte provider.\n@return the underlying byte provider","static":false,"name":"getByteProvider","comment":"Returns the underlying byte provider.","params":[],"throws":[],"return":{"type_long":"ghidra.app.util.bin.ByteProvider","comment":"the underlying byte provider","type_short":"ByteProvider"}},{"javadoc":"Returns the specified integer after it has been forced to be within the range of\n [minClamp-maxClamp].\n <p>\n@param i value to force into range\n@param minClamp minimum value the integer is allowed to take (inclusive)\n@param maxClamp maximum value the integer is allowed to take (inclusive)\n@return value of {@code i} if it is within the range [min-max], otherwise min if {@code i} is less than min\n or max if {@code i} is greater than max.","static":false,"name":"clampInt","comment":"Returns the specified integer after it has been forced to be within the range of\n [minClamp-maxClamp].\n ","params":[{"type_long":"int","name":"i","comment":"value to force into range","type_short":"int"},{"type_long":"int","name":"minClamp","comment":"minimum value the integer is allowed to take (inclusive)","type_short":"int"},{"type_long":"int","name":"maxClamp","comment":"maximum value the integer is allowed to take (inclusive)","type_short":"int"}],"throws":[],"return":{"type_long":"int","comment":"value of  if it is within the range [min-max], otherwise min if  is less than min\n or max if  is greater than max.","type_short":"int"}}],"name":"BinaryReader","comment":"A class for reading data from a\n generic byte provider in either big-endian or little-endian.","fields":[{"type_long":"int","javadoc":"The size of a BYTE in Java.","static":true,"name":"SIZEOF_BYTE","comment":"The size of a BYTE in Java.","type_short":"int","constant_value":"1"},{"type_long":"int","javadoc":"The size of a SHORT in Java.","static":true,"name":"SIZEOF_SHORT","comment":"The size of a SHORT in Java.","type_short":"int","constant_value":"2"},{"type_long":"int","javadoc":"The size of an INTEGER in Java.","static":true,"name":"SIZEOF_INT","comment":"The size of an INTEGER in Java.","type_short":"int","constant_value":"4"},{"type_long":"int","javadoc":"The size of a LONG in Java.","static":true,"name":"SIZEOF_LONG","comment":"The size of a LONG in Java.","type_short":"int","constant_value":"8"},{"type_long":"ghidra.app.util.bin.ByteProvider","javadoc":"","static":false,"name":"provider","comment":"","type_short":"ByteProvider","constant_value":null},{"type_long":"ghidra.util.DataConverter","javadoc":"","static":false,"name":"converter","comment":"","type_short":"DataConverter","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"currentIndex","comment":"","type_short":"long","constant_value":null}]}
