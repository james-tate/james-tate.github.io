{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.program.model.listing.Program","name":"program","comment":"","type_short":"Program"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add initialized memory \"section\" based upon a specified data source fileOffset.\n The last \"section\" defined will take precedence when resolving conflicts. Sections identified \n as loaded will take precedence over those that are non-loaded.\n placed into memory\n@param key the loadable section key which corresponds to this memory \"section\"\n@param fileOffset data source file offset.  It is assumed that all initialized\n \"sections\" draw from a single data source.\n@param length number of bytes within \"section\"\n@param startAddress desired physical start address of \"section\"\n@param sectionName name of \"section\"\n@param isReadable true if \"section\" has read privilege\n@param isWritable true if \"section\" has write privilege\n@param isExecutable true if \"section\" has execute privilege\n@param comment section comment (used as basis for block comment)\n@param isFragmentationOK if true this memory section may be fragmented due to\n@param isLoadedSection if true this memory section will take precedence over non-loaded sections\n conflict\/overlap with other memory sections of higher precedence.\n@throws AddressOverflowException","static":false,"name":"addInitializedMemorySection","comment":"Add initialized memory \"section\" based upon a specified data source fileOffset.\n The last \"section\" defined will take precedence when resolving conflicts. Sections identified \n as loaded will take precedence over those that are non-loaded.\n placed into memory","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"the loadable section key which corresponds to this memory \"section\"","type_short":"MemoryLoadable"},{"type_long":"long","name":"fileOffset","comment":"data source file offset.  It is assumed that all initialized\n \"sections\" draw from a single data source.","type_short":"long"},{"type_long":"long","name":"numberOfBytes","comment":"","type_short":"long"},{"type_long":"ghidra.program.model.address.Address","name":"startAddress","comment":"desired physical start address of \"section\"","type_short":"Address"},{"type_long":"java.lang.String","name":"sectionName","comment":"name of \"section\"","type_short":"String"},{"type_long":"boolean","name":"isReadable","comment":"true if \"section\" has read privilege","type_short":"boolean"},{"type_long":"boolean","name":"isWritable","comment":"true if \"section\" has write privilege","type_short":"boolean"},{"type_long":"boolean","name":"isExecutable","comment":"true if \"section\" has execute privilege","type_short":"boolean"},{"type_long":"java.lang.String","name":"comment","comment":"section comment (used as basis for block comment)","type_short":"String"},{"type_long":"boolean","name":"isFragmentationOK","comment":"if true this memory section may be fragmented due to","type_short":"boolean"},{"type_long":"boolean","name":"isLoadedSection","comment":"if true this memory section will take precedence over non-loaded sections\n conflict\/overlap with other memory sections of higher precedence.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add uninitialized memory \"section\".\n The last \"section\" defined will take precedence when resolving conflicts.\n@param key the loadable section key which corresponds to this memory \"section\"\n@param length number of bytes within \"section\"\n@param startAddress desired physical start address of \"section\"\n@param sectionName name of \"section\"\n@param isReadable true if \"section\" has read privilege\n@param isWritable true if \"section\" has write privilege\n@param isExecutable true if \"section\" has execute privilege\n@param comment section comment (used as basis for block comment)\n@param isFragmentationOK if true this memory section may be fragmented due to \n conflict\/overlap with other memory sections of higher precedence.\n@throws AddressOverflowException","static":false,"name":"addUninitializedMemorySection","comment":"Add uninitialized memory \"section\".\n The last \"section\" defined will take precedence when resolving conflicts.","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"the loadable section key which corresponds to this memory \"section\"","type_short":"MemoryLoadable"},{"type_long":"long","name":"numberOfBytes","comment":"","type_short":"long"},{"type_long":"ghidra.program.model.address.Address","name":"startAddress","comment":"desired physical start address of \"section\"","type_short":"Address"},{"type_long":"java.lang.String","name":"sectionName","comment":"name of \"section\"","type_short":"String"},{"type_long":"boolean","name":"isReadable","comment":"true if \"section\" has read privilege","type_short":"boolean"},{"type_long":"boolean","name":"isWritable","comment":"true if \"section\" has write privilege","type_short":"boolean"},{"type_long":"boolean","name":"isExecutable","comment":"true if \"section\" has execute privilege","type_short":"boolean"},{"type_long":"java.lang.String","name":"comment","comment":"section comment (used as basis for block comment)","type_short":"String"},{"type_long":"boolean","name":"isFragmentationOK","comment":"if true this memory section may be fragmented due to \n conflict\/overlap with other memory sections of higher precedence.","type_short":"boolean"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getUniqueSectionName","comment":"","params":[{"type_long":"java.lang.String","name":"baseName","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"getUniqueSectionChunkName","comment":"","params":[{"type_long":"ghidra.app.util.opinion.MemorySection","name":"section","comment":"","type_short":"MemorySection"},{"type_long":"ghidra.program.model.mem.Memory","name":"memory","comment":"","type_short":"Memory"},{"type_long":"int","name":"preferredIndex","comment":"","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"makeRange","comment":"","params":[{"type_long":"ghidra.program.model.address.Address","name":"startAddress","comment":"","type_short":"Address"},{"type_long":"long","name":"numberOfBytes","comment":"","type_short":"long"}],"throws":[{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"}],"return":{"type_long":"ghidra.program.model.address.AddressRange","comment":"","type_short":"AddressRange"}},{"javadoc":"Get the address set as a list of ranges which correspond to a \n loaded section.  The key object corresponds to the key object \n provided when the section was added.\n@param key section key object\n@return list of resolved address ranges or null if not found","static":false,"name":"getResolvedLoadAddresses","comment":"Get the address set as a list of ranges which correspond to a \n loaded section.  The key object corresponds to the key object \n provided when the section was added.","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"section key object","type_short":"MemoryLoadable"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.program.model.address.AddressRange>","comment":"list of resolved address ranges or null if not found","type_short":"List"}},{"javadoc":"","static":false,"name":"getFileLoadRangeMap","comment":"","params":[{"type_long":"ghidra.program.model.address.AddressSpace","name":"space","comment":"","type_short":"AddressSpace"},{"type_long":"boolean","name":"create","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.util.datastruct.ObjectRangeMap<ghidra.app.util.opinion.MemorySectionResolver.AllocatedFileSectionRange>","comment":"","type_short":"ObjectRangeMap"}},{"javadoc":"Perform final resolve of all defined memory \"sections\" to establish final memory mappings.\n This method will resolve all conflicts and create memory blocks within the associated program.\n@param monitor\n@throws CancelledException","static":false,"name":"resolve","comment":"Perform final resolve of all defined memory \"sections\" to establish final memory mappings.\n This method will resolve all conflicts and create memory blocks within the associated program.","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Resolve the specified section and create the corresponding memory block(s).\n An entry will be added to the sectionMemoryMap to facilitate subsequent \n MemoryLoadable memory assignment lookups, see {@link #getResolvedLoadAddresses(MemoryLoadable)}.\n@param section section to be resolved\n@param fileAllocationMap memory mapping of file for those sections already processed.\n Any new file regions claimed by the specified section will be added to this map.\n@param monitor task monitor\n@throws CancelledException","static":false,"name":"resolveSectionMemory","comment":"Resolve the specified section and create the corresponding memory block(s).\n An entry will be added to the sectionMemoryMap to facilitate subsequent \n MemoryLoadable memory assignment lookups, see #getResolvedLoadAddresses(MemoryLoadable).","params":[{"type_long":"ghidra.app.util.opinion.MemorySection","name":"section","comment":"section to be resolved","type_short":"MemorySection"},{"type_long":"ghidra.program.database.register.AddressRangeObjectMap<ghidra.app.util.opinion.MemorySectionResolver.AllocatedFileSectionRange>","name":"fileAllocationMap","comment":"memory mapping of file for those sections already processed.\n Any new file regions claimed by the specified section will be added to this map.","type_short":"AddressRangeObjectMap"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Complete creation of section memory block(s) based upon the provided\n memoryAllocationList.\n@param section section to be allocated and blocks created\n@param memoryAllocationList memory allocation list.\n Matching ranges allocated to other sections are identified using a ProxyAddressRange, \n memory-mapped file range conflicts are identified using an OverlayAddressRange, while\n new file-mapped ranges are be identified by an AddressRangeImpl.\n@param monitor\n@return memory address ranges corresponding to the specified section. Memory blocks\n will have been created for these ranges but may be shared by other sections.\n@throws IOException\n@throws AddressOverflowException\n@throws CancelledException","static":false,"name":"processSectionRanges","comment":"Complete creation of section memory block(s) based upon the provided\n memoryAllocationList.","params":[{"type_long":"ghidra.app.util.opinion.MemorySection","name":"section","comment":"section to be allocated and blocks created","type_short":"MemorySection"},{"type_long":"java.util.List<ghidra.program.model.address.AddressRange>","name":"memoryAllocationList","comment":"memory allocation list.\n Matching ranges allocated to other sections are identified using a ProxyAddressRange, \n memory-mapped file range conflicts are identified using an OverlayAddressRange, while\n new file-mapped ranges are be identified by an AddressRangeImpl.","type_short":"List"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"java.util.List<ghidra.program.model.address.AddressRange>","comment":"memory address ranges corresponding to the specified section. Memory blocks\n will have been created for these ranges but may be shared by other sections.","type_short":"List"}},{"javadoc":"Determine loaded memory conflict set.  Use physical address of loaded overlay\n blocks to force reconciliation and avoid duplication.\n@param rangeMin\n@param rangeMax\n@return conflict memory set","static":false,"name":"getMemoryConflictSet","comment":"Determine loaded memory conflict set.  Use physical address of loaded overlay\n blocks to force reconciliation and avoid duplication.","params":[{"type_long":"ghidra.program.model.address.Address","name":"rangeMin","comment":"","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"rangeMax","comment":"","type_short":"Address"}],"throws":[],"return":{"type_long":"ghidra.program.model.address.AddressSet","comment":"conflict memory set","type_short":"AddressSet"}},{"javadoc":"Allocate section to memory ranges based upon address-mapping of file offsets.\n The fileAllocationMap is used to map regions of the section to previously processed \n sections or to identify new unclaimed address-mapped file regions.  Those ranges \n which match memory-mapped file ranges are identified using a ProxyAddressRange, \n memory-mapped file range conflicts are identified using an OverlayAddressRange, while\n new ranges will be identified by an AddressRangeImpl.\n@param section new section to be processed\n@param fileAllocationMap address to file region map\n@param monitor task monitor\n@return address range list section memory assignment\n@throws CancelledException","static":false,"name":"allocateSectionMemory","comment":"Allocate section to memory ranges based upon address-mapping of file offsets.\n The fileAllocationMap is used to map regions of the section to previously processed \n sections or to identify new unclaimed address-mapped file regions.  Those ranges \n which match memory-mapped file ranges are identified using a ProxyAddressRange, \n memory-mapped file range conflicts are identified using an OverlayAddressRange, while\n new ranges will be identified by an AddressRangeImpl.","params":[{"type_long":"ghidra.app.util.opinion.MemorySection","name":"section","comment":"new section to be processed","type_short":"MemorySection"},{"type_long":"ghidra.program.database.register.AddressRangeObjectMap<ghidra.app.util.opinion.MemorySectionResolver.AllocatedFileSectionRange>","name":"fileAllocationMap","comment":"address to file region map","type_short":"AddressRangeObjectMap"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"java.util.List<ghidra.program.model.address.AddressRange>","comment":"address range list section memory assignment","type_short":"List"}},{"javadoc":"Add a new non-conflicting section load memory range to the rangeList.\n@param section\n@param minAddr start of range\n@param maxAddr end of range\n@param fileOffset file offset at start of range\n@param rangeList rangeList accumulation list of sequentially allocated memory address ranges\n which makeup the specified loaded section.  This list will be added to for the new\n range.\n@return updated file offset if section is initialized.","static":false,"name":"addSectionRange","comment":"Add a new non-conflicting section load memory range to the rangeList.","params":[{"type_long":"ghidra.app.util.opinion.MemorySection","name":"section","comment":"","type_short":"MemorySection"},{"type_long":"ghidra.program.model.address.Address","name":"minAddr","comment":"start of range","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"maxAddr","comment":"end of range","type_short":"Address"},{"type_long":"long","name":"fileOffset","comment":"file offset at start of range","type_short":"long"},{"type_long":"java.util.List<ghidra.program.model.address.AddressRange>","name":"rangeList","comment":"rangeList accumulation list of sequentially allocated memory address ranges\n which makeup the specified loaded section.  This list will be added to for the new\n range.","type_short":"List"}],"throws":[],"return":{"type_long":"long","comment":"updated file offset if section is initialized.","type_short":"long"}},{"javadoc":"Reconcile section load range which has been determined to be in conflict with\n previously resolved section chunks.  Either OverlayAddressRange or \n ProxyAddressRange objects will be added to rangeList to provide advice for\n subsequent memory block creation.\n@param section\n@param minAddr start of conflict range\n@param maxAddr end of conflict range\n@param fileOffset file offset at start of conflict range\n@param rangeList accumulation list of sequentially allocated memory address ranges\n which makeup the specified loaded section.  This list will be added to as the specified\n conflict range is reconciled.\n@return updated file offset if section is initialized.","static":false,"name":"reconcileSectionRangeOverlap","comment":"Reconcile section load range which has been determined to be in conflict with\n previously resolved section chunks.  Either OverlayAddressRange or \n ProxyAddressRange objects will be added to rangeList to provide advice for\n subsequent memory block creation.","params":[{"type_long":"ghidra.app.util.opinion.MemorySection","name":"section","comment":"","type_short":"MemorySection"},{"type_long":"ghidra.program.model.address.Address","name":"minAddr","comment":"start of conflict range","type_short":"Address"},{"type_long":"ghidra.program.model.address.Address","name":"maxAddr","comment":"end of conflict range","type_short":"Address"},{"type_long":"long","name":"fileOffset","comment":"file offset at start of conflict range","type_short":"long"},{"type_long":"java.util.List<ghidra.program.model.address.AddressRange>","name":"rangeList","comment":"accumulation list of sequentially allocated memory address ranges\n which makeup the specified loaded section.  This list will be added to as the specified\n conflict range is reconciled.","type_short":"List"}],"throws":[],"return":{"type_long":"long","comment":"updated file offset if section is initialized.","type_short":"long"}},{"javadoc":"Get program memory object\n@return program memory","static":false,"name":"getMemory","comment":"Get program memory object","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.mem.Memory","comment":"program memory","type_short":"Memory"}},{"javadoc":"Get program object\n@return program","static":false,"name":"getProgram","comment":"Get program object","params":[],"throws":[],"return":{"type_long":"ghidra.program.model.listing.Program","comment":"program","type_short":"Program"}},{"javadoc":"Create a memory block (possible fragment if conflicts resolved) for the specified loadable \"section\". \n If multiple blocks are created due to size restrictions only the first block will be returned.  The \n returned block's length can be checked to determine if this has occurred.\n@param key the loadable section key which corresponds to this memory block or null for\n an adhoc block\n@param isOverlay true if an overlay should be created\n@param name unique name assignment based upon original \"section\" name\n@param start starting physical address of block\n@param fileOffset starting file offset for initialized data source\n@param length number of bytes in block\n@param comment block comment\n@param r true if \"section\" has read privilege\n@param w true if \"section\" has write privilege\n@param x true if \"section\" has execute privilege\n@return memory block\n@throws IOException\n@throws AddressOverflowException\n@throws CancelledException","static":false,"name":"createInitializedBlock","comment":"Create a memory block (possible fragment if conflicts resolved) for the specified loadable \"section\". \n If multiple blocks are created due to size restrictions only the first block will be returned.  The \n returned block's length can be checked to determine if this has occurred.","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"the loadable section key which corresponds to this memory block or null for\n an adhoc block","type_short":"MemoryLoadable"},{"type_long":"boolean","name":"isOverlay","comment":"true if an overlay should be created","type_short":"boolean"},{"type_long":"java.lang.String","name":"name","comment":"unique name assignment based upon original \"section\" name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"starting physical address of block","type_short":"Address"},{"type_long":"long","name":"fileOffset","comment":"starting file offset for initialized data source","type_short":"long"},{"type_long":"long","name":"length","comment":"number of bytes in block","type_short":"long"},{"type_long":"java.lang.String","name":"comment","comment":"block comment","type_short":"String"},{"type_long":"boolean","name":"r","comment":"true if \"section\" has read privilege","type_short":"boolean"},{"type_long":"boolean","name":"w","comment":"true if \"section\" has write privilege","type_short":"boolean"},{"type_long":"boolean","name":"x","comment":"true if \"section\" has execute privilege","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"memory block","type_short":"MemoryBlock"}},{"javadoc":"Create a memory block (possible fragment if conflicts resolved) for the specified loadable \"section\". \n If multiple blocks are created due to size restrictions only the first block will be returned.  The \n returned block's length can be checked to determine if this has occurred.\n@param key the loadable section key which corresponds to this memory block or null for\n an adhoc block\n@param isOverlay true if an overlay should be created\n@param name unique name assignment based upon original \"section\" name\n@param start starting physical address of block\n@param length number of bytes in block\n@param comment block comment\n@param r true if \"section\" has read privilege\n@param w true if \"section\" has write privilege\n@param x true if \"section\" has execute privilege\n@return memory block\n@throws IOException\n@throws AddressOverflowException\n@throws CancelledException","static":false,"name":"createUninitializedBlock","comment":"Create a memory block (possible fragment if conflicts resolved) for the specified loadable \"section\". \n If multiple blocks are created due to size restrictions only the first block will be returned.  The \n returned block's length can be checked to determine if this has occurred.","params":[{"type_long":"ghidra.app.util.bin.format.MemoryLoadable","name":"key","comment":"the loadable section key which corresponds to this memory block or null for\n an adhoc block","type_short":"MemoryLoadable"},{"type_long":"boolean","name":"isOverlay","comment":"true if an overlay should be created","type_short":"boolean"},{"type_long":"java.lang.String","name":"name","comment":"unique name assignment based upon original \"section\" name","type_short":"String"},{"type_long":"ghidra.program.model.address.Address","name":"start","comment":"starting physical address of block","type_short":"Address"},{"type_long":"long","name":"length","comment":"number of bytes in block","type_short":"long"},{"type_long":"java.lang.String","name":"comment","comment":"block comment","type_short":"String"},{"type_long":"boolean","name":"r","comment":"true if \"section\" has read privilege","type_short":"boolean"},{"type_long":"boolean","name":"w","comment":"true if \"section\" has write privilege","type_short":"boolean"},{"type_long":"boolean","name":"x","comment":"true if \"section\" has execute privilege","type_short":"boolean"}],"throws":[{"type_long":"java.io.IOException","comment":"","type_short":"IOException"},{"type_long":"ghidra.program.model.address.AddressOverflowException","comment":"","type_short":"AddressOverflowException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"ghidra.program.model.mem.MemoryBlock","comment":"memory block","type_short":"MemoryBlock"}}],"name":"MemorySectionResolver","comment":"","fields":[{"type_long":"ghidra.program.model.listing.Program","javadoc":"","static":false,"name":"program","comment":"","type_short":"Program","constant_value":null},{"type_long":"java.util.List<ghidra.app.util.opinion.MemorySection>","javadoc":"","static":false,"name":"sections","comment":"","type_short":"List","constant_value":null},{"type_long":"java.util.Map<java.lang.String,java.lang.Integer>","javadoc":"","static":false,"name":"sectionIndexMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<ghidra.app.util.bin.format.MemoryLoadable,java.util.List<ghidra.program.model.address.AddressRange>>","javadoc":"","static":false,"name":"sectionMemoryMap","comment":"","type_short":"Map","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"nextNonLoadedSectionInsertionIndex","comment":"","type_short":"int","constant_value":null},{"type_long":"java.util.Map<ghidra.program.model.address.AddressSpace,ghidra.util.datastruct.ObjectRangeMap<ghidra.app.util.opinion.MemorySectionResolver.AllocatedFileSectionRange>>","javadoc":"","static":false,"name":"fileLoadMaps","comment":"","type_short":"Map","constant_value":null}]}
