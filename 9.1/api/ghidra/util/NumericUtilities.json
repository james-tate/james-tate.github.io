{"implements":[],"javadoc":"","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"parses the given string as a numeric value, detecting whether\n or not it begins with a Hex prefix, and if not, parses as a\n long int value.","static":true,"name":"parseNumber","comment":"parses the given string as a numeric value, detecting whether\n or not it begins with a Hex prefix, and if not, parses as a\n long int value.","params":[{"type_long":"java.lang.String","name":"numStr","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"parses the given string as a numeric value, detecting whether\n or not it begins with a Hex prefix, and if not, parses as a\n long int value.","static":true,"name":"parseLong","comment":"parses the given string as a numeric value, detecting whether\n or not it begins with a Hex prefix, and if not, parses as a\n long int value.","params":[{"type_long":"java.lang.String","name":"numStr","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"parses the given string as a numeric value, detecting whether\n or not it begins with a Hex prefix, and if not, parses as a\n long int value.","static":true,"name":"parseOctLong","comment":"parses the given string as a numeric value, detecting whether\n or not it begins with a Hex prefix, and if not, parses as a\n long int value.","params":[{"type_long":"java.lang.String","name":"numStr","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":true,"name":"parseHexLong","comment":"","params":[{"type_long":"java.lang.String","name":"numStr","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"","static":true,"name":"parseHexBigInteger","comment":"","params":[{"type_long":"java.lang.String","name":"numStr","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"","type_short":"BigInteger"}},{"javadoc":"returns the value of the specified long as hexadecimal, prefixing\n with the HEX_PREFIX_x string.\n@param value the long value to convert","static":true,"name":"toHexString","comment":"returns the value of the specified long as hexadecimal, prefixing\n with the HEX_PREFIX_x string.","params":[{"type_long":"long","name":"value","comment":"the long value to convert","type_short":"long"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"returns the value of the specified long as hexadecimal, prefixing\n with the HEX_PREFIX_x string.\n@param value the long value to convert\n@param size number of bytes to be represented","static":true,"name":"toHexString","comment":"returns the value of the specified long as hexadecimal, prefixing\n with the HEX_PREFIX_x string.","params":[{"type_long":"long","name":"value","comment":"the long value to convert","type_short":"long"},{"type_long":"int","name":"size","comment":"number of bytes to be represented","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"returns the value of the specified long as signed hexadecimal, prefixing\n with the HEX_PREFIX_x string.\n@param value the long value to convert","static":true,"name":"toSignedHexString","comment":"returns the value of the specified long as signed hexadecimal, prefixing\n with the HEX_PREFIX_x string.","params":[{"type_long":"long","name":"value","comment":"the long value to convert","type_short":"long"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":true,"name":"unsignedLongToBigInteger","comment":"","params":[{"type_long":"long","name":"value","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"java.math.BigInteger","comment":"","type_short":"BigInteger"}},{"javadoc":"","static":true,"name":"bigIntegerToUnsignedLong","comment":"","params":[{"type_long":"java.math.BigInteger","name":"value","comment":"","type_short":"BigInteger"}],"throws":[],"return":{"type_long":"long","comment":"","type_short":"long"}},{"javadoc":"Get an unsigned aligned value corresponding to the specified unsigned value\n which will be greater than or equal the specified value.\n@param value value to be aligned\n@param alignment alignment\n@return aligned value","static":true,"name":"getUnsignedAlignedValue","comment":"Get an unsigned aligned value corresponding to the specified unsigned value\n which will be greater than or equal the specified value.","params":[{"type_long":"long","name":"unsignedValue","comment":"","type_short":"long"},{"type_long":"long","name":"alignment","comment":"alignment","type_short":"long"}],"throws":[],"return":{"type_long":"long","comment":"aligned value","type_short":"long"}},{"javadoc":"Convert a masked value into a hexadecimal-ish string.\n\n Converts the data to hexadecimal, placing an X where a nibble is unknown. Where a nibble\n is partially defined, it is displayed as four bits in brackets []. Bits are displayed\n as x, or the defined value.\n\n For example, consider the mask 00001111:01011100, and the value 00001001:00011000. This\n will display as {@code X8:[x0x1][10xx]}. To see the correlation, consider the table:\n <table>\n   <tr><th>Display<\/th><th>{@code X}<\/th>   <th>{@code 8}<\/th>   <th>{@code :}<\/th>\n                           <th>{@code [x0x1]}<\/th><th>{@code [10xx]}<\/th><\/tr>\n   <tr><th>Mask<\/th>   <td>{@code 0000}<\/td><td>{@code 1111}<\/td><td>{@code :}<\/td>\n                           <td>{@code 0101}<\/td>  <td>{@code 1100}<\/td>  <\/tr>\n   <tr><th>Value<\/th>  <td>{@code 0000}<\/td><td>{@code 1000}<\/td><td>{@code :}<\/td>\n                           <td>{@code 0001}<\/td>  <td>{@code 1000}<\/td>  <\/tr>\n <\/table>\n@param msk the mask\n@param val the value\n@param n the number of nibbles, starting at the right. The example uses 4.\n@param truncate true if leading Xs may be truncated. The example uses {@code false}.\n@param spaceevery how many nibbles in spaced groups, 0 for no spaces. The example uses 2.\n@param spacer the group separator, if applicable. The example uses {@code ':'}.\n@return the string representation\n@see #convertMaskToHexString(long, int, boolean, int, String)\n@see #convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int, String)","static":true,"name":"convertMaskedValueToHexString","comment":"Convert a masked value into a hexadecimal-ish string.\n\n Converts the data to hexadecimal, placing an X where a nibble is unknown. Where a nibble\n is partially defined, it is displayed as four bits in brackets []. Bits are displayed\n as x, or the defined value.\n\n For example, consider the mask 00001111:01011100, and the value 00001001:00011000. This\n will display as . To see the correlation, consider the table:\n \n   Display      \n                           \n   Mask   \n                               \n   Value  \n                               \n ","params":[{"type_long":"long","name":"msk","comment":"the mask","type_short":"long"},{"type_long":"long","name":"val","comment":"the value","type_short":"long"},{"type_long":"int","name":"n","comment":"the number of nibbles, starting at the right. The example uses 4.","type_short":"int"},{"type_long":"boolean","name":"truncate","comment":"true if leading Xs may be truncated. The example uses .","type_short":"boolean"},{"type_long":"int","name":"spaceevery","comment":"how many nibbles in spaced groups, 0 for no spaces. The example uses 2.","type_short":"int"},{"type_long":"java.lang.String","name":"spacer","comment":"the group separator, if applicable. The example uses .","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the string representation","type_short":"String"}},{"javadoc":"Convert a mask to a hexadecimal-ish string.\n\n Converts the mask in a similar way to\n {@link #convertMaskedValueToHexString(long, long, int, boolean, int, String)}.\n Philosophically, it is hexadecimal, but the only valid digits are 0 and F. Any\n partially-included nibble will be broken down into bracketed bits. Displaying masks in this\n way is convenient when shown proximal to related masked values.\n@param msk the mask\n@param n the number of nibbles, starting at the right\n@param truncate true if leading Xs may be truncated\n@param spaceevery how many nibbles in spaced groups, 0 for no spaces\n@param spacer the group separator, if applicable\n@return the string representation\n@see #convertMaskedValueToHexString(long, long, int, boolean, int, String)\n@see #convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int, String)","static":true,"name":"convertMaskToHexString","comment":"Convert a mask to a hexadecimal-ish string.\n\n Converts the mask in a similar way to\n #convertMaskedValueToHexString(long, long, int, boolean, int, String).\n Philosophically, it is hexadecimal, but the only valid digits are 0 and F. Any\n partially-included nibble will be broken down into bracketed bits. Displaying masks in this\n way is convenient when shown proximal to related masked values.","params":[{"type_long":"long","name":"msk","comment":"the mask","type_short":"long"},{"type_long":"int","name":"n","comment":"the number of nibbles, starting at the right","type_short":"int"},{"type_long":"boolean","name":"truncate","comment":"true if leading Xs may be truncated","type_short":"boolean"},{"type_long":"int","name":"spaceevery","comment":"how many nibbles in spaced groups, 0 for no spaces","type_short":"int"},{"type_long":"java.lang.String","name":"spacer","comment":"the group separator, if applicable","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the string representation","type_short":"String"}},{"javadoc":"The reverse of {@link #convertMaskedValueToHexString(long, long, int, boolean, int, String)}\n@param msk an object to receive the resulting mask\n@param val an object to receive the resulting value\n@param hex the input string to parse\n@param n the number of nibbles to parse (they are stored right aligned in the result)\n@param spaceevery how many nibbles are expected between spacers\n@param spacer the spacer\n@see #convertMaskedValueToHexString(long, long, int, boolean, int, String)\n@see #convertMaskToHexString(long, int, boolean, int, String)","static":true,"name":"convertHexStringToMaskedValue","comment":"The reverse of #convertMaskedValueToHexString(long, long, int, boolean, int, String)","params":[{"type_long":"java.util.concurrent.atomic.AtomicLong","name":"msk","comment":"an object to receive the resulting mask","type_short":"AtomicLong"},{"type_long":"java.util.concurrent.atomic.AtomicLong","name":"val","comment":"an object to receive the resulting value","type_short":"AtomicLong"},{"type_long":"java.lang.String","name":"hex","comment":"the input string to parse","type_short":"String"},{"type_long":"int","name":"n","comment":"the number of nibbles to parse (they are stored right aligned in the result)","type_short":"int"},{"type_long":"int","name":"spaceevery","comment":"how many nibbles are expected between spacers","type_short":"int"},{"type_long":"java.lang.String","name":"spacer","comment":"the spacer","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Render <code>number<\/code> in different bases using the default signedness mode.\n <p>This invokes {@linkplain #formatNumber(long, int, SignednessFormatMode)} with a\n <tt>mode<\/tt> parameter of <tt>{@linkplain SignednessFormatMode#DEFAULT}<\/tt>.\n@param number The number to represent\n@param radix the base in which <code>number<\/code> is represented\n@return formatted string of the number parameter in provided radix base\n@see #formatNumber(long, int, SignednessFormatMode)","static":true,"name":"formatNumber","comment":"Render number in different bases using the default signedness mode.\n This invokes  with a\n mode parameter of .","params":[{"type_long":"long","name":"number","comment":"The number to represent","type_short":"long"},{"type_long":"int","name":"radix","comment":"the base in which number is represented","type_short":"int"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"formatted string of the number parameter in provided radix base","type_short":"String"}},{"javadoc":"Provide renderings of <code>number<\/code> in different bases:\n <ul>\n <li> 0 - renders <code>number<\/code> as an escaped character sequence<\/li>\n <li> 2 - renders <code>number<\/code> as a base-2 integer<\/li>\n <li> 8 - renders <code>number<\/code> as a base-8 integer<\/li>\n <li> 10 - renders <code>number<\/code> as a base-10 integer<\/li>\n <li> 16 (default) - renders <code>number<\/code> base-16 integer<\/li>\n <\/ul>\n <table>\n <tr><th>Number<\/th><th>Radix<\/th><th>DEFAULT Mode Alias<\/th><th><i>UNSIGNED<\/i> Mode Value<\/th><th><i>SIGNED<\/i> Mode Value<\/th><\/tr>\n <tr><td>&nbsp;<\/td><td><\/td><td><i><\/i><\/td><td><\/td><td><\/td><\/tr>\n <tr align=right><td>100<\/td><td>2<\/td><td><i>UNSIGNED<\/i><\/td><td>1100100b<\/td><td>1100100b<\/td><\/tr>\n <tr align=right><td>100<\/td><td>8<\/td><td><i>UNSIGNED<\/i><\/td><td>144o<\/td><td>144o<\/td><\/tr>\n <tr align=right><td>100<\/td><td>10<\/td><td><i>SIGNED<\/i><\/td><td>100<\/td><td>100<\/td><\/tr>\n <tr align=right><td>100<\/td><td>16<\/td><td><i>UNSIGNED<\/i><\/td><td>64h<\/td><td>64h<\/td><\/tr>\n <tr><td>&nbsp;<\/td><td><\/td><td><i><\/i><\/td><td><\/td><td><\/td><\/tr>\n <tr align=right><td>-1<\/td><td>2<\/td><td><i>UNSIGNED<\/i><\/td><td>1111111111111111111111111111111111111111111111111111111111111111b<\/td><td>-1b<\/td><\/tr>\n <tr align=right><td>-1<\/td><td>8<\/td><td><i>UNSIGNED<\/i><\/td><td>1777777777777777777777o<\/td><td>-1o<\/td><\/tr>\n <tr align=right><td>-1<\/td><td>10<\/td><td><i>SIGNED<\/i><\/td><td>18446744073709551615<\/td><td>-1<\/td><\/tr>\n <tr align=right><td>-1<\/td><td>16<\/td><td><i>UNSIGNED<\/i><\/td><td>ffffffffffffffffh<\/td><td>-1h<\/td><\/tr>\n<tr><td>&nbsp;<\/td><td><\/td><td><i><\/i><\/td><td><\/td><td><\/td><\/tr>\n <tr align=right><td>-100<\/td><td>2<\/td><td><i>UNSIGNED<\/i><\/td><td>1111111111111111111111111111111111111111111111111111111110011100b<\/td><td>-1100100b<\/td><\/tr>\n <tr align=right><td>-100<\/td><td>8<\/td><td><i>UNSIGNED<\/i><\/td><td>1777777777777777777634o<\/td><td>-144o<\/td><\/tr>\n <tr align=right><td>-100<\/td><td>10<\/td><td><i>SIGNED<\/i><\/td><td>18446744073709551516<\/td><td>-100<\/td><\/tr>\n <tr align=right><td>-100<\/td><td>16<\/td><td><i>UNSIGNED<\/i><\/td><td>ffffffffffffff9ch<\/td><td>-64h<\/td><\/tr>\n <\/table>\n@param number The number to represent\n@param radix The base in which <code>number<\/code> is represented\n@param mode Specifies how the number is formatted with respect to its signed-ness\n@return number string in the given base","static":true,"name":"formatNumber","comment":"Provide renderings of number in different bases:\n \n  0 - renders number as an escaped character sequence\n  2 - renders number as a base-2 integer\n  8 - renders number as a base-8 integer\n  10 - renders number as a base-10 integer\n  16 (default) - renders number base-16 integer\n \n \n NumberRadixDEFAULT Mode AliasUNSIGNED Mode ValueSIGNED Mode Value\n \n 1002UNSIGNED1100100b1100100b\n 1008UNSIGNED144o144o\n 10010SIGNED100100\n 10016UNSIGNED64h64h\n \n -12UNSIGNED1111111111111111111111111111111111111111111111111111111111111111b-1b\n -18UNSIGNED1777777777777777777777o-1o\n -110SIGNED18446744073709551615-1\n -116UNSIGNEDffffffffffffffffh-1h\n\n -1002UNSIGNED1111111111111111111111111111111111111111111111111111111110011100b-1100100b\n -1008UNSIGNED1777777777777777777634o-144o\n -10010SIGNED18446744073709551516-100\n -10016UNSIGNEDffffffffffffff9ch-64h\n ","params":[{"type_long":"long","name":"number","comment":"The number to represent","type_short":"long"},{"type_long":"int","name":"radix","comment":"The base in which number is represented","type_short":"int"},{"type_long":"ghidra.util.SignednessFormatMode","name":"mode","comment":"Specifies how the number is formatted with respect to its signed-ness","type_short":"SignednessFormatMode"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"number string in the given base","type_short":"String"}},{"javadoc":"Parse hexadecimal digits into a byte array.\n@param hexString hexadecimal digits\n@return numeric value as a byte array, or null if string contains invalid hex characters.","static":true,"name":"convertStringToBytes","comment":"Parse hexadecimal digits into a byte array.","params":[{"type_long":"java.lang.String","name":"hexString","comment":"hexadecimal digits","type_short":"String"}],"throws":[],"return":{"type_long":"byte[]","comment":"numeric value as a byte array, or null if string contains invalid hex characters.","type_short":"byte[]"}},{"javadoc":"","static":true,"name":"condenseByteString","comment":"","params":[{"type_long":"java.lang.String","name":"hexString","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.CharSequence","comment":"","type_short":"CharSequence"}},{"javadoc":"","static":true,"name":"convertCharSequenceToBytes","comment":"","params":[{"type_long":"java.lang.CharSequence","name":"characters","comment":"","type_short":"CharSequence"}],"throws":[],"return":{"type_long":"byte[]","comment":"","type_short":"byte[]"}},{"javadoc":"Convert the given byte into a two character String, padding with a leading 0 if\n needed.\n@param b the byte\n@return the byte string","static":true,"name":"toString","comment":"Convert the given byte into a two character String, padding with a leading 0 if\n needed.","params":[{"type_long":"byte","name":"b","comment":"the byte","type_short":"byte"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the byte string","type_short":"String"}},{"javadoc":"Convert a byte array into a hexadecimal string.\n@param bytes byte array\n@return hex string representation","static":true,"name":"convertBytesToString","comment":"Convert a byte array into a hexadecimal string.","params":[{"type_long":"byte[]","name":"bytes","comment":"byte array","type_short":"byte[]"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"hex string representation","type_short":"String"}},{"javadoc":"Convert a byte array into a hexadecimal string.\n@param bytes byte array\n@param delimeter the text between byte strings\n@return hex string representation","static":true,"name":"convertBytesToString","comment":"Convert a byte array into a hexadecimal string.","params":[{"type_long":"byte[]","name":"bytes","comment":"byte array","type_short":"byte[]"},{"type_long":"java.lang.String","name":"delimeter","comment":"the text between byte strings","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"hex string representation","type_short":"String"}},{"javadoc":"Convert a byte array into a hexadecimal string.\n@param bytes byte array\n@param start start index\n@param len number of bytes to convert\n@param delimeter the text between byte strings\n@return hex string representation","static":true,"name":"convertBytesToString","comment":"Convert a byte array into a hexadecimal string.","params":[{"type_long":"byte[]","name":"bytes","comment":"byte array","type_short":"byte[]"},{"type_long":"int","name":"start","comment":"start index","type_short":"int"},{"type_long":"int","name":"len","comment":"number of bytes to convert","type_short":"int"},{"type_long":"java.lang.String","name":"delimeter","comment":"the text between byte strings","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"hex string representation","type_short":"String"}},{"javadoc":"Convert a bytes into a hexadecimal string.\n@param bytes an iterator of bytes\n@param delimiter the text between byte strings; null is allowed\n@return hex string representation","static":true,"name":"convertBytesToString","comment":"Convert a bytes into a hexadecimal string.","params":[{"type_long":"java.util.Iterator<java.lang.Byte>","name":"bytes","comment":"an iterator of bytes","type_short":"Iterator"},{"type_long":"java.lang.String","name":"delimiter","comment":"the text between byte strings; null is allowed","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"hex string representation","type_short":"String"}},{"javadoc":"Convert a bytes into a hexadecimal string.\n@param bytes an iterable of bytes\n@param delimiter the text between byte strings; null is allowed\n@return hex string representation","static":true,"name":"convertBytesToString","comment":"Convert a bytes into a hexadecimal string.","params":[{"type_long":"java.lang.Iterable<java.lang.Byte>","name":"bytes","comment":"an iterable of bytes","type_short":"Iterable"},{"type_long":"java.lang.String","name":"delimiter","comment":"the text between byte strings; null is allowed","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"hex string representation","type_short":"String"}},{"javadoc":"Convert a bytes into a hexadecimal string.\n@param bytes an stream of bytes\n@param delimiter the text between byte strings; null is allowed\n@return hex string representation","static":true,"name":"convertBytesToString","comment":"Convert a bytes into a hexadecimal string.","params":[{"type_long":"java.util.stream.Stream<java.lang.Byte>","name":"bytes","comment":"an stream of bytes","type_short":"Stream"},{"type_long":"java.lang.String","name":"delimiter","comment":"the text between byte strings; null is allowed","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"hex string representation","type_short":"String"}},{"javadoc":"Determine if the provided Number is an integer type -- Byte, Short, Integer, or Long.\n@param number the object to check for for integer-type\n@return true if the provided number is an integer-type, false otherwise","static":true,"name":"isIntegerType","comment":"Determine if the provided Number is an integer type -- Byte, Short, Integer, or Long.","params":[{"type_long":"java.lang.Number","name":"number","comment":"the object to check for for integer-type","type_short":"Number"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the provided number is an integer-type, false otherwise","type_short":"boolean"}},{"javadoc":"Determine if the provided Number class is an integer type.\n@param numClass Class of an object\n@return true if the class parameter is a integer type, false otherwise","static":true,"name":"isIntegerType","comment":"Determine if the provided Number class is an integer type.","params":[{"type_long":"java.lang.Class<?>","name":"numClass","comment":"Class of an object","type_short":"Class"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the class parameter is a integer type, false otherwise","type_short":"boolean"}},{"javadoc":"Determine if the provided Number is a floating-point type -- Float or Double.\n@param number the object to check for for floating-point-type\n@return true if the provided number is a floating-point-type, false otherwise","static":true,"name":"isFloatingPointType","comment":"Determine if the provided Number is a floating-point type -- Float or Double.","params":[{"type_long":"java.lang.Number","name":"number","comment":"the object to check for for floating-point-type","type_short":"Number"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the provided number is a floating-point-type, false otherwise","type_short":"boolean"}},{"javadoc":"Determine if the provided Number class is a floating-point type.\n@param numClass Class of an object\n@return true if the class parameter is a floating-point type, false otherwise","static":true,"name":"isFloatingPointType","comment":"Determine if the provided Number class is a floating-point type.","params":[{"type_long":"java.lang.Class<?>","name":"numClass","comment":"Class of an object","type_short":"Class"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the class parameter is a floating-point type, false otherwise","type_short":"boolean"}}],"name":"NumericUtilities","comment":"","fields":[{"type_long":"java.math.BigInteger","javadoc":"","static":true,"name":"MAX_UNSIGNED_LONG","comment":"","type_short":"BigInteger","constant_value":null},{"type_long":"java.math.BigInteger","javadoc":"","static":true,"name":"MAX_SIGNED_LONG","comment":"","type_short":"BigInteger","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"HEX_PREFIX_X","comment":"","type_short":"String","constant_value":"\"0X\""},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"HEX_PREFIX_x","comment":"","type_short":"String","constant_value":"\"0x\""},{"type_long":"java.util.Set<java.lang.Class<? extends java.lang.Number>>","javadoc":"","static":true,"name":"INTEGER_TYPES","comment":"","type_short":"Set","constant_value":null},{"type_long":"java.util.Set<java.lang.Class<? extends java.lang.Number>>","javadoc":"","static":true,"name":"FLOATINGPOINT_TYPES","comment":"","type_short":"Set","constant_value":null},{"type_long":"ghidra.util.NumericUtilities.IntegerRadixRenderer","javadoc":"","static":true,"name":"SIGNED_INTEGER_RENDERER","comment":"","type_short":"IntegerRadixRenderer","constant_value":null},{"type_long":"ghidra.util.NumericUtilities.IntegerRadixRenderer","javadoc":"","static":true,"name":"UNSIGNED_INTEGER_RENDERER","comment":"","type_short":"IntegerRadixRenderer","constant_value":null},{"type_long":"ghidra.util.NumericUtilities.IntegerRadixRenderer","javadoc":"","static":true,"name":"DEFAULT_INTEGER_RENDERER","comment":"","type_short":"IntegerRadixRenderer","constant_value":null}]}
