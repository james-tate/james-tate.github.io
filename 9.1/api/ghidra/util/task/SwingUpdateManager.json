{"implements":[],"javadoc":"A class to allow clients to buffer events.  UI components may receive numbers events to make\n changes to their underlying data model.  Further, for many of these clients, it is sufficient\n to perform one update to capture all of the changes.  In this scenario, the client can use this\n class to keep pushing off internal updates until: 1) the flurry of events has settled down, or\n 2) some specified amount of time has expired.\n <p>\n The various methods dictate when the client will get a callback:<p>\n <ul>\n \t<li>{@link #update()} - if this is the first call to <tt>update<\/tt>, then do the work\n                          immediately; otherwise, buffer the update request until the\n                          timeout has expired.<\/li>\n  <li>{@link #updateNow()} - perform the callback now.<\/li>\n  <li>{@link #updateLater()} - buffer the update request until the timeout has expired.<\/li>\n  <li>Non-blocking update now - this is a conceptual use-case, where the client wishes to perform an\n                          immediate update, but not during the current Swing event.  To achieve\n                          this, you could call something like:\n                          <pre>\n                          \tSwingUtilities.invokeLater(() -> updateManager.updateNow());\n                          <\/pre>\n  <\/li>\n <\/ul>\n\n <P> This class is safe to use in a multi-threaded environment.   State variables are guarded\n via synchronization on this object.   The Swing thread is used to perform updates, which\n guarantees that only one update will happen at a time.  There is one state variable,\n the {@link #workCount}, that is changed both in the synchronized blocks and the Swing thread\n which is an atomic variable.  This variable must be updated\/incremented when the\n synchronized variables are cleared to prevent {@link #isBusy()} from returning false when\n there is a gap between 'work posted' and 'work execution'.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructs a new SwingUpdateManager.\n@param r the runnable that performs the client work.","static":false,"name":"<init>","comment":"Constructs a new SwingUpdateManager.","params":[{"type_long":"java.lang.Runnable","name":"r","comment":"the runnable that performs the client work.","type_short":"Runnable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new SwingUpdateManager\n <p>\n <b>Note: <\/b>The <tt>minDelay<\/tt> will always be at least {@link #MIN_DELAY_FLOOR}, regardless of\n the given value.\n@param minDelay the minimum number of milliseconds to wait once the event stream stops\n                 coming in before actually updating the screen.\n@param r the runnable that performs the client work.","static":false,"name":"<init>","comment":"Constructs a new SwingUpdateManager\n \n Note: The minDelay will always be at least #MIN_DELAY_FLOOR, regardless of\n the given value.","params":[{"type_long":"int","name":"minDelay","comment":"the minimum number of milliseconds to wait once the event stream stops\n                 coming in before actually updating the screen.","type_short":"int"},{"type_long":"java.lang.Runnable","name":"r","comment":"the runnable that performs the client work.","type_short":"Runnable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new SwingUpdateManager\n <p>\n <b>Note: <\/b>The <tt>minDelay<\/tt> will always be at least {@link #MIN_DELAY_FLOOR}, regardless of\n the given value.\n@param minDelay the minimum number of milliseconds to wait once the event stream stops\n                 coming in before actually updating the screen.\n@param maxDelay the maximum amount of time to wait between gui updates.\n@param r the runnable that performs the client work.","static":false,"name":"<init>","comment":"Constructs a new SwingUpdateManager\n \n Note: The minDelay will always be at least #MIN_DELAY_FLOOR, regardless of\n the given value.","params":[{"type_long":"int","name":"minDelay","comment":"the minimum number of milliseconds to wait once the event stream stops\n                 coming in before actually updating the screen.","type_short":"int"},{"type_long":"int","name":"maxDelay","comment":"the maximum amount of time to wait between gui updates.","type_short":"int"},{"type_long":"java.lang.Runnable","name":"r","comment":"the runnable that performs the client work.","type_short":"Runnable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Constructs a new SwingUpdateManager\n <p>\n <b>Note: <\/b>The <tt>minDelay<\/tt> will always be at least {@link #MIN_DELAY_FLOOR}, regardless of\n the given value.\n@param minDelay the minimum number of milliseconds to wait once the event stream stops\n                 coming in before actually updating the screen.\n@param maxDelay the maximum amount of time to wait between gui updates.\n@param name The name of this update manager; this allows for selective trace logging\n@param r the runnable that performs the client work.","static":false,"name":"<init>","comment":"Constructs a new SwingUpdateManager\n \n Note: The minDelay will always be at least #MIN_DELAY_FLOOR, regardless of\n the given value.","params":[{"type_long":"int","name":"minDelay","comment":"the minimum number of milliseconds to wait once the event stream stops\n                 coming in before actually updating the screen.","type_short":"int"},{"type_long":"int","name":"maxDelay","comment":"the maximum amount of time to wait between gui updates.","type_short":"int"},{"type_long":"java.lang.String","name":"name","comment":"The name of this update manager; this allows for selective trace logging","type_short":"String"},{"type_long":"java.lang.Runnable","name":"r","comment":"the runnable that performs the client work.","type_short":"Runnable"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Signals to perform an update.  See the class header for the usage of the various\n update methods.","static":false,"name":"update","comment":"Signals to perform an update.  See the class header for the usage of the various\n update methods.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Signals to perform an update.  See the class header for the usage of the various\n update methods.","static":false,"name":"updateLater","comment":"Signals to perform an update.  See the class header for the usage of the various\n update methods.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Signals to perform an update.  See the class header for the usage of the various\n update methods.","static":false,"name":"updateNow","comment":"Signals to perform an update.  See the class header for the usage of the various\n update methods.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Signals to stop any buffered work.   This will not stop any in-progress work.","static":false,"name":"stop","comment":"Signals to stop any buffered work.   This will not stop any in-progress work.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if there is a pending request that hasn't started yet.  Any currently\n executing requests will not affect this call.\n@return true if there is a pending request that hasn't started yet.","static":false,"name":"hasPendingUpdates","comment":"Returns true if there is a pending request that hasn't started yet.  Any currently\n executing requests will not affect this call.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if there is a pending request that hasn't started yet.","type_short":"boolean"}},{"javadoc":"Returns true if any work is being performed or if there is buffered work.\n@return true if any work is being performed or if there is buffered work.","static":false,"name":"isBusy","comment":"Returns true if any work is being performed or if there is buffered work.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if any work is being performed or if there is buffered work.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"dispose","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isDisposed","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"toStringDebug","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"checkForWork","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"shouldDoWork","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"scheduleCheckForWork","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isTimeToWork","comment":"","params":[{"type_long":"long","name":"now","comment":"","type_short":"long"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"doWork","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"recordInception","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getInceptionFromTheFirstClassThatIsNotUs","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}}],"name":"SwingUpdateManager","comment":"A class to allow clients to buffer events.  UI components may receive numbers events to make\n changes to their underlying data model.  Further, for many of these clients, it is sufficient\n to perform one update to capture all of the changes.  In this scenario, the client can use this\n class to keep pushing off internal updates until: 1) the flurry of events has settled down, or\n 2) some specified amount of time has expired.\n \n The various methods dictate when the client will get a callback:\n \n \t#update() - if this is the first call to update, then do the work\n                          immediately; otherwise, buffer the update request until the\n                          timeout has expired.\n  #updateNow() - perform the callback now.\n  #updateLater() - buffer the update request until the timeout has expired.\n  Non-blocking update now - this is a conceptual use-case, where the client wishes to perform an\n                          immediate update, but not during the current Swing event.  To achieve\n                          this, you could call something like:\n                          \n                          \tSwingUtilities.invokeLater(() - updateManager.updateNow());\n                          \n  \n \n\n  This class is safe to use in a multi-threaded environment.   State variables are guarded\n via synchronization on this object.   The Swing thread is used to perform updates, which\n guarantees that only one update will happen at a time.  There is one state variable,\n the #workCount, that is changed both in the synchronized blocks and the Swing thread\n which is an atomic variable.  This variable must be updated\/incremented when the\n synchronized variables are cleared to prevent #isBusy() from returning false when\n there is a gap between 'work posted' and 'work execution'.","fields":[{"type_long":"long","javadoc":"","static":true,"name":"NONE","comment":"","type_short":"long","constant_value":"0"},{"type_long":"int","javadoc":"","static":true,"name":"DEFAULT_MAX_DELAY","comment":"","type_short":"int","constant_value":"30000"},{"type_long":"int","javadoc":"","static":true,"name":"MIN_DELAY_FLOOR","comment":"","type_short":"int","constant_value":"10"},{"type_long":"int","javadoc":"","static":true,"name":"DEFAULT_MIN_DELAY","comment":"","type_short":"int","constant_value":"250"},{"type_long":"java.lang.String","javadoc":"","static":true,"name":"DEFAULT_NAME","comment":"","type_short":"String","constant_value":null},{"type_long":"ghidra.util.datastruct.WeakSet<ghidra.util.task.SwingUpdateManager>","javadoc":"","static":true,"name":"instances","comment":"","type_short":"WeakSet","constant_value":null},{"type_long":"javax.swing.Timer","javadoc":"","static":false,"name":"timer","comment":"","type_short":"Timer","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"minDelay","comment":"","type_short":"int","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"maxDelay","comment":"","type_short":"int","constant_value":null},{"type_long":"java.lang.Runnable","javadoc":"","static":false,"name":"clientRunnable","comment":"","type_short":"Runnable","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"name","comment":"","type_short":"String","constant_value":null},{"type_long":"java.lang.String","javadoc":"","static":false,"name":"inceptionInformation","comment":"","type_short":"String","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"requestTime","comment":"","type_short":"long","constant_value":null},{"type_long":"long","javadoc":"","static":false,"name":"bufferingStartTime","comment":"","type_short":"long","constant_value":null},{"type_long":"boolean","javadoc":"","static":false,"name":"disposed","comment":"","type_short":"boolean","constant_value":null},{"type_long":"java.util.concurrent.atomic.AtomicInteger","javadoc":"","static":false,"name":"workCount","comment":"","type_short":"AtomicInteger","constant_value":null}]}
