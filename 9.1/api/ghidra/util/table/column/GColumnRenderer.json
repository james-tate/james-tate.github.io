{"implements":["javax.swing.table.TableCellRenderer"],"javadoc":"An interface for the {@link DynamicTableColumn}.  This allows the filtering system to stay\n in sync with the rendering system by using the display text to filter.\n \n <P>Table filtering in {@link GTable}s typically works with the following setup:\n <OL>\n \t<LI>The table has a text field that allows for quick filtering across all <B>visible<\/B> \n      columns.  The specifics of how the text filter works are defined by the \n      {@link RowFilterTransformer}, which is controlled by the user via the button at the right\n      of the filter field.  (In the absence of this button, filters are typically a 'contains'\n      filter.\n      \n      <P>The default transformer turns items to strings by, in order,:\n      <OL>\n      \t<LI>checking the the renderer's {@link #getFilterString(Object, Settings)}, \n      \t\tif a renderer is installed\n      \t<\/LI>\n      \t<LI>checking to see if the column value is an instance of {@link DisplayStringProvider}\n      \t<\/LI>\n      \t<LI>checking to see if the column value is a {@link JLabel}\n      \t<\/LI>\n      \t<LI>calling <code>toString()<\/code> on the object\n      \t<\/LI>\n      <\/OL>\n  <\/LI>\n  <LI>\n  \tThe table has the ability to perform advanced filtering based upon specific columns.  Each\n  \tcolumn's type is used to find dynamically discovered {@link ColumnConstraint}s.  These\n  \tconstraints dictate how a given column can be filtered.  The user will create filters\n  \tusing these constraints in the {@link ColumnFilterDialog} by pressing the \n  \tbutton at the far right of the filter text field.\n  \t\n  \t<P>The way the constraints are used in the filtering system, in conjunction with \n  \t   this renderer, is defined by the {@link ColumnConstraintFilterMode} via\n  \t   {@link #getColumnConstraintFilterMode()}.\n  <\/LI>\n  <LI>\n  \tAny custom filters, defined by individual clients (this is outside the scope of the \n  \tdefault filtering system)\n  <\/LI>\n <\/OL>\n@param <T> the column type","static":false,"methods":[{"javadoc":"Returns the current mode of how column constraints will be used to filter this column\n \n <P>This method is typically not overridden.  This is only needed in rare cases, such as\n when a column uses a renderer, but does *not* want this column to be filtered using\n a String column constraint.   Or, if a column uses a renderer and wants that text to \n be available as a filter, along with any other column constraints.\n@return the mode","static":false,"name":"getColumnConstraintFilterMode","comment":"Returns the current mode of how column constraints will be used to filter this column\n \n This method is typically not overridden.  This is only needed in rare cases, such as\n when a column uses a renderer, but does *not* want this column to be filtered using\n a String column constraint.   Or, if a column uses a renderer and wants that text to \n be available as a filter, along with any other column constraints.","params":[],"throws":[],"return":{"type_long":"ghidra.util.table.column.GColumnRenderer.ColumnConstraintFilterMode","comment":"the mode","type_short":"ColumnConstraintFilterMode"}},{"javadoc":"Returns a string that is suitable for use when filtering.  The returned String should \n be an unformatted (e.g., no HTML markup, icons, etc) version of what is on the screen.\n If the String returned here does not match what the user sees (that which is rendered),\n then the filtering action may confuse the user.\n@param t the column type instance\n@param settings any settings the converter may need to convert the type\n@return the unformatted String version of what is rendered in the table cell on screen","static":false,"name":"getFilterString","comment":"Returns a string that is suitable for use when filtering.  The returned String should \n be an unformatted (e.g., no HTML markup, icons, etc) version of what is on the screen.\n If the String returned here does not match what the user sees (that which is rendered),\n then the filtering action may confuse the user.","params":[{"type_long":"T","name":"t","comment":"the column type instance","type_short":"T"},{"type_long":"ghidra.docking.settings.Settings","name":"settings","comment":"any settings the converter may need to convert the type","type_short":"Settings"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the unformatted String version of what is rendered in the table cell on screen","type_short":"String"}},{"javadoc":"A convenience method for primitive-based\/wrapper-based renderers to signal that they\n should not be using text to filter.  \n \n <P>The basic wrapper types, like Number, and some others, like {@link Date}, have special\n built-in filtering capabilities.  Columns whose column type is one of the wrapper classes\n will not have their {@link #getFilterString(Object, Settings)} methods called.  They can\n stub out those methods by throwing the exception returned by this method.\n@return the new exception\n@see AbstractWrapperTypeColumnRenderer","static":false,"name":"createWrapperTypeException","comment":"A convenience method for primitive-based\/wrapper-based renderers to signal that they\n should not be using text to filter.  \n \n The basic wrapper types, like Number, and some others, like Date, have special\n built-in filtering capabilities.  Columns whose column type is one of the wrapper classes\n will not have their #getFilterString(Object, Settings) methods called.  They can\n stub out those methods by throwing the exception returned by this method.","params":[],"throws":[],"return":{"type_long":"ghidra.util.exception.AssertException","comment":"the new exception","type_short":"AssertException"}}],"name":"GColumnRenderer","comment":"An interface for the DynamicTableColumn.  This allows the filtering system to stay\n in sync with the rendering system by using the display text to filter.\n \n Table filtering in GTables typically works with the following setup:\n \n \tThe table has a text field that allows for quick filtering across all visible \n      columns.  The specifics of how the text filter works are defined by the \n      RowFilterTransformer, which is controlled by the user via the button at the right\n      of the filter field.  (In the absence of this button, filters are typically a 'contains'\n      filter.\n      \n      The default transformer turns items to strings by, in order,:\n      \n      \tchecking the the renderer's #getFilterString(Object, Settings), \n      \t\tif a renderer is installed\n      \t\n      \tchecking to see if the column value is an instance of DisplayStringProvider\n      \t\n      \tchecking to see if the column value is a JLabel\n      \t\n      \tcalling toString() on the object\n      \t\n      \n  \n  \n  \tThe table has the ability to perform advanced filtering based upon specific columns.  Each\n  \tcolumn's type is used to find dynamically discovered ColumnConstraints.  These\n  \tconstraints dictate how a given column can be filtered.  The user will create filters\n  \tusing these constraints in the ColumnFilterDialog by pressing the \n  \tbutton at the far right of the filter text field.\n  \t\n  \tThe way the constraints are used in the filtering system, in conjunction with \n  \t   this renderer, is defined by the ColumnConstraintFilterMode via\n  \t   #getColumnConstraintFilterMode().\n  \n  \n  \tAny custom filters, defined by individual clients (this is outside the scope of the \n  \tdefault filtering system)\n  \n ","fields":[]}
