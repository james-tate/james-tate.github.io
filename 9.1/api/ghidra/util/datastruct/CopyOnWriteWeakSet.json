{"implements":[],"javadoc":"A set that avoids {@link ConcurrentModificationException}s by copying the internal storage \n <b>for every mutation operation<\/b>.  Thus, this data structure is only efficient when the \n number of event notification operations significantly out numbers mutations to this structure\n (e.g., adding and removing items.\n <p>\n An example use cases where using this class is a good fit would be a listener list where \n listeners are added during initialization, but not after that.   Further, this hypothetical \n list fires a large number of events.\n <p>\n A bad use of this class would be as a container to store widgets where the container the \n contents are changed often, but iterated over very little.\n <p>\n Finally, if this structure is only ever used from a single thread, like the Swing thread, then\n you do not need the overhead of this class, as the Swing thread synchronous access guarantees\n that the structure cannot be mutated while it is being iterated.  See \n {@link WeakDataStructureFactory#createSingleThreadAccessWeakSet()}.\n@param <T>\n@see WeakSet","static":false,"extends":"ghidra.util.datastruct.WeakSet","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"iterator","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Iterator<T>","comment":"","type_short":"Iterator"}},{"javadoc":"","static":false,"name":"add","comment":"","params":[{"type_long":"T","name":"t","comment":"","type_short":"T"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"remove","comment":"","params":[{"type_long":"T","name":"t","comment":"","type_short":"T"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clear","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"values","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Collection<T>","comment":"","type_short":"Collection"}},{"javadoc":"","static":false,"name":"isEmpty","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"size","comment":"","params":[],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":false,"name":"contains","comment":"","params":[{"type_long":"T","name":"t","comment":"","type_short":"T"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"CopyOnWriteWeakSet","comment":"A set that avoids ConcurrentModificationExceptions by copying the internal storage \n for every mutation operation.  Thus, this data structure is only efficient when the \n number of event notification operations significantly out numbers mutations to this structure\n (e.g., adding and removing items.\n \n An example use cases where using this class is a good fit would be a listener list where \n listeners are added during initialization, but not after that.   Further, this hypothetical \n list fires a large number of events.\n \n A bad use of this class would be as a container to store widgets where the container the \n contents are changed often, but iterated over very little.\n \n Finally, if this structure is only ever used from a single thread, like the Swing thread, then\n you do not need the overhead of this class, as the Swing thread synchronous access guarantees\n that the structure cannot be mutated while it is being iterated.  See \n WeakDataStructureFactory#createSingleThreadAccessWeakSet().","fields":[]}
