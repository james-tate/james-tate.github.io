{"implements":[],"javadoc":"","static":false,"methods":[{"javadoc":"Callback indicating that an absolute stack reference was encountered.  A non-load\/store\n operation will have a -1 for both storageSpaceId and size.\n@param op pcode operation\n@param instrOpIndex opIndex associated with reference or -1 if it could not be determined\n@param stackOffset stack offset\n@param size access size or -1 if not applicable\n@param storageSpaceID storage space ID or -1 if not applicable\n@param refType read\/write\/data reference type\n@param monitor task monitor\n@throws CancelledException if callback canceled by monitor","static":false,"name":"stackReference","comment":"Callback indicating that an absolute stack reference was encountered.  A non-load\/store\n operation will have a -1 for both storageSpaceId and size.","params":[{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"op","comment":"pcode operation","type_short":"PcodeOp"},{"type_long":"int","name":"instrOpIndex","comment":"opIndex associated with reference or -1 if it could not be determined","type_short":"int"},{"type_long":"int","name":"stackOffset","comment":"stack offset","type_short":"int"},{"type_long":"int","name":"size","comment":"access size or -1 if not applicable","type_short":"int"},{"type_long":"int","name":"storageSpaceID","comment":"storage space ID or -1 if not applicable","type_short":"int"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"read\/write\/data reference type","type_short":"RefType"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if callback canceled by monitor","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Callback indicating that a computed stack reference was encountered.  A non-load\/store\n operation will have a -1 for both storageSpaceId and size.\n@param op pcode operation\n@param instrOpIndex opIndex associated with reference or -1 if it could not be determined\n@param computedStackOffset stack offset computation (i.e., VarnodeOperation w\/ stack pointer)\n@param size access size or -1 if not applicable\n@param storageSpaceID storage space ID or -1 if not applicable\n@param refType read\/write\/data reference type\n@param monitor task monitor\n@throws CancelledException if callback canceled by monitor","static":false,"name":"stackReference","comment":"Callback indicating that a computed stack reference was encountered.  A non-load\/store\n operation will have a -1 for both storageSpaceId and size.","params":[{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"op","comment":"pcode operation","type_short":"PcodeOp"},{"type_long":"int","name":"instrOpIndex","comment":"opIndex associated with reference or -1 if it could not be determined","type_short":"int"},{"type_long":"ghidra.util.state.VarnodeOperation","name":"computedStackOffset","comment":"stack offset computation (i.e., VarnodeOperation w\/ stack pointer)","type_short":"VarnodeOperation"},{"type_long":"int","name":"size","comment":"access size or -1 if not applicable","type_short":"int"},{"type_long":"int","name":"storageSpaceID","comment":"storage space ID or -1 if not applicable","type_short":"int"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"read\/write\/data reference type","type_short":"RefType"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if callback canceled by monitor","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Callback indicating that an absolute memory reference was encountered\n@param op pcode operation\n@param instrOpIndex opIndex associated with reference or -1 if it could not be determined\n@param storageVarnode absolute storage Varnode\n@param refType read\/write\/data reference type\n@param monitor task monitor\n@throws CancelledException if callback canceled by monitor","static":false,"name":"dataReference","comment":"Callback indicating that an absolute memory reference was encountered","params":[{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"op","comment":"pcode operation","type_short":"PcodeOp"},{"type_long":"int","name":"instrOpIndex","comment":"opIndex associated with reference or -1 if it could not be determined","type_short":"int"},{"type_long":"ghidra.program.model.pcode.Varnode","name":"storageVarnode","comment":"absolute storage Varnode","type_short":"Varnode"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"read\/write\/data reference type","type_short":"RefType"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if callback canceled by monitor","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Callback indicating that an indirect\/computed memory reference was encountered using an indirect\/computed offset\n@param op pcode operation\n@param instrOpIndex opIndex associated with reference or -1 if it could not be determined\n@param offsetVarnode indirect\/computed offset\n@param size access size or -1 if not applicable\n@param storageSpaceID storage space ID\n@param refType read\/write\/data reference type\n@param monitor task monitor\n@throws CancelledException if callback canceled by monitor","static":false,"name":"indirectDataReference","comment":"Callback indicating that an indirect\/computed memory reference was encountered using an indirect\/computed offset","params":[{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"op","comment":"pcode operation","type_short":"PcodeOp"},{"type_long":"int","name":"instrOpIndex","comment":"opIndex associated with reference or -1 if it could not be determined","type_short":"int"},{"type_long":"ghidra.program.model.pcode.Varnode","name":"offsetVarnode","comment":"indirect\/computed offset","type_short":"Varnode"},{"type_long":"int","name":"size","comment":"access size or -1 if not applicable","type_short":"int"},{"type_long":"int","name":"storageSpaceID","comment":"storage space ID","type_short":"int"},{"type_long":"ghidra.program.model.symbol.RefType","name":"refType","comment":"read\/write\/data reference type","type_short":"RefType"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if callback canceled by monitor","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Callback indicating that a call\/branch destination was identified.  \n Analyzer should create reference if appropriate\n Keep in mind that there could be other unidentified destinations.\n@param op branch or call flow operation\n@param instrOpIndex opIndex associated with reference or -1 if it could not be determined\n@param destAddr destination address\n@param results contains previous states leading upto the currentState\n@param currentState current state at the branch\/call\n@param monitor task monitor\n@return true if destination should be disassembled if not already\n@throws CancelledException if callback canceled by monitor","static":false,"name":"resolvedFlow","comment":"Callback indicating that a call\/branch destination was identified.  \n Analyzer should create reference if appropriate\n Keep in mind that there could be other unidentified destinations.","params":[{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"op","comment":"branch or call flow operation","type_short":"PcodeOp"},{"type_long":"int","name":"instrOpIndex","comment":"opIndex associated with reference or -1 if it could not be determined","type_short":"int"},{"type_long":"ghidra.program.model.address.Address","name":"destAddr","comment":"destination address","type_short":"Address"},{"type_long":"ghidra.util.state.ContextState","name":"currentState","comment":"current state at the branch\/call","type_short":"ContextState"},{"type_long":"ghidra.util.state.ResultsState","name":"results","comment":"contains previous states leading upto the currentState","type_short":"ResultsState"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if callback canceled by monitor","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"true if destination should be disassembled if not already","type_short":"boolean"}},{"javadoc":"Callback indicating that a computed call\/branch destination was not resolved.\n@param op indirect branch or call flow operation\n@param instrOpIndex opIndex associated with reference or -1 if it could not be determined\n@param destination destination identified as a Varnode (may be an expression represented by\n a {@link VarnodeOperation}\n@param results contains previous states leading upto the currentState\n@param currentState current state at the branch\/call\n@param monitor task monitor\n@return list of resolved destinations which should be used or null.  List of destination\n addresses will trigger disassembly where necessary.\n@throws CancelledException if callback cancelled by monitor","static":false,"name":"unresolvedIndirectFlow","comment":"Callback indicating that a computed call\/branch destination was not resolved.","params":[{"type_long":"ghidra.program.model.pcode.PcodeOp","name":"op","comment":"indirect branch or call flow operation","type_short":"PcodeOp"},{"type_long":"int","name":"instrOpIndex","comment":"opIndex associated with reference or -1 if it could not be determined","type_short":"int"},{"type_long":"ghidra.program.model.pcode.Varnode","name":"destination","comment":"destination identified as a Varnode (may be an expression represented by\n a VarnodeOperation","type_short":"Varnode"},{"type_long":"ghidra.util.state.ContextState","name":"currentState","comment":"current state at the branch\/call","type_short":"ContextState"},{"type_long":"ghidra.util.state.ResultsState","name":"results","comment":"contains previous states leading upto the currentState","type_short":"ResultsState"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if callback cancelled by monitor","type_short":"CancelledException"}],"return":{"type_long":"java.util.List<ghidra.program.model.address.Address>","comment":"list of resolved destinations which should be used or null.  List of destination\n addresses will trigger disassembly where necessary.","type_short":"List"}}],"name":"FunctionAnalyzer","comment":"","fields":[]}
