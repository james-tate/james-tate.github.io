{"implements":[],"javadoc":"The FileWatcher *watches* a single file and fires a change notification whenever the file \n is modified. A couple notes:\n \n 1. To keep from processing change events every time the file is modified, which may be\n    too frequent and cause processing issues, we use a simple polling mechanism.  \n    \n 2. Changes in the file are identified by inspecting the {@link File#lastModified()}\n    timestamp. \n \n 3. The {@link WatchService} mechanism is not being used here since we cannot specify a \n    polling rate.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Constructor. Creates a new {@link Executor} that will inspect the file at regular \n intervals.  Users must call {@link #start()} to begin polling.\n@param file the file to be watched","static":false,"name":"<init>","comment":"Constructor. Creates a new Executor that will inspect the file at regular \n intervals.  Users must call #start() to begin polling.","params":[{"type_long":"java.io.File","name":"file","comment":"the file to be watched","type_short":"File"},{"type_long":"ghidra.framework.main.logviewer.event.FVEventListener","name":"eventListener","comment":"","type_short":"FVEventListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Suspends the timer so it will no longer poll. This does not perform a shutdown, so the\n future may be scheduled again.","static":false,"name":"stop","comment":"Suspends the timer so it will no longer poll. This does not perform a shutdown, so the\n future may be scheduled again.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Starts polling, or resumes polling if previously stopped.","static":false,"name":"start","comment":"Starts polling, or resumes polling if previously stopped.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Checks the timestamp of the given file to see if it has changed.  If so, returns true.\n@param file\n@return ","static":false,"name":"isFileUpdated","comment":"Checks the timestamp of the given file to see if it has changed.  If so, returns true.","params":[{"type_long":"java.io.File","name":"file","comment":"","type_short":"File"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}}],"name":"FileWatcher","comment":"The FileWatcher *watches* a single file and fires a change notification whenever the file \n is modified. A couple notes:\n \n 1. To keep from processing change events every time the file is modified, which may be\n    too frequent and cause processing issues, we use a simple polling mechanism.  \n    \n 2. Changes in the file are identified by inspecting the File#lastModified()\n    timestamp. \n \n 3. The WatchService mechanism is not being used here since we cannot specify a \n    polling rate.","fields":[{"type_long":"long","javadoc":"","static":false,"name":"timestamp","comment":"","type_short":"long","constant_value":null},{"type_long":"int","javadoc":"","static":false,"name":"POLLING_INTERVAL_SEC","comment":"","type_short":"int","constant_value":"5"},{"type_long":"int","javadoc":"","static":false,"name":"POLLING_DELAY_SEC","comment":"","type_short":"int","constant_value":"0"},{"type_long":"java.io.File","javadoc":"","static":false,"name":"file","comment":"","type_short":"File","constant_value":null},{"type_long":"java.util.concurrent.ScheduledFuture<?>","javadoc":"","static":false,"name":"future","comment":"","type_short":"ScheduledFuture","constant_value":null},{"type_long":"java.util.concurrent.ScheduledExecutorService","javadoc":"","static":false,"name":"executor","comment":"","type_short":"ScheduledExecutorService","constant_value":null},{"type_long":"ghidra.framework.main.logviewer.event.FVEventListener","javadoc":"","static":false,"name":"eventListener","comment":"","type_short":"FVEventListener","constant_value":null}]}
