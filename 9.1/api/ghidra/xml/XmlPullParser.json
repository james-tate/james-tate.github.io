{"implements":[],"javadoc":"An interface describing the API for the XML pull parsing system. This is\n similar to XmlParser, except that it has slightly different methods and IS\n case sensitive, conforming to the XML spec.","static":false,"methods":[{"javadoc":"Returns the name of this parser.\n@return the name of this parser","static":false,"name":"getName","comment":"Returns the name of this parser.","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"the name of this parser","type_short":"String"}},{"javadoc":"Returns the value of the attribute of the processing instruction.\n For example, <code>&lt;?program_dtd version=\"1\"?&gt;<\/code>\n@param name the name of the processing instruction\n@param attribute the name of the attribute\n@return the value of the attribute of the processing instruction","static":false,"name":"getProcessingInstruction","comment":"Returns the value of the attribute of the processing instruction.\n For example, ?program_dtd version=\"1\"?","params":[{"type_long":"java.lang.String","name":"name","comment":"the name of the processing instruction","type_short":"String"},{"type_long":"java.lang.String","name":"attribute","comment":"the name of the attribute","type_short":"String"}],"throws":[],"return":{"type_long":"java.lang.String","comment":"the value of the attribute of the processing instruction","type_short":"String"}},{"javadoc":"Returns the current line number where the parser is (note that this may\n actually be ahead of where you think it is because of look-ahead and\n caching).\n@return the current line number","static":false,"name":"getLineNumber","comment":"Returns the current line number where the parser is (note that this may\n actually be ahead of where you think it is because of look-ahead and\n caching).","params":[],"throws":[],"return":{"type_long":"int","comment":"the current line number","type_short":"int"}},{"javadoc":"Returns the current column number where the parser is (note that this may\n actually be ahead of where you think it is because of look-ahead and\n caching).\n@return the current column number","static":false,"name":"getColumnNumber","comment":"Returns the current column number where the parser is (note that this may\n actually be ahead of where you think it is because of look-ahead and\n caching).","params":[],"throws":[],"return":{"type_long":"int","comment":"the current column number","type_short":"int"}},{"javadoc":"Returns whether the parser will return content elements as well as start\n and end elements (they're always accumulated and provided in the\n appropriate end element).\n@return whether the parser will return content elements","static":false,"name":"isPullingContent","comment":"Returns whether the parser will return content elements as well as start\n and end elements (they're always accumulated and provided in the\n appropriate end element).","params":[],"throws":[],"return":{"type_long":"boolean","comment":"whether the parser will return content elements","type_short":"boolean"}},{"javadoc":"Set whether the parser will return content elements. Note that this\n method may throw an exception if the parser cannot comply with the\n setting (usually when setting to true).\n@param pullingContent whether the parser will return content elements","static":false,"name":"setPullingContent","comment":"Set whether the parser will return content elements. Note that this\n method may throw an exception if the parser cannot comply with the\n setting (usually when setting to true).","params":[{"type_long":"boolean","name":"pullingContent","comment":"whether the parser will return content elements","type_short":"boolean"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"The current element level, as if the XML document was a tree. The root\n element is at level 0. Each child is at a level one higher than its\n parent.\n \n Note that this is the same as peek().getLevel().\n@return the current element level","static":false,"name":"getCurrentLevel","comment":"The current element level, as if the XML document was a tree. The root\n element is at level 0. Each child is at a level one higher than its\n parent.\n \n Note that this is the same as peek().getLevel().","params":[],"throws":[],"return":{"type_long":"int","comment":"the current element level","type_short":"int"}},{"javadoc":"Returns whether there is a next element.\n@return whether there is a next element","static":false,"name":"hasNext","comment":"Returns whether there is a next element.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"whether there is a next element","type_short":"boolean"}},{"javadoc":"Returns the next element, without removing it from the queue (assuming\n there is such a next element). This is very useful for examining the next\n item to decide who should handle the subtree, and then delegating to a\n subordinate with the parser state intact.\n@return the next element, without removing it","static":false,"name":"peek","comment":"Returns the next element, without removing it from the queue (assuming\n there is such a next element). This is very useful for examining the next\n item to decide who should handle the subtree, and then delegating to a\n subordinate with the parser state intact.","params":[],"throws":[],"return":{"type_long":"ghidra.xml.XmlElement","comment":"the next element, without removing it","type_short":"XmlElement"}},{"javadoc":"Returns the next element, removing it from the queue (assuming there is\n such a next element). This method should be used RARELY. Typically, when\n you're reading XML, you almost always at least know that you're either\n starting or ending a subtree, so start() or end() should be used instead.\n The only time you really might need to use this is if you don't really\n know where you are and you need to pop elements off until you synchronize\n back into a sane state.\n@return the next element, removing it","static":false,"name":"next","comment":"Returns the next element, removing it from the queue (assuming there is\n such a next element). This method should be used RARELY. Typically, when\n you're reading XML, you almost always at least know that you're either\n starting or ending a subtree, so start() or end() should be used instead.\n The only time you really might need to use this is if you don't really\n know where you are and you need to pop elements off until you synchronize\n back into a sane state.","params":[],"throws":[],"return":{"type_long":"ghidra.xml.XmlElement","comment":"the next element, removing it","type_short":"XmlElement"}},{"javadoc":"Returns the next element, which must be a start element, and must be one\n of the supplied names (if provided). This method is very useful for\n starting a subtree, and throws an XmlException if the next element does\n not conform to your specification.\n@param names optional vararg Strings which start element name must be one\n            of\n@return the next element (which is a start element)","static":false,"name":"start","comment":"Returns the next element, which must be a start element, and must be one\n of the supplied names (if provided). This method is very useful for\n starting a subtree, and throws an XmlException if the next element does\n not conform to your specification.","params":[{"type_long":"java.lang.String[]","name":"names","comment":"optional vararg Strings which start element name must be one\n            of","type_short":"java.lang.String[]"}],"throws":[],"return":{"type_long":"ghidra.xml.XmlElement","comment":"the next element (which is a start element)","type_short":"XmlElement"}},{"javadoc":"Returns the next element, which must be an end element. The name doesn't\n matter. This method throws an XmlException if the next element is not an\n end element. Use this method when you really know you're matching the\n right end and want to avoid extra constraint checks.\n@return the next element (which is an end element)","static":false,"name":"end","comment":"Returns the next element, which must be an end element. The name doesn't\n matter. This method throws an XmlException if the next element is not an\n end element. Use this method when you really know you're matching the\n right end and want to avoid extra constraint checks.","params":[],"throws":[],"return":{"type_long":"ghidra.xml.XmlElement","comment":"the next element (which is an end element)","type_short":"XmlElement"}},{"javadoc":"Returns the next element, which must be an end element, and must match\n the supplied XmlElement's name (presumably the start element of the\n subtree). This method throws an XmlException if the next element is not\n an end element, or if the name doesn't match.\n@param element the presumed start element to match names\n@return the next element (which is an end element)","static":false,"name":"end","comment":"Returns the next element, which must be an end element, and must match\n the supplied XmlElement's name (presumably the start element of the\n subtree). This method throws an XmlException if the next element is not\n an end element, or if the name doesn't match.","params":[{"type_long":"ghidra.xml.XmlElement","name":"element","comment":"the presumed start element to match names","type_short":"XmlElement"}],"throws":[],"return":{"type_long":"ghidra.xml.XmlElement","comment":"the next element (which is an end element)","type_short":"XmlElement"}},{"javadoc":"Returns the next element, which must be a start element, and must be one\n of the supplied names (if provided). This method is very useful for\n starting a subtree, but differs from start(...) in that failures are\n soft. This means that if the next element isn't a start element, or\n doesn't match one of the optional provided names, null is returned\n (instead of raising an XmlException).\n@param names optional vararg Strings which start element name must be one\n            of\n@return the next element (which is a start element) or null","static":false,"name":"softStart","comment":"Returns the next element, which must be a start element, and must be one\n of the supplied names (if provided). This method is very useful for\n starting a subtree, but differs from start(...) in that failures are\n soft. This means that if the next element isn't a start element, or\n doesn't match one of the optional provided names, null is returned\n (instead of raising an XmlException).","params":[{"type_long":"java.lang.String[]","name":"names","comment":"optional vararg Strings which start element name must be one\n            of","type_short":"java.lang.String[]"}],"throws":[],"return":{"type_long":"ghidra.xml.XmlElement","comment":"the next element (which is a start element) or null","type_short":"XmlElement"}},{"javadoc":"Discards the current subtree. If the current element (peek()) is a\n content or end element, then just that element is discarded. If it's a\n start element, then the entire subtree starting with the start element is\n discarded (i.e. next() is called until the current element is now the\n element after the subtree's end element).\n@return the number of elements discarded","static":false,"name":"discardSubTree","comment":"Discards the current subtree. If the current element (peek()) is a\n content or end element, then just that element is discarded. If it's a\n start element, then the entire subtree starting with the start element is\n discarded (i.e. next() is called until the current element is now the\n element after the subtree's end element).","params":[],"throws":[],"return":{"type_long":"int","comment":"the number of elements discarded","type_short":"int"}},{"javadoc":"Discards the current subtree. The current element must be a start\n element, and must be named name, otherwise an XmlException is thrown.\n@param name what the current start element must be named\n@return the number of elements discarded","static":false,"name":"discardSubTree","comment":"Discards the current subtree. The current element must be a start\n element, and must be named name, otherwise an XmlException is thrown.","params":[{"type_long":"java.lang.String","name":"name","comment":"what the current start element must be named","type_short":"String"}],"throws":[],"return":{"type_long":"int","comment":"the number of elements discarded","type_short":"int"}},{"javadoc":"Discards a subtree. The element provided is used as the \"start\" of the\n subtree (although it doesn't actually have to be a start element; only\n its name and level are used). The queue of elements is discarded such\n that the last element discarded is an end element, has the same name as\n the provided element, and is the same level as the provided element. If\n the provided element's level is higher than the current level, then\n nothing is discarded.\n@param element the element provided as the \"start\" element\n@return the number of elements discarded","static":false,"name":"discardSubTree","comment":"Discards a subtree. The element provided is used as the \"start\" of the\n subtree (although it doesn't actually have to be a start element; only\n its name and level are used). The queue of elements is discarded such\n that the last element discarded is an end element, has the same name as\n the provided element, and is the same level as the provided element. If\n the provided element's level is higher than the current level, then\n nothing is discarded.","params":[{"type_long":"ghidra.xml.XmlElement","name":"element","comment":"the element provided as the \"start\" element","type_short":"XmlElement"}],"throws":[],"return":{"type_long":"int","comment":"the number of elements discarded","type_short":"int"}},{"javadoc":"Disposes all resources of the parser. It's important that this is called\n when a client is finished with the parser, because this allows files to\n be closed, threads to be stopped, etc.","static":false,"name":"dispose","comment":"Disposes all resources of the parser. It's important that this is called\n when a client is finished with the parser, because this allows files to\n be closed, threads to be stopped, etc.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"XmlPullParser","comment":"An interface describing the API for the XML pull parsing system. This is\n similar to XmlParser, except that it has slightly different methods and IS\n case sensitive, conforming to the XML spec.","fields":[]}
