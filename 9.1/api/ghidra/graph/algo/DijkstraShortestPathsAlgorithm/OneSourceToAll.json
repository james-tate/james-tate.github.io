{"implements":[],"javadoc":"A class representing all optimal paths from a given source to every other (reachable) vertex\n in the graph\n \n This is the workhorse of path computation, and implements Dijkstra's Shortest Path algorithm\n from one source to all destinations. We considered using JUNG to store the graph and compute\n the paths, but we could not, because we would like to find all paths having the\n optimal distance. If there are ties, JUNG's implementation chooses one arbitrarily; we would\n like all tied paths.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Compute the shortest paths from a given vertex to all other reachable vertices in the\n graph\n@param src the source (seed) vertex","static":false,"name":"<init>","comment":"Compute the shortest paths from a given vertex to all other reachable vertices in the\n graph","params":[{"type_long":"V","name":"src","comment":"the source (seed) vertex","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Recover the shortest paths from the source to the given destination, if it is reachable\n@param dst the destination\n@return a collection of the shortest paths from source to destination, or the empty set","static":false,"name":"computeOptimalPathsTo","comment":"Recover the shortest paths from the source to the given destination, if it is reachable","params":[{"type_long":"V","name":"dst","comment":"the destination","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Collection<java.util.Deque<E>>","comment":"a collection of the shortest paths from source to destination, or the empty set","type_short":"Collection"}},{"javadoc":"Add the shortest paths from the source to the given destination into the given\n collection\n \n This is used internally to recover the shortest paths\n@param paths a place to store the recovered paths\n@param dst the destination","static":false,"name":"addPathsTo","comment":"Add the shortest paths from the source to the given destination into the given\n collection\n \n This is used internally to recover the shortest paths","params":[{"type_long":"java.util.Collection<java.util.Deque<E>>","name":"paths","comment":"a place to store the recovered paths","type_short":"Collection"},{"type_long":"V","name":"dst","comment":"the destination","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Add the shortest paths from source to a given intermediate, continuing along a given\n path to the final destination, into the given collection\n \n This is a recursive method for constructing the shortest paths overall. Assuming the\n given path from intermediate to final destination is the shortest, we can show by\n induction, the computed paths from source to destination are the shortest.\n@param paths a place to store the recovered paths\n@param prev the intermediate destination\n@param soFar a (shortest) path from intermediate to final destination","static":false,"name":"addPathsTo","comment":"Add the shortest paths from source to a given intermediate, continuing along a given\n path to the final destination, into the given collection\n \n This is a recursive method for constructing the shortest paths overall. Assuming the\n given path from intermediate to final destination is the shortest, we can show by\n induction, the computed paths from source to destination are the shortest.","params":[{"type_long":"java.util.Collection<java.util.Deque<E>>","name":"paths","comment":"a place to store the recovered paths","type_short":"Collection"},{"type_long":"V","name":"prev","comment":"the intermediate destination","type_short":"V"},{"type_long":"java.util.Deque<E>","name":"soFar","comment":"a (shortest) path from intermediate to final destination","type_short":"Deque"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Update the record for the given destination with a new offer of shortest distance\n \n If either the record doesn't exist yet, or the new offer beats the current best, then\n a new record is created and replaces the current record. If present, the list of best\n inbound edges is cleared -- because they all correspond to a distance that has just been\n beat. The node is also added and\/or moved forward in the queue of unvisited vertices.\n \n If the record exists, and the new offer ties the current offer, nothing happens, but\n the method still returns true, since the corresponding inbound edge could be optimal.\n \n If the record's current best beats the offer, nothing happens, and the method returns\n false, indicating the inbound edge is definitely not optimal.\n@param dest the destination whose record to update\n@param newDist the distance offer\n@return true iff the offer is equal to or better than the record's current best","static":false,"name":"addOrUpdate","comment":"Update the record for the given destination with a new offer of shortest distance\n \n If either the record doesn't exist yet, or the new offer beats the current best, then\n a new record is created and replaces the current record. If present, the list of best\n inbound edges is cleared -- because they all correspond to a distance that has just been\n beat. The node is also added and\/or moved forward in the queue of unvisited vertices.\n \n If the record exists, and the new offer ties the current offer, nothing happens, but\n the method still returns true, since the corresponding inbound edge could be optimal.\n \n If the record's current best beats the offer, nothing happens, and the method returns\n false, indicating the inbound edge is definitely not optimal.","params":[{"type_long":"V","name":"dest","comment":"the destination whose record to update","type_short":"V"},{"type_long":"double","name":"newDist","comment":"the distance offer","type_short":"double"}],"throws":[],"return":{"type_long":"boolean","comment":"true iff the offer is equal to or better than the record's current best","type_short":"boolean"}},{"javadoc":"Compute paths, building out the graph until all reachable vertices have been visited","static":false,"name":"fill","comment":"Compute paths, building out the graph until all reachable vertices have been visited","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Perform one iteration of Dijskstra's path finding algorithm\n@param from the vertex to visit for this iteration","static":false,"name":"fillStep","comment":"Perform one iteration of Dijskstra's path finding algorithm","params":[{"type_long":"V","name":"from","comment":"the vertex to visit for this iteration","type_short":"V"},{"type_long":"double","name":"dist","comment":"","type_short":"double"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"OneSourceToAll","comment":"A class representing all optimal paths from a given source to every other (reachable) vertex\n in the graph\n \n This is the workhorse of path computation, and implements Dijkstra's Shortest Path algorithm\n from one source to all destinations. We considered using JUNG to store the graph and compute\n the paths, but we could not, because we would like to find all paths having the\n optimal distance. If there are ties, JUNG's implementation chooses one arbitrarily; we would\n like all tied paths.","fields":[{"type_long":"ghidra.generic.util.datastruct.DynamicValueSortedTreeMap<V,java.lang.Double>","javadoc":"","static":false,"name":"queueByDistance","comment":"","type_short":"DynamicValueSortedTreeMap","constant_value":null},{"type_long":"java.util.Map<V,java.lang.Double>","javadoc":"","static":false,"name":"visitedDistance","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<E>>","javadoc":"","static":false,"name":"bestIns","comment":"","type_short":"Map","constant_value":null},{"type_long":"V","javadoc":"","static":false,"name":"source","comment":"","type_short":"V","constant_value":null}]}
