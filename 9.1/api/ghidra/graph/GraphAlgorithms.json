{"implements":[],"javadoc":"A set of convenience methods for performing graph algorithms on a graph.\n \n <P>Some definitions:\n <OL>\n \t   <LI>\n \t\t<B>dominance:<\/B> \n \t\t\t\t\ta node 'a' dominates node 'b' if all paths from start to 'b' contain 'a';\n\t\t            a node always dominates itself (except in 'strict dominance', which is all\n\t\t            dominators except for itself)\n\n\t   <LI>\n\t\t<B>post-dominance:<\/B> \n\t\t\t\t\t A node 'b' is said to post-dominate node 'a' if all paths from 'a'\n\t\t             to END contain 'b'\n\n\t   <LI>\n\t\t<B>immediate dominator:<\/B> \n\t\t\t\t\tthe closest dominator of a node\n\n\t   <LI>\n\t\t<B>dominance tree:<\/B>  \n\t\t\t\t\tA dominator tree is a tree where each node's children are those nodes \n\t\t\t\t\tit *immediately* dominates (a idom b)\n\n     <LI>\n     \t<B>dominance frontier:<\/B> \n     \t\t\t\tthe immediate successors of the nodes dominated by 'a'; it is the set of \n     \t\t\t\tnodes where d's dominance stops.\n     \n     <LI>\n     \t<B>strongly connected components:<\/B> \n     \t\t\t\ta graph is said to be strongly connected if every vertex is reachable \n     \t\t\t\tfrom every other vertex. The strongly connected components \n     \t\t\t\tof an arbitrary directed graph form a partition into \n     \t\t\t\tsubgraphs that are themselves strongly connected.\n     <LI>\n     \t<B>graph density:<\/B>\n     <PRE>\n                        E\n          Density =  --------\n                      V(V-1)\n\t\t<\/PRE>\n <\/OL>","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns all source vertices (those with no incoming edges) in the graph.\n@param g the graph\n@return source vertices","static":true,"name":"getSources","comment":"Returns all source vertices (those with no incoming edges) in the graph.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"source vertices","type_short":"Set"}},{"javadoc":"Returns all sink vertices (those with no outgoing edges) in the graph.\n@param g the graph\n@return sink vertices","static":true,"name":"getSinks","comment":"Returns all sink vertices (those with no outgoing edges) in the graph.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"sink vertices","type_short":"Set"}},{"javadoc":"Returns all descendants for the given vertices in the given graph.  Descendants for a given\n vertex are all nodes at the outgoing side of an edge, as well as their outgoing \n vertices, etc.\n@param g the graph\n@param vertices the vertices for which to find descendants\n@return the descendants","static":true,"name":"getDescendants","comment":"Returns all descendants for the given vertices in the given graph.  Descendants for a given\n vertex are all nodes at the outgoing side of an edge, as well as their outgoing \n vertices, etc.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"java.util.Collection<V>","name":"vertices","comment":"the vertices for which to find descendants","type_short":"Collection"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"the descendants","type_short":"Set"}},{"javadoc":"Returns all ancestors for the given vertices in the given graph.  Ancestors for a given\n vertex are all nodes at the incoming side of an edge, as well as their incoming \n vertices, etc.\n@param g the graph\n@param vertices the vertices for which to find descendants\n@return the ancestors","static":true,"name":"getAncestors","comment":"Returns all ancestors for the given vertices in the given graph.  Ancestors for a given\n vertex are all nodes at the incoming side of an edge, as well as their incoming \n vertices, etc.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"java.util.Collection<V>","name":"vertices","comment":"the vertices for which to find descendants","type_short":"Collection"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"the ancestors","type_short":"Set"}},{"javadoc":"Returns a set of all edges that are reachable from the given vertex.\n@param g the graph\n@param v the vertex for which to get edges\n@param topDown true for outgoing edges; false for incoming edges\n@return the set of edges","static":true,"name":"getEdgesFrom","comment":"Returns a set of all edges that are reachable from the given vertex.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"V","name":"v","comment":"the vertex for which to get edges","type_short":"V"},{"type_long":"boolean","name":"topDown","comment":"true for outgoing edges; false for incoming edges","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"the set of edges","type_short":"Set"}},{"javadoc":"Returns a set of all edges that are reachable from the given collection of vertices.\n@param g the graph\n@param vertices the vertices for which to get edges\n@param topDown true for outgoing edges; false for incoming edges\n@return the set of edges","static":true,"name":"getEdgesFrom","comment":"Returns a set of all edges that are reachable from the given collection of vertices.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"java.util.Collection<V>","name":"vertices","comment":"the vertices for which to get edges","type_short":"Collection"},{"type_long":"boolean","name":"topDown","comment":"true for outgoing edges; false for incoming edges","type_short":"boolean"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"the set of edges","type_short":"Set"}},{"javadoc":"Creates a subgraph of the given graph for each edge of the given graph that is \n contained in the list of vertices.\n@param g the existing graph\n@param vertices the vertices to be in the new graph\n@return the new subgraph","static":true,"name":"createSubGraph","comment":"Creates a subgraph of the given graph for each edge of the given graph that is \n contained in the list of vertices.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the existing graph","type_short":"GDirectedGraph"},{"type_long":"java.util.Collection<V>","name":"vertices","comment":"the vertices to be in the new graph","type_short":"Collection"}],"throws":[],"return":{"type_long":"ghidra.graph.GDirectedGraph<V,E>","comment":"the new subgraph","type_short":"GDirectedGraph"}},{"javadoc":"Returns a list where each set therein is a strongly connected component of the given \n graph.  Each strongly connected component is that in which each vertex is reachable from\n any other vertex in that set.\n \n <P>This method can be used to determine reachability of a set of vertices.  \n \n <P>This can also be useful for cycle detection, as a multi-vertex strong component \n is by definition a cycle.  This method differs from \n {@link #findCircuits(GDirectedGraph, boolean, TaskMonitor)} in that the latter will \n return cycles within the strong components, or sub-cycles.\n@param g the graph\n@return the list of strongly connected components","static":true,"name":"getStronglyConnectedComponents","comment":"Returns a list where each set therein is a strongly connected component of the given \n graph.  Each strongly connected component is that in which each vertex is reachable from\n any other vertex in that set.\n \n This method can be used to determine reachability of a set of vertices.  \n \n This can also be useful for cycle detection, as a multi-vertex strong component \n is by definition a cycle.  This method differs from \n #findCircuits(GDirectedGraph, boolean, TaskMonitor) in that the latter will \n return cycles within the strong components, or sub-cycles.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"}],"throws":[],"return":{"type_long":"java.util.Set<java.util.Set<V>>","comment":"the list of strongly connected components","type_short":"Set"}},{"javadoc":"Returns all entry points in the given graph.  This includes sources, vertices which \n have no incoming edges, as well as strongly connected sub-graphs.  The latter being a \n group vertices where each vertex is reachable from every other vertex.  In the case of\n strongly connected components, we pick one of them arbitrarily to be the entry point.\n@param g the graph\n@return the entry points into the graph","static":true,"name":"getEntryPoints","comment":"Returns all entry points in the given graph.  This includes sources, vertices which \n have no incoming edges, as well as strongly connected sub-graphs.  The latter being a \n group vertices where each vertex is reachable from every other vertex.  In the case of\n strongly connected components, we pick one of them arbitrarily to be the entry point.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"the entry points into the graph","type_short":"Set"}},{"javadoc":"Returns the dominance tree of the given graph.  A dominator tree of the vertices where each \n node's children are those nodes it *immediately* dominates (a idom b)\n@param g the graph\n@param monitor the task monitor\n@return the tree\n@throws CancelledException if the monitor is cancelled","static":true,"name":"findDominanceTree","comment":"Returns the dominance tree of the given graph.  A dominator tree of the vertices where each \n node's children are those nodes it *immediately* dominates (a idom b)","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"}],"return":{"type_long":"ghidra.graph.GDirectedGraph<V,ghidra.graph.GEdge<V>>","comment":"the tree","type_short":"GDirectedGraph"}},{"javadoc":"Returns a set of all vertices that are dominated by the given vertex.  A node 'a' \n dominates node 'b' if all paths from start to 'b' contain 'a';\n a node always dominates itself (except in 'strict dominance', which is all\n dominators except for itself)\n@param g the graph\n@param from the vertex for which to find dominated vertices\n@param monitor the monitor\n@return the set of dominated vertices\n@throws CancelledException if the monitor is cancelled","static":true,"name":"findDominance","comment":"Returns a set of all vertices that are dominated by the given vertex.  A node 'a' \n dominates node 'b' if all paths from start to 'b' contain 'a';\n a node always dominates itself (except in 'strict dominance', which is all\n dominators except for itself)","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"V","name":"from","comment":"the vertex for which to find dominated vertices","type_short":"V"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"}],"return":{"type_long":"java.util.Set<V>","comment":"the set of dominated vertices","type_short":"Set"}},{"javadoc":"Returns a set of all vertices that are post-dominated by the given vertex.  A node 'b' \n is said to post-dominate node 'a' if all paths from 'a' to END contain 'b'.\n@param g the graph\n@param from the vertex for which to get post-dominated vertices\n@param monitor the monitor\n@return the post-dominated vertices\n@throws CancelledException if the monitor is cancelled","static":true,"name":"findPostDominance","comment":"Returns a set of all vertices that are post-dominated by the given vertex.  A node 'b' \n is said to post-dominate node 'a' if all paths from 'a' to END contain 'b'.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"V","name":"from","comment":"the vertex for which to get post-dominated vertices","type_short":"V"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"}],"return":{"type_long":"java.util.Set<V>","comment":"the post-dominated vertices","type_short":"Set"}},{"javadoc":"Finds all the circuits, or cycles, in the given graph.\n@param g the graph\n@param monitor the task monitor\n@return the circuits\n@throws CancelledException if the monitor is cancelled","static":true,"name":"findCircuits","comment":"Finds all the circuits, or cycles, in the given graph.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"}],"return":{"type_long":"java.util.List<java.util.List<V>>","comment":"the circuits","type_short":"List"}},{"javadoc":"Finds all the circuits, or cycles, in the given graph.\n@param g the graph\n@param uniqueCircuits true signals to return only unique circuits, where no two \n        circuits will contain the same vertex\n@param monitor the task monitor\n@return the circuits\n@throws CancelledException if the monitor is cancelled","static":true,"name":"findCircuits","comment":"Finds all the circuits, or cycles, in the given graph.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"boolean","name":"uniqueCircuits","comment":"true signals to return only unique circuits, where no two \n        circuits will contain the same vertex","type_short":"boolean"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"}],"return":{"type_long":"java.util.List<java.util.List<V>>","comment":"the circuits","type_short":"List"}},{"javadoc":"Finds all the circuits, or cycles, in the given graph.  <B>This version\n of <tt>findCircuits()<\/tt> takes a {@link TimeoutTaskMonitor}, which allows for the \n client to control the duration of work.<\/B>   This is useful for finding paths on very\n large, dense graphs.\n@param g the graph\n@param uniqueCircuits true signals to return only unique circuits, where no two \n        circuits will contain the same vertex\n@param monitor the timeout task monitor\n@return the circuits\n@throws CancelledException if the monitor is cancelled\n@throws TimeoutException if the algorithm times-out, as defined by the monitor","static":true,"name":"findCircuits","comment":"Finds all the circuits, or cycles, in the given graph.  This version\n of findCircuits() takes a TimeoutTaskMonitor, which allows for the \n client to control the duration of work.   This is useful for finding paths on very\n large, dense graphs.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"boolean","name":"uniqueCircuits","comment":"true signals to return only unique circuits, where no two \n        circuits will contain the same vertex","type_short":"boolean"},{"type_long":"ghidra.util.task.TimeoutTaskMonitor","name":"monitor","comment":"the timeout task monitor","type_short":"TimeoutTaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the monitor is cancelled","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.TimeoutException","comment":"if the algorithm times-out, as defined by the monitor","type_short":"TimeoutException"}],"return":{"type_long":"java.util.List<java.util.List<V>>","comment":"the circuits","type_short":"List"}},{"javadoc":"Finds all paths from <tt>start<\/tt> to <tt>end<\/tt> in the given graph.\n \n <P><B><U>Warning:<\/U><\/B> for large, dense graphs (those with many interconnected \n vertices) this algorithm could run indeterminately, possibly causing the JVM to \n run out of memory.\n \n <P>You are encouraged to call this method with a monitor that will limit the work to \n be done, such as the {@link TimeoutTaskMonitor}.\n@param g the graph\n@param start the start vertex\n@param end the end vertex\n@param accumulator the accumulator into which results will be placed\n@param monitor the task monitor\n@throws CancelledException if the operation is cancelled","static":true,"name":"findPaths","comment":"Finds all paths from start to end in the given graph.\n \n Warning: for large, dense graphs (those with many interconnected \n vertices) this algorithm could run indeterminately, possibly causing the JVM to \n run out of memory.\n \n You are encouraged to call this method with a monitor that will limit the work to \n be done, such as the TimeoutTaskMonitor.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"V","name":"start","comment":"the start vertex","type_short":"V"},{"type_long":"V","name":"end","comment":"the end vertex","type_short":"V"},{"type_long":"ghidra.util.datastruct.Accumulator<java.util.List<V>>","name":"accumulator","comment":"the accumulator into which results will be placed","type_short":"Accumulator"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"the task monitor","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the operation is cancelled","type_short":"CancelledException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Finds all paths from <tt>start<\/tt> to <tt>end<\/tt> in the given graph.  <B>This version\n of <tt>findPaths()<\/tt> takes a {@link TimeoutTaskMonitor}, which allows for the \n client to control the duration of work.<\/B>   This is useful for finding paths on very\n large, dense graphs.\n \n <P><B><U>Warning:<\/U><\/B> for large, dense graphs (those with many interconnected \n vertices) this algorithm could run indeterminately, possibly causing the JVM to \n run out of memory.\n@param g the graph\n@param start the start vertex\n@param end the end vertex\n@param accumulator the accumulator into which results will be placed\n@param monitor the timeout task monitor\n@throws CancelledException if the operation is cancelled\n@throws TimeoutException if the operation passes the timeout period","static":true,"name":"findPaths","comment":"Finds all paths from start to end in the given graph.  This version\n of findPaths() takes a TimeoutTaskMonitor, which allows for the \n client to control the duration of work.   This is useful for finding paths on very\n large, dense graphs.\n \n Warning: for large, dense graphs (those with many interconnected \n vertices) this algorithm could run indeterminately, possibly causing the JVM to \n run out of memory.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"V","name":"start","comment":"the start vertex","type_short":"V"},{"type_long":"V","name":"end","comment":"the end vertex","type_short":"V"},{"type_long":"ghidra.util.datastruct.Accumulator<java.util.List<V>>","name":"accumulator","comment":"the accumulator into which results will be placed","type_short":"Accumulator"},{"type_long":"ghidra.util.task.TimeoutTaskMonitor","name":"monitor","comment":"the timeout task monitor","type_short":"TimeoutTaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if the operation is cancelled","type_short":"CancelledException"},{"type_long":"ghidra.util.exception.TimeoutException","comment":"if the operation passes the timeout period","type_short":"TimeoutException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns the vertices of the graph in post-order.   Pre-order is the order the vertices\n are last visited when performing a depth-first traversal.\n@param g the graph\n@param navigator the knower of the direction the graph should be traversed\n@return the vertices","static":true,"name":"getVerticesInPostOrder","comment":"Returns the vertices of the graph in post-order.   Pre-order is the order the vertices\n are last visited when performing a depth-first traversal.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"ghidra.graph.algo.GraphNavigator<V,E>","name":"navigator","comment":"the knower of the direction the graph should be traversed","type_short":"GraphNavigator"}],"throws":[],"return":{"type_long":"java.util.List<V>","comment":"the vertices","type_short":"List"}},{"javadoc":"Returns the vertices of the graph in pre-order.   Pre-order is the order the vertices\n are encountered when performing a depth-first traversal.\n@param g the graph\n@param navigator the knower of the direction the graph should be traversed\n@return the vertices","static":true,"name":"getVerticesInPreOrder","comment":"Returns the vertices of the graph in pre-order.   Pre-order is the order the vertices\n are encountered when performing a depth-first traversal.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"ghidra.graph.algo.GraphNavigator<V,E>","name":"navigator","comment":"the knower of the direction the graph should be traversed","type_short":"GraphNavigator"}],"throws":[],"return":{"type_long":"java.util.List<V>","comment":"the vertices","type_short":"List"}},{"javadoc":"Calculates 'complexity depth', which is, for each vertex, the deepest\/longest path \n from that vertex for a depth-first traversal.   So, for a vertex with a single \n successor that has no children, the depth would be 1.\n@param g the graph\n@return the map of each vertex to its complexity depth","static":true,"name":"getComplexityDepth","comment":"Calculates 'complexity depth', which is, for each vertex, the deepest\/longest path \n from that vertex for a depth-first traversal.   So, for a vertex with a single \n successor that has no children, the depth would be 1.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"}],"throws":[],"return":{"type_long":"java.util.Map<V,java.lang.Integer>","comment":"the map of each vertex to its complexity depth","type_short":"Map"}},{"javadoc":"Retain all edges in the graph where each edge's endpoints are in the given set of \n vertices.\n@param graph the graph\n@param vertices the vertices of the edges to keep\n@return the set of edges","static":true,"name":"retainEdges","comment":"Retain all edges in the graph where each edge's endpoints are in the given set of \n vertices.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"graph","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"java.util.Set<V>","name":"vertices","comment":"the vertices of the edges to keep","type_short":"Set"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"the set of edges","type_short":"Set"}},{"javadoc":"Returns the set of vertices contained within the given edges.\n@param edges the edges\n@return the vertices","static":true,"name":"toVertices","comment":"Returns the set of vertices contained within the given edges.","params":[{"type_long":"java.util.Collection<E>","name":"edges","comment":"the edges","type_short":"Collection"}],"throws":[],"return":{"type_long":"java.util.Set<V>","comment":"the vertices","type_short":"Set"}},{"javadoc":"A method to debug the given graph by printing it.\n@param g the graph to print\n@param ps the output stream","static":true,"name":"printGraph","comment":"A method to debug the given graph by printing it.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph to print","type_short":"GDirectedGraph"},{"type_long":"java.io.PrintStream","name":"ps","comment":"the output stream","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns true if the given strong component has no incoming edges that are outside of \n the component.  This is useful to know, as it signals that the given strong component\n is reachable from outside of that component.\n@param g the graph\n@param strongComponent the set of vertices representing a strong component\n@return true if the given strong component has no incoming edges that are outside of \n \t\t   the component","static":true,"name":"isSelfContainedStrongComponent","comment":"Returns true if the given strong component has no incoming edges that are outside of \n the component.  This is useful to know, as it signals that the given strong component\n is reachable from outside of that component.","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"the graph","type_short":"GDirectedGraph"},{"type_long":"java.util.Set<V>","name":"strongComponent","comment":"the set of vertices representing a strong component","type_short":"Set"}],"throws":[],"return":{"type_long":"boolean","comment":"true if the given strong component has no incoming edges that are outside of \n \t\t   the component","type_short":"boolean"}},{"javadoc":"","static":true,"name":"getMaxChildLevel","comment":"","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"","type_short":"GDirectedGraph"},{"type_long":"java.util.Map<V,java.lang.Integer>","name":"levelMap","comment":"","type_short":"Map"},{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"int","comment":"","type_short":"int"}},{"javadoc":"","static":true,"name":"recursivePrint","comment":"","params":[{"type_long":"ghidra.graph.GDirectedGraph<V,E>","name":"g","comment":"","type_short":"GDirectedGraph"},{"type_long":"V","name":"v","comment":"","type_short":"V"},{"type_long":"java.util.Set<V>","name":"set","comment":"","type_short":"Set"},{"type_long":"int","name":"depth","comment":"","type_short":"int"},{"type_long":"java.io.PrintStream","name":"ps","comment":"","type_short":"PrintStream"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"GraphAlgorithms","comment":"A set of convenience methods for performing graph algorithms on a graph.\n \n Some definitions:\n \n \t   \n \t\tdominance: \n \t\t\t\t\ta node 'a' dominates node 'b' if all paths from start to 'b' contain 'a';\n\t\t            a node always dominates itself (except in 'strict dominance', which is all\n\t\t            dominators except for itself)\n\n\t   \n\t\tpost-dominance: \n\t\t\t\t\t A node 'b' is said to post-dominate node 'a' if all paths from 'a'\n\t\t             to END contain 'b'\n\n\t   \n\t\timmediate dominator: \n\t\t\t\t\tthe closest dominator of a node\n\n\t   \n\t\tdominance tree:  \n\t\t\t\t\tA dominator tree is a tree where each node's children are those nodes \n\t\t\t\t\tit *immediately* dominates (a idom b)\n\n     \n     \tdominance frontier: \n     \t\t\t\tthe immediate successors of the nodes dominated by 'a'; it is the set of \n     \t\t\t\tnodes where d's dominance stops.\n     \n     \n     \tstrongly connected components: \n     \t\t\t\ta graph is said to be strongly connected if every vertex is reachable \n     \t\t\t\tfrom every other vertex. The strongly connected components \n     \t\t\t\tof an arbitrary directed graph form a partition into \n     \t\t\t\tsubgraphs that are themselves strongly connected.\n     \n     \tgraph density:\n     \n                        E\n          Density =  --------\n                      V(V-1)\n\t\t\n ","fields":[]}
