{"implements":[],"javadoc":"A class that calculates flow between vertices and then triggers that flow to be painted\n in the UI.\n \n <P><B><U>Threading Policy:<\/U><\/B>  Some operations use algorithms that slow down, depending\n upon the graph size.  Further, some of these algorithms may not even complete.  To keep the\n graph responsive, this class will perform its work <I>in the future<\/I>.   The work we \n wish to do is further complicated by these requirements:\n <UL>\n \t<LI>Some data should be calculated only as needed, to avoid excessive work<\/LI>\n \t<LI>Many tasks depend on data to be calculated before they can perform their algorithm<\/LI>\n \t<LI>Results must be cached for speed, but may cleared as the graph is mutated<\/LI>\n  <LI>Algorithms must not block the UI thread<\/LI>\n  <LI>Related actions (i.e., hover vs. selection) should cancel any pending action, but not \n      unrelated actions (e.g., a new hover request should cancel a pending hover update)\n <\/UL>\n \n Based on these requirements, we need to use multi-threading.  Further complicating the need\n for multi-threading is that some operations depending on lazy-loaded data.  Finally, we \n have different types of actions, hovering vs. selecting a vertex, which should override \n previous related requests.   To accomplish this we use:\n <UL>\n \t<LI>{@link CompletableFuture} - to lazy-load and cache required algorithm data<\/LI>\n \t<LI>{@link RunManager}s - to queue requests so that new requests cancel old ones.  A \n      different Run Manager is used for each type of request.<\/LI>\n <\/UL>\n \t\t\n <P><B><U>Naming Conventions:<\/U><\/B>  There are many methods in this class, called from \n different threads.   For simplicity, we use the following conventions: \n <UL>\n \t<LI><CODE>fooAsync<\/CODE> - methods ending in <B>Async<\/B> indicate that they are to be \n                              called from a background thread.<\/LI>\n  <LI><CODE>fooSwing<\/CODE> - methods ending in <B>Swing<\/B> indicate that they are to be \n                              called from the Swing thread.<\/LI>                             \n \t<LI>*All public methods are assumed to be called on the Swing thread<\/LI>\n <\/UL>\n@param <V> the vertex type\n@param <E> the edge type","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[{"type_long":"ghidra.graph.VisualGraph<V,E>","name":"graph","comment":"","type_short":"VisualGraph"},{"type_long":"ghidra.graph.viewer.edge.PathHighlightListener","name":"listener","comment":"","type_short":"PathHighlightListener"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Sets the callback that signals when this path highlighter should not be performing any\n work\n@param pauser the callback that returns a boolean of true when this class should pause\n        its work.","static":false,"name":"setWorkPauser","comment":"Sets the callback that signals when this path highlighter should not be performing any\n work","params":[{"type_long":"ghidra.graph.viewer.edge.PathHighlighterWorkPauser","name":"pauser","comment":"the callback that returns a boolean of true when this class should pause\n        its work.","type_short":"PathHighlighterWorkPauser"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getGraphExecutor","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.concurrent.Executor","comment":"","type_short":"Executor"}},{"javadoc":"","static":false,"name":"lazyCreateDominaceFuture","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.concurrent.CompletableFuture<ghidra.graph.algo.ChkDominanceAlgorithm<V,E>>","comment":"","type_short":"CompletableFuture"}},{"javadoc":"","static":false,"name":"getDominanceGraph","comment":"","params":[{"type_long":"ghidra.graph.VisualGraph<V,E>","name":"visualGraph","comment":"","type_short":"VisualGraph"},{"type_long":"boolean","name":"forward","comment":"","type_short":"boolean"}],"throws":[],"return":{"type_long":"ghidra.graph.GDirectedGraph<V,E>","comment":"","type_short":"GDirectedGraph"}},{"javadoc":"","static":false,"name":"lazyCreatePostDominanceFuture","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.concurrent.CompletableFuture<ghidra.graph.algo.ChkDominanceAlgorithm<V,E>>","comment":"","type_short":"CompletableFuture"}},{"javadoc":"","static":false,"name":"lazyCreateCircuitFuture","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.concurrent.CompletableFuture<ghidra.graph.viewer.edge.VisualGraphPathHighlighter<V,E>.Circuits>","comment":"","type_short":"CompletableFuture"}},{"javadoc":"","static":false,"name":"setStatusTextSwing","comment":"","params":[{"type_long":"java.lang.String","name":"message","comment":"","type_short":"String"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Signals to this path highlighter that it should stop all background jobs","static":false,"name":"stop","comment":"Signals to this path highlighter that it should stop all background jobs","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"dispose","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isBusy","comment":"","params":[],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"getVertexHoverPathHighlightMode","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.graph.viewer.PathHighlightMode","comment":"","type_short":"PathHighlightMode"}},{"javadoc":"","static":false,"name":"getVertexFocusPathHighlightMode","comment":"","params":[],"throws":[],"return":{"type_long":"ghidra.graph.viewer.PathHighlightMode","comment":"","type_short":"PathHighlightMode"}},{"javadoc":"","static":false,"name":"setVertexFocusMode","comment":"","params":[{"type_long":"ghidra.graph.viewer.PathHighlightMode","name":"mode","comment":"","type_short":"PathHighlightMode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setVertexHoverMode","comment":"","params":[{"type_long":"ghidra.graph.viewer.PathHighlightMode","name":"mode","comment":"","type_short":"PathHighlightMode"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setHoveredVertex","comment":"","params":[{"type_long":"V","name":"hoveredVertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setFocusedVertex","comment":"","params":[{"type_long":"V","name":"focusedVertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"doUpdateFocusedVertex","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clearHoveredEdgesSwing","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clearFocusedEdgesSwing","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"clearEdgeCache","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"accumulateCircuitEdgesForCurrentStateOfGraphSwing","comment":"","params":[{"type_long":"java.util.Set<E>","name":"newAllCircuits","comment":"","type_short":"Set"},{"type_long":"java.util.Map<V,java.util.Set<E>>","name":"newCircuitsByVertex","comment":"","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"accumulateAllCircuitsSwing","comment":"","params":[{"type_long":"ghidra.graph.viewer.edge.VisualGraphPathHighlighter<V,E>.Circuits","name":"circuits","comment":"","type_short":"Circuits"},{"type_long":"java.util.Set<E>","name":"results","comment":"","type_short":"Set"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"accumulateVertexCircuitsSwing","comment":"","params":[{"type_long":"ghidra.graph.viewer.edge.VisualGraphPathHighlighter<V,E>.Circuits","name":"circuits","comment":"","type_short":"Circuits"},{"type_long":"java.util.Map<V,java.util.Set<E>>","name":"results","comment":"","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"ensureEdgeUpToDateSwing","comment":"","params":[{"type_long":"E","name":"edge","comment":"","type_short":"E"}],"throws":[],"return":{"type_long":"E","comment":"","type_short":"E"}},{"javadoc":"","static":false,"name":"findMatchingVertexSwing","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"V","comment":"","type_short":"V"}},{"javadoc":"","static":false,"name":"clearCacheSwing","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setInFocusedEdges","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setOutFocusedEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setForwardScopedFlowFocusedEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setReverseScopedFlowFocusedEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setInOutFocusedEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setVertexCycleFocusedEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setAllCycleFocusedEdgesSwing","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setInHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setOutHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setForwardScopedFlowHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setReverseScopedFlowHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setInOutHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setVertexCycleHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setVertexToVertexPathHoveredEdgesSwing","comment":"","params":[{"type_long":"V","name":"start","comment":"","type_short":"V"},{"type_long":"V","name":"end","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setInFocusedPathOnSwing","comment":"","params":[{"type_long":"java.util.Collection<E>","name":"edges","comment":"","type_short":"Collection"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setInHoverPathOnSwing","comment":"","params":[{"type_long":"java.util.Collection<E>","name":"edges","comment":"","type_short":"Collection"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"setEdgeCircuitsSwing","comment":"","params":[{"type_long":"java.util.Set<E>","name":"allCircuitResults","comment":"","type_short":"Set"},{"type_long":"java.util.Map<V,java.util.Set<E>>","name":"circuitFlowResults","comment":"","type_short":"Map"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"disposeSwing","comment":"","params":[{"type_long":"java.util.concurrent.CompletableFuture<T>","name":"cf","comment":"","type_short":"CompletableFuture"},{"type_long":"java.util.function.Consumer<T>","name":"clearer","comment":"","type_short":"Consumer"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"getForwardScopedFlowEdgesForVertexAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getForwardFlowEdgesForVertexAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getReverseFlowEdgesForVertexAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getFlowEdgesForVertexAsync","comment":"","params":[{"type_long":"boolean","name":"isForward","comment":"","type_short":"boolean"},{"type_long":"java.util.Map<V,java.util.Set<E>>","name":"cache","comment":"","type_short":"Map"},{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getAllCircuitFlowEdgesAsync","comment":"","params":[],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getReverseScopedFlowEdgesForVertexAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getCircuitEdgesAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"getAsync","comment":"","params":[{"type_long":"java.util.concurrent.CompletableFuture<T>","name":"cf","comment":"","type_short":"CompletableFuture"}],"throws":[],"return":{"type_long":"T","comment":"","type_short":"T"}},{"javadoc":"","static":false,"name":"calculateCircuitsAsync","comment":"","params":[{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"ghidra.graph.viewer.edge.VisualGraphPathHighlighter<V,E>.Circuits","comment":"","type_short":"Circuits"}},{"javadoc":"","static":false,"name":"pathToEdgesAsync","comment":"","params":[{"type_long":"java.util.List<V>","name":"path","comment":"","type_short":"List"}],"throws":[],"return":{"type_long":"java.util.List<E>","comment":"","type_short":"List"}},{"javadoc":"","static":false,"name":"findForwardScopedFlowAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"findReverseScopedFlowAsync","comment":"","params":[{"type_long":"V","name":"v","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"java.util.Set<E>","comment":"","type_short":"Set"}},{"javadoc":"","static":false,"name":"calculatePathsBetweenVerticesAsync","comment":"","params":[{"type_long":"V","name":"v1","comment":"","type_short":"V"},{"type_long":"V","name":"v2","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"VisualGraphPathHighlighter","comment":"A class that calculates flow between vertices and then triggers that flow to be painted\n in the UI.\n \n Threading Policy:  Some operations use algorithms that slow down, depending\n upon the graph size.  Further, some of these algorithms may not even complete.  To keep the\n graph responsive, this class will perform its work in the future.   The work we \n wish to do is further complicated by these requirements:\n \n \tSome data should be calculated only as needed, to avoid excessive work\n \tMany tasks depend on data to be calculated before they can perform their algorithm\n \tResults must be cached for speed, but may cleared as the graph is mutated\n  Algorithms must not block the UI thread\n  Related actions (i.e., hover vs. selection) should cancel any pending action, but not \n      unrelated actions (e.g., a new hover request should cancel a pending hover update)\n \n \n Based on these requirements, we need to use multi-threading.  Further complicating the need\n for multi-threading is that some operations depending on lazy-loaded data.  Finally, we \n have different types of actions, hovering vs. selecting a vertex, which should override \n previous related requests.   To accomplish this we use:\n \n \tCompletableFuture - to lazy-load and cache required algorithm data\n \tRunManagers - to queue requests so that new requests cancel old ones.  A \n      different Run Manager is used for each type of request.\n \n \t\t\n Naming Conventions:  There are many methods in this class, called from \n different threads.   For simplicity, we use the following conventions: \n \n \tfooAsync - methods ending in Async indicate that they are to be \n                              called from a background thread.\n  fooSwing - methods ending in Swing indicate that they are to be \n                              called from the Swing thread.                             \n \t*All public methods are assumed to be called on the Swing thread\n ","fields":[{"type_long":"int","javadoc":"","static":true,"name":"ALGORITHM_TIMEOUT","comment":"","type_short":"int","constant_value":"5"},{"type_long":"ghidra.graph.viewer.PathHighlightMode","javadoc":"","static":false,"name":"vertexFocusMode","comment":"","type_short":"PathHighlightMode","constant_value":null},{"type_long":"ghidra.graph.viewer.PathHighlightMode","javadoc":"","static":false,"name":"vertexHoverMode","comment":"","type_short":"PathHighlightMode","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<E>>","javadoc":"","static":false,"name":"forwardFlowEdgeCache","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<E>>","javadoc":"","static":false,"name":"reverseFlowEdgeCache","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<E>>","javadoc":"","static":false,"name":"forwardScopedFlowEdgeCache","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Map<V,java.util.Set<E>>","javadoc":"","static":false,"name":"reverseScopedFlowEdgeCache","comment":"","type_short":"Map","constant_value":null},{"type_long":"ghidra.graph.VisualGraph<V,E>","javadoc":"","static":false,"name":"graph","comment":"","type_short":"VisualGraph","constant_value":null},{"type_long":"ghidra.util.task.RunManager","javadoc":"","static":false,"name":"hoverRunManager","comment":"","type_short":"RunManager","constant_value":null},{"type_long":"ghidra.util.task.RunManager","javadoc":"","static":false,"name":"focusRunManager","comment":"","type_short":"RunManager","constant_value":null},{"type_long":"java.util.concurrent.CompletableFuture<ghidra.graph.algo.ChkDominanceAlgorithm<V,E>>","javadoc":"","static":false,"name":"dominanceFuture","comment":"","type_short":"CompletableFuture","constant_value":null},{"type_long":"java.util.concurrent.CompletableFuture<ghidra.graph.algo.ChkDominanceAlgorithm<V,E>>","javadoc":"","static":false,"name":"postDominanceFuture","comment":"","type_short":"CompletableFuture","constant_value":null},{"type_long":"java.util.concurrent.CompletableFuture<ghidra.graph.viewer.edge.VisualGraphPathHighlighter<V,E>.Circuits>","javadoc":"","static":false,"name":"circuitFuture","comment":"","type_short":"CompletableFuture","constant_value":null},{"type_long":"ghidra.graph.viewer.edge.PathHighlightListener","javadoc":"","static":false,"name":"listener","comment":"","type_short":"PathHighlightListener","constant_value":null},{"type_long":"ghidra.graph.viewer.edge.PathHighlighterWorkPauser","javadoc":"","static":false,"name":"workPauser","comment":"","type_short":"PathHighlighterWorkPauser","constant_value":null},{"type_long":"ghidra.util.task.SwingUpdateManager","javadoc":"","static":false,"name":"focusedVertexUpdater","comment":"","type_short":"SwingUpdateManager","constant_value":null}]}
