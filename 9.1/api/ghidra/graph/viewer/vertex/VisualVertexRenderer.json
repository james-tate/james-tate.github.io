{"implements":[],"javadoc":"A renderer for the {@link VisualGraph} system.\n \n <p>Rendering in the graph system is a bit different than other Java rendering systems.  For\n example, when a JTable renders itself, it uses a single renderer to stamp the data.  The \n table's renderer has no state and is updated for each cell's data that is to be rendered.\n The graph renderer system is different due to the possibility of complex vertex UIs.  Some\n vertices have sophisticated UI elements that have state.  For these vertices, it makes sense\n for the vertex to build and maintain that state; having that state repeatedly built by the\n renderer would be extremely inefficient and difficult to implement.  Considering that we \n expect the vertex to build and maintain its UI, this renderer is really just a tool to:\n <ol>\n  <li>Determine if the vertex needs to be painted (by clipping or filtering)\n  <\/li>\n  <li>Setup the geometry for the vertex (convert the model's location to the view location,\n      accounting for panning and zooming)\n  <\/li>\n  <li>Paint any added effects (such as drop-shadows or highlighting)\n  <\/li>\n <\/ol>\n@param <V> the vertex type\n@param <E> the edge type","static":false,"extends":"ghidra.graph.viewer.vertex.AbstractVisualVertexRenderer","methods":[{"javadoc":"","static":false,"name":"<init>","comment":"","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"paintVertex","comment":"","params":[{"type_long":"edu.uci.ics.jung.visualization.RenderContext<V,E>","name":"rc","comment":"","type_short":"RenderContext"},{"type_long":"edu.uci.ics.jung.algorithms.layout.Layout<V,E>","name":"layout","comment":"","type_short":"Layout"},{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"paintDropShadow","comment":"","params":[{"type_long":"edu.uci.ics.jung.visualization.RenderContext<V,E>","name":"rc","comment":"","type_short":"RenderContext"},{"type_long":"edu.uci.ics.jung.visualization.transform.shape.GraphicsDecorator","name":"g","comment":"","type_short":"GraphicsDecorator"},{"type_long":"java.awt.Shape","name":"shape","comment":"","type_short":"Shape"},{"type_long":"V","name":"vertex","comment":"","type_short":"V"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"paintVertexOrVertexShape","comment":"","params":[{"type_long":"edu.uci.ics.jung.visualization.RenderContext<V,E>","name":"rc","comment":"","type_short":"RenderContext"},{"type_long":"edu.uci.ics.jung.visualization.transform.shape.GraphicsDecorator","name":"g","comment":"","type_short":"GraphicsDecorator"},{"type_long":"edu.uci.ics.jung.algorithms.layout.Layout<V,E>","name":"layout","comment":"","type_short":"Layout"},{"type_long":"V","name":"vertex","comment":"","type_short":"V"},{"type_long":"java.awt.Shape","name":"compactShape","comment":"","type_short":"Shape"},{"type_long":"java.awt.Shape","name":"fullShape","comment":"","type_short":"Shape"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"paintVertex","comment":"","params":[{"type_long":"edu.uci.ics.jung.visualization.RenderContext<V,E>","name":"rc","comment":"","type_short":"RenderContext"},{"type_long":"edu.uci.ics.jung.visualization.transform.shape.GraphicsDecorator","name":"g","comment":"","type_short":"GraphicsDecorator"},{"type_long":"V","name":"vertex","comment":"","type_short":"V"},{"type_long":"java.awt.Rectangle","name":"bounds","comment":"","type_short":"Rectangle"},{"type_long":"edu.uci.ics.jung.algorithms.layout.Layout<V,E>","name":"layout","comment":"","type_short":"Layout"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"isScaledPastVertexPaintingThreshold","comment":"","params":[{"type_long":"edu.uci.ics.jung.visualization.RenderContext<V,E>","name":"rc","comment":"","type_short":"RenderContext"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"","static":false,"name":"paintScaledVertex","comment":"","params":[{"type_long":"edu.uci.ics.jung.visualization.RenderContext<V,E>","name":"rc","comment":"","type_short":"RenderContext"},{"type_long":"V","name":"vertex","comment":"","type_short":"V"},{"type_long":"edu.uci.ics.jung.visualization.transform.shape.GraphicsDecorator","name":"g","comment":"","type_short":"GraphicsDecorator"},{"type_long":"java.awt.Shape","name":"shape","comment":"","type_short":"Shape"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}}],"name":"VisualVertexRenderer","comment":"A renderer for the VisualGraph system.\n \n Rendering in the graph system is a bit different than other Java rendering systems.  For\n example, when a JTable renders itself, it uses a single renderer to stamp the data.  The \n table's renderer has no state and is updated for each cell's data that is to be rendered.\n The graph renderer system is different due to the possibility of complex vertex UIs.  Some\n vertices have sophisticated UI elements that have state.  For these vertices, it makes sense\n for the vertex to build and maintain that state; having that state repeatedly built by the\n renderer would be extremely inefficient and difficult to implement.  Considering that we \n expect the vertex to build and maintain its UI, this renderer is really just a tool to:\n \n  Determine if the vertex needs to be painted (by clipping or filtering)\n  \n  Setup the geometry for the vertex (convert the model's location to the view location,\n      accounting for panning and zooming)\n  \n  Paint any added effects (such as drop-shadows or highlighting)\n  \n ","fields":[]}
