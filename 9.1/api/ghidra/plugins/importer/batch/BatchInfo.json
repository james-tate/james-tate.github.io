{"implements":[],"javadoc":"This is the main state of a batch import task, containing the segregated groupings of\n applications.\n <p>\n This class also handles populating the batch groups by recursively descending into files\n and the contents of those files.","static":false,"extends":"java.lang.Object","methods":[{"javadoc":"Creates a new BatchInfo object with a default {@link #maxDepth}.","static":false,"name":"<init>","comment":"Creates a new BatchInfo object with a default #maxDepth.","params":[],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Creates a new BatchInfo object using the specified maxDepth.\n@param maxDepth see {@link #maxDepth}.","static":false,"name":"<init>","comment":"Creates a new BatchInfo object using the specified maxDepth.","params":[{"type_long":"int","name":"maxDepth","comment":"see #maxDepth.","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Returns a list of the {@link BatchGroup}s that have been found when processing\n the added files.\n@return {@link List} of {@link BatchGroup}s.","static":false,"name":"getGroups","comment":"Returns a list of the BatchGroups that have been found when processing\n the added files.","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.plugins.importer.batch.BatchGroup>","comment":"List of BatchGroups.","type_short":"List"}},{"javadoc":"Returns the count of how many importable objects (ie. {@link LoadSpec}s) were found.\n@return count of importable objects.","static":false,"name":"getTotalCount","comment":"Returns the count of how many importable objects (ie. LoadSpecs) were found.","params":[],"throws":[],"return":{"type_long":"int","comment":"count of importable objects.","type_short":"int"}},{"javadoc":"Returns the count of how many files were found while processing the source files.\n@return count of files found while processing source files.","static":false,"name":"getTotalRawCount","comment":"Returns the count of how many files were found while processing the source files.","params":[],"throws":[],"return":{"type_long":"int","comment":"count of files found while processing source files.","type_short":"int"}},{"javadoc":"Returns the count of applications in enabled {@link BatchGroup}s... in other\n words, the number of objects that would be imported during this batch.\n@return count of enabled applications.","static":false,"name":"getEnabledCount","comment":"Returns the count of applications in enabled BatchGroups... in other\n words, the number of objects that would be imported during this batch.","params":[],"throws":[],"return":{"type_long":"int","comment":"count of enabled applications.","type_short":"int"}},{"javadoc":"Removes a user-added source file (and all the embedded files inside it) from this\n batch.\n@param fsrl {@link FSRL} of the file to remove.","static":false,"name":"remove","comment":"Removes a user-added source file (and all the embedded files inside it) from this\n batch.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the file to remove.","type_short":"FSRL"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds a file to this batch as the direct result of a user action.\n <p>\n If the file is a container for other files, this method will iterate through those\n child files and recursively try to add them using this method.\n <p>\n@param fsrl {@link FSRL} of the file to add.\n@param taskMonitor {@link TaskMonitor} to watch and update with progress.\n@return boolean true if something in the the file produced something to import.\n@throws IOException if io error when reading files.\n@throws CancelledException if user cancels.","static":false,"name":"addFile","comment":"Adds a file to this batch as the direct result of a user action.\n \n If the file is a container for other files, this method will iterate through those\n child files and recursively try to add them using this method.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the file to add.","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"taskMonitor","comment":"TaskMonitor to watch and update with progress.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if io error when reading files.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"boolean true if something in the the file produced something to import.","type_short":"boolean"}},{"javadoc":"The main worker for adding a file to the batch session.\n <p>\n The file is probed for high-priority filesystems first, then if no matches,\n Ghidra loaders, and then if no matches, all filesystems.\n <p>\n@param fsrl {@link FSRL} of the file to probe and process\n@param taskMonitor {@link TaskMonitor} to watch and update.\n@return boolean true if something in the the file produced something to import.\n@throws IOException if io error when reading files.\n@throws CancelledException if user cancels.","static":false,"name":"doAddFile","comment":"The main worker for adding a file to the batch session.\n \n The file is probed for high-priority filesystems first, then if no matches,\n Ghidra loaders, and then if no matches, all filesystems.\n ","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the file to probe and process","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"taskMonitor","comment":"TaskMonitor to watch and update.","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if io error when reading files.","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"boolean true if something in the the file produced something to import.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"shouldTerminateRecurse","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"","type_short":"FSRL"}],"throws":[],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Returns true if any of the user source files had containers that were not\n recursed into because of the {@link #maxDepth} limit.\n@return true if any of the user source files had containers that were not\n recursed into because of the {@link #maxDepth} limit.","static":false,"name":"wasRecurseTerminatedEarly","comment":"Returns true if any of the user source files had containers that were not\n recursed into because of the #maxDepth limit.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if any of the user source files had containers that were not\n recursed into because of the #maxDepth limit.","type_short":"boolean"}},{"javadoc":"Checks the found applications and returns true if only a single binary was found,\n even if multiple loaders claim it.\n@return true if single binary and batch is probably not correct importer.","static":false,"name":"isSingleApp","comment":"Checks the found applications and returns true if only a single binary was found,\n even if multiple loaders claim it.","params":[],"throws":[],"return":{"type_long":"boolean","comment":"true if single binary and batch is probably not correct importer.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"toString","comment":"","params":[],"throws":[],"return":{"type_long":"java.lang.String","comment":"","type_short":"String"}},{"javadoc":"","static":false,"name":"processAsFS","comment":"","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"taskMonitor","comment":"","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"","type_short":"boolean"}},{"javadoc":"Recursively handles files in an already opened GFileSystem.\n@param fs {@link GFileSystem} containing the startDir\n@param startDir {@link GFile} ref to the directory to process, null if root of the filesystem.\n@param taskMonitor {@link TaskMonitor} to watch and update.\n@throws CancelledException if user cancels\n@throws IOException if io error while reading files.","static":false,"name":"processFS","comment":"Recursively handles files in an already opened GFileSystem.","params":[{"type_long":"ghidra.formats.gfilesystem.GFileSystem","name":"fs","comment":"GFileSystem containing the startDir","type_short":"GFileSystem"},{"type_long":"ghidra.formats.gfilesystem.GFile","name":"startDir","comment":"GFile ref to the directory to process, null if root of the filesystem.","type_short":"GFile"},{"type_long":"ghidra.util.task.TaskMonitor","name":"taskMonitor","comment":"TaskMonitor to watch and update.","type_short":"TaskMonitor"}],"throws":[{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels","type_short":"CancelledException"},{"type_long":"java.io.IOException","comment":"if io error while reading files.","type_short":"IOException"}],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Tries to open a file using Ghidra {@link Loader}s.\n <p>\n The {@link BinaryLoader} is unconditionally skipped.\n@param fsrl {@link FSRL} of the file to open\n@param monitor {@link TaskMonitor} to use\n@return boolean true if successfully processed with a loader, false if no loader claimed\n the file.\n@throws IOException if io error during processing\n@throws CancelledException if user cancels.","static":false,"name":"processWithLoader","comment":"Tries to open a file using Ghidra Loaders.\n \n The BinaryLoader is unconditionally skipped.","params":[{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"FSRL of the file to open","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"TaskMonitor to use","type_short":"TaskMonitor"}],"throws":[{"type_long":"java.io.IOException","comment":"if io error during processing","type_short":"IOException"},{"type_long":"ghidra.util.exception.CancelledException","comment":"if user cancels.","type_short":"CancelledException"}],"return":{"type_long":"boolean","comment":"boolean true if successfully processed with a loader, false if no loader claimed\n the file.","type_short":"boolean"}},{"javadoc":"","static":false,"name":"pollLoadersForLoadSpecs","comment":"","params":[{"type_long":"ghidra.app.util.bin.ByteProvider","name":"provider","comment":"","type_short":"ByteProvider"},{"type_long":"ghidra.formats.gfilesystem.FSRL","name":"fsrl","comment":"","type_short":"FSRL"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"java.util.Map<ghidra.app.util.opinion.Loader,java.util.Collection<ghidra.app.util.opinion.LoadSpec>>","comment":"","type_short":"Map"}},{"javadoc":"Returns the {@link List} of files added via {@link #addFile(FSRL, TaskMonitor)}.\n@return {@link List} of files added via {@link #addFile(FSRL, TaskMonitor)}.","static":false,"name":"getUserAddedSources","comment":"Returns the List of files added via #addFile(FSRL, TaskMonitor).","params":[],"throws":[],"return":{"type_long":"java.util.List<ghidra.plugins.importer.batch.UserAddedSourceInfo>","comment":"List of files added via #addFile(FSRL, TaskMonitor).","type_short":"List"}},{"javadoc":"Maximum depth of containers (ie. filesystems) to recurse into when processing\n a file added by the user\n@return the current maximum depth of containers (ie. filesystems) to recurse into when processing\n a file added by the user.","static":false,"name":"getMaxDepth","comment":"Maximum depth of containers (ie. filesystems) to recurse into when processing\n a file added by the user","params":[],"throws":[],"return":{"type_long":"int","comment":"the current maximum depth of containers (ie. filesystems) to recurse into when processing\n a file added by the user.","type_short":"int"}},{"javadoc":"Sets a new max container recursive depth limit for this batch import\n <p>\n Doing this requires rescanning all original user-added source files and stopping\n at the new max depth.\n <p>\n@param newMaxDepth new value for the max depth","static":false,"name":"setMaxDepth","comment":"Sets a new max container recursive depth limit for this batch import\n \n Doing this requires rescanning all original user-added source files and stopping\n at the new max depth.\n ","params":[{"type_long":"int","name":"newMaxDepth","comment":"new value for the max depth","type_short":"int"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"Adds the given files to this batch import\n@param filesToAdd the files to add\n@return any files that failed to load; exceptions will be logged","static":false,"name":"addFiles","comment":"Adds the given files to this batch import","params":[{"type_long":"java.util.List<ghidra.formats.gfilesystem.FSRL>","name":"filesToAdd","comment":"the files to add","type_short":"List"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.formats.gfilesystem.FSRL>","comment":"any files that failed to load; exceptions will be logged","type_short":"List"}},{"javadoc":"","static":false,"name":"doSetMaxDepth","comment":"","params":[{"type_long":"int","name":"newMaxDepth","comment":"","type_short":"int"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"void","comment":"","type_short":"void"}},{"javadoc":"","static":false,"name":"doAddFiles","comment":"","params":[{"type_long":"java.util.List<ghidra.formats.gfilesystem.FSRL>","name":"filesToAdd","comment":"","type_short":"List"},{"type_long":"ghidra.util.task.TaskMonitor","name":"monitor","comment":"","type_short":"TaskMonitor"}],"throws":[],"return":{"type_long":"java.util.List<ghidra.formats.gfilesystem.FSRL>","comment":"","type_short":"List"}}],"name":"BatchInfo","comment":"This is the main state of a batch import task, containing the segregated groupings of\n applications.\n \n This class also handles populating the batch groups by recursively descending into files\n and the contents of those files.","fields":[{"type_long":"int","javadoc":"","static":true,"name":"MAXDEPTH_UNLIMITED","comment":"","type_short":"int","constant_value":"-1"},{"type_long":"int","javadoc":"","static":true,"name":"MAXDEPTH_DEFAULT","comment":"","type_short":"int","constant_value":"2"},{"type_long":"java.util.Map<ghidra.plugins.importer.batch.BatchSegregatingCriteria,ghidra.plugins.importer.batch.BatchGroup>","javadoc":"","static":false,"name":"groupsByCriteria","comment":"","type_short":"Map","constant_value":null},{"type_long":"java.util.Set<ghidra.formats.gfilesystem.FSRL>","javadoc":"","static":false,"name":"userAddedFSRLs","comment":"","type_short":"Set","constant_value":null},{"type_long":"java.util.List<ghidra.plugins.importer.batch.UserAddedSourceInfo>","javadoc":"","static":false,"name":"userAddedSources","comment":"","type_short":"List","constant_value":null},{"type_long":"int","javadoc":"Maximum depth of containers (ie. filesystems) to recurse into when processing\n a file added by the user.\n <p>\n maxDepth of less than or equal to 0 == unlimited.\n <p>\n maxDepth of 1 == no recursing into containers found in added file, just try it\n with a loader.\n <p>\n Default is {@link #MAXDEPTH_DEFAULT}.","static":false,"name":"maxDepth","comment":"Maximum depth of containers (ie. filesystems) to recurse into when processing\n a file added by the user.\n \n maxDepth of less than or equal to 0 == unlimited.\n \n maxDepth of 1 == no recursing into containers found in added file, just try it\n with a loader.\n \n Default is #MAXDEPTH_DEFAULT.","type_short":"int","constant_value":null},{"type_long":"ghidra.plugins.importer.batch.UserAddedSourceInfo","javadoc":"","static":false,"name":"currentUASI","comment":"","type_short":"UserAddedSourceInfo","constant_value":null}]}
